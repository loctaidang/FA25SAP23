*&---------------------------------------------------------------------*
*& Report ZFA25SAP23
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zfa25sap23.

INCLUDE zfa25sap23_top.     "Khai báo biến toàn cục, TYPE, constant
INCLUDE zfa25sap23_sel.     "Selection screen
INCLUDE zfa25sap23_auth.    "Check whitelist + AUTHORITY-CHECK
INCLUDE zfa25sap23_ddic.    "Metadata + RTTC/RTTS + fieldcatalog
INCLUDE zfa25sap23_alv.     "ALV show + event
INCLUDE zfa25sap23_io.      "Upload/Download CSV, clipboard
INCLUDE zfa25sap23_audit.   "Audit log + rollback
INCLUDE zfa25sap23_db.      "Load/Save DB
INCLUDE zfa25sap23_main.    "START-OF-SELECTION + flow chính
INCLUDE zfa25sap23_f01.     "FORM rollBack"
*&---------------------------------------------------------------------*

"===== INCLUDE ZFA25SAP23_TOP =====


TYPE-POOLS: abap.
CLASS lcl_alv_handler DEFINITION DEFERRED.

DATA: gv_toolbar_mode TYPE c LENGTH 1 VALUE 'D'. " 'D' = display, 'E' = edit

"––– Dữ liệu động (itab) cho mọi bảng
DATA: gr_data TYPE REF TO data.
FIELD-SYMBOLS: <gt_data> TYPE STANDARD TABLE,
               <gs_wa>   TYPE any.
"––– Ghi log lỗi chi tiết để hiển thị + debug
TYPES: BEGIN OF ty_error_log,
         row   TYPE i,
         col   TYPE i,
         field TYPE fieldname,
         value TYPE string,
         msg   TYPE string,
       END OF ty_error_log,
       ty_t_error_log TYPE STANDARD TABLE OF ty_error_log WITH DEFAULT KEY.

DATA: gt_error_log TYPE ty_t_error_log.
DATA gv_keys_tabname TYPE tabname.
DATA lv_msg TYPE string.

"––– Cấu trúc style để highlight lỗi trong ALV
TYPES: BEGIN OF ty_cell_style,
         fieldname TYPE fieldname,
         style     TYPE lvc_s_styl,
       END OF ty_cell_style,
       ty_t_celltab TYPE STANDARD TABLE OF ty_cell_style WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_upload_error,
           row_id    TYPE i,        " Dòng Excel
           col_name  TYPE string,   " Tên cột
           value     TYPE string,   " Giá trị sai
           message   TYPE string,   " Nội dung lỗi
         END OF ty_upload_error.

"––– ALV objects & cấu hình
DATA: g_container TYPE REF TO cl_gui_custom_container,
      g_alv_grid  TYPE REF TO cl_gui_alv_grid,
      g_okcode    TYPE sy-ucomm,
      g_handler   TYPE REF TO lcl_alv_handler,
      gv_edit_md  TYPE abap_bool VALUE abap_false.

DATA: gt_dc_del_rows TYPE lvc_t_roid, " giữ danh sách dòng ALV báo xóa
      gv_from_dc     TYPE abap_bool.  " cờ: xóa từ data_changed (phím Delete)

DATA: gt_fieldcat TYPE lvc_t_fcat,
      gs_fieldcat TYPE lvc_s_fcat,
      gs_layout   TYPE lvc_s_layo.
TYPES: ty_fieldnames TYPE STANDARD TABLE OF fieldname WITH EMPTY KEY.
DATA: gt_fieldnames TYPE ty_fieldnames.
CONSTANTS: gc_cc_alv TYPE scrfname VALUE 'CC_ALV'.

DATA: gv_add_mode TYPE abap_bool VALUE abap_false.

"Cache danh sách trường khoá
DATA gt_key_fields TYPE STANDARD TABLE OF dd03l-fieldname WITH DEFAULT KEY.

"Buffer audit
TYPES: BEGIN OF ty_audit,
         logid       TYPE char32,
         uname       TYPE syuname,
         udate       TYPE sydatum,
         utime       TYPE syuzeit,
         tabname     TYPE tabname,
         action      TYPE char10,
         before_json TYPE zde_json_txt,
         after_json  TYPE zde_json_txt,
       END OF ty_audit.
DATA gt_audit TYPE STANDARD TABLE OF ty_audit WITH DEFAULT KEY.

DATA gv_dirty TYPE abap_bool VALUE abap_false.
DATA gv_del_newrec_only TYPE abap_bool VALUE abap_false.
DATA: gv_dirty_nonnewrec TYPE abap_bool VALUE abap_false.


TYPES: ty_fname TYPE lvc_fname.
DATA: gt_f4_whitelist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line,
      gt_f4_blacklist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line.
DATA gr_data_original TYPE REF TO data.

DATA: gv_can_create  TYPE abap_bool,
      gv_can_change  TYPE abap_bool,
      gv_can_delete  TYPE abap_bool,
      gv_can_display TYPE abap_bool.
DATA gt_added_audit_fields TYPE TABLE OF fieldname WITH EMPTY KEY.
DATA gt_tb_excl TYPE ui_functions.

TYPES: ty_keyhash TYPE string.
DATA: gt_changed_existing_keys TYPE HASHED TABLE OF ty_keyhash WITH UNIQUE KEY table_line.
DATA gv_in_upload TYPE abap_bool VALUE abap_false.


"Types cho payload thay đổi (SAVE email)
TYPES: BEGIN OF zty_change,
         row_key         TYPE string,        " key hợp nhất (text)
         change_type     TYPE c LENGTH 1,    " '+' insert, '~' update, '-' delete
         changed_columns TYPE string,        " CSV tên cột đổi (cho UPDATE)
         before_json     TYPE zde_json_txt,  " dùng cùng định dạng JSON như ty_audit
         after_json      TYPE zde_json_txt,
       END OF zty_change.

TYPES: zty_change_tab TYPE STANDARD TABLE OF zty_change WITH DEFAULT KEY.

TYPES: BEGIN OF ty_fp,
         fp TYPE string,
       END OF ty_fp.
TYPES: BEGIN OF ty_val_error,
         row_idx   TYPE i,          " Chỉ số dòng trong ALV
         fieldname TYPE fieldname,  " Tên cột bị lỗi
         msg       TYPE string,     " Thông báo lỗi
       END OF ty_val_error.

DATA: gt_val_errors TYPE STANDARD TABLE OF ty_val_error.

"=====================================================================

"===== INCLUDE ZFA25SAP23_SEL =====

" Khối tham số
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-001.
  PARAMETERS:
*    p_tab    TYPE tabname OBLIGATORY, "Bảng Z*
    p_tab    TYPE tabname,
    p_maxrow TYPE i DEFAULT 200.
SELECTION-SCREEN END OF BLOCK b1.

" F4 cho tên bảng

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tab.
  PERFORM f4_tabname.

  " Kiểm tra hợp lệ khi người dùng nhấn Execute

AT SELECTION-SCREEN.
  PERFORM validate_tab.
  PERFORM validate_maxrow.

  "Validate bảng
FORM validate_tab.
  " Chưa nhập
  IF p_tab IS INITIAL.
    MESSAGE TEXT-002 TYPE 'E'.
  ENDIF.

  "===== Kiểm tra bảng có tồn tại trong DDIC =====
  SELECT SINGLE tabname
    FROM dd02l
    INTO @DATA(lv_exist)
    WHERE tabname = @p_tab.

  IF sy-subrc <> 0.
    lv_msg = TEXT-150.   " Table &1 does not exist.
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'E'.
  ENDIF.


  " Bảng phải là Z*, transparent, active
  SELECT SINGLE tabname
    FROM dd02l
    INTO @DATA(lv_tab)
    WHERE tabname  = @p_tab
      AND tabclass = 'TRANSP'
  AND as4local = 'A'
  AND tabname  LIKE 'Z%'.

  IF sy-subrc <> 0.

    lv_msg = TEXT-003.
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'E'.


*    MESSAGE e398(00) WITH |Bảng { p_tab } không hợp lệ (chỉ Z* active).|.
  ENDIF.
ENDFORM.

"Validate p_maxrow
FORM validate_maxrow.
  IF p_maxrow IS INITIAL OR p_maxrow <= 0.
*    MESSAGE e398(00) WITH 'p_maxrow phải > 0'.
    MESSAGE TEXT-004 TYPE 'E'.

  ENDIF.
ENDFORM.

" Subroutine: F4 chọn bảng Z* active
FORM f4_tabname.
  TYPES: BEGIN OF ty_tab,
           tabname TYPE dd02l-tabname,
         END OF ty_tab.
  DATA: lt_tabs TYPE STANDARD TABLE OF ty_tab,
        lt_ret  TYPE TABLE OF ddshretval.

  SELECT tabname
    FROM dd02l
    INTO TABLE lt_tabs
    WHERE tabname LIKE 'Z%'
      AND tabclass = 'TRANSP'
  AND as4local = 'A'
  ORDER BY tabname.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'TABNAME'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = 'P_TAB'
      value_org       = 'S'
    TABLES
      value_tab       = lt_tabs
      return_tab      = lt_ret
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
    READ TABLE lt_ret INDEX 1 INTO DATA(ls_ret).
    IF sy-subrc = 0.
      p_tab = ls_ret-fieldval.
    ENDIF.
  ENDIF.
ENDFORM.

*----------------------------------------------------------------------*
*  Include: ZFA25SAP23_AUTH
*----------------------------------------------------------------------*
FORM check_authorization .
  DATA: lv_can_create  TYPE abap_bool,
        lv_can_change  TYPE abap_bool,
        lv_can_delete  TYPE abap_bool,
        lv_can_display TYPE abap_bool.

  " Kiểm tra quyền bằng form has_actvt
  PERFORM has_actvt USING '01' CHANGING lv_can_create.
  PERFORM has_actvt USING '02' CHANGING lv_can_change.
  PERFORM has_actvt USING '06' CHANGING lv_can_delete.
  PERFORM has_actvt USING '03' CHANGING lv_can_display.

  "Xử lý nếu không có quyền change
  IF lv_can_change = abap_false.
    " 1. Tắt cờ Edit Mode (Để lưới ALV xám màu ngay từ đầu)
    gv_edit_md = abap_false.

    " 2. Tắt cờ Add Mode
    gv_add_mode = abap_false.

    " 3. Chuyển toolbar về chế độ Display
    gv_toolbar_mode = 'D'.

    " 4. Thông báo (Chỉ hiện nếu họ có quyền xem nhưng ko có quyền sửa)
    IF lv_can_display = abap_true.
      MESSAGE s000(38) WITH 'Bạn chỉ có quyền xem (Read-Only) đối với bảng' p_tab.
    ENDIF.
  ENDIF.

  "--- Lưu lại quyền để toolbar ẩn/hiện nút
  gv_can_create  = lv_can_create.
  gv_can_change  = lv_can_change.
  gv_can_delete  = lv_can_delete.
  gv_can_display = lv_can_display.

ENDFORM.


FORM has_actvt USING iv_act TYPE activ_auth CHANGING ev_ok TYPE abap_bool.
  ev_ok = abap_false.

  " 1.Quyền dùng Tool (Object ZFA25SAP23)
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD iv_act.
  IF sy-subrc = 0.

    " 2.Quyền Sửa Bảng Cụ Thể (S_TABU_NAM)
    AUTHORITY-CHECK OBJECT 'S_TABU_NAM'
             ID 'TABLE' FIELD p_tab
             ID 'ACTVT' FIELD iv_act.

    IF sy-subrc = 0.
      " Chỉ khi qua cả 2 thì mới OK
      ev_ok = abap_true.
    ENDIF.

  ENDIF.
ENDFORM.

FORM lock_current_table USING    iv_tab TYPE tabname
                        CHANGING ev_ok  TYPE abap_bool.

  ev_ok = abap_false.

  CALL FUNCTION 'ENQUEUE_E_TABLE'
    EXPORTING
      tabname        = iv_tab
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.

  CASE sy-subrc.
    WHEN 0.
      ev_ok = abap_true.
    WHEN 1.

      DATA(lv_locked_by) = sy-msgv1.

*      lv_msg = |Bảng { iv_tab } đang được người dùng { lv_locked_by } chỉnh sửa. Vui lòng chỉ mở dạng xem.|.
      lv_msg = TEXT-151.

      REPLACE '&1' IN lv_msg WITH iv_tab.
      REPLACE '&2' IN lv_msg WITH lv_locked_by.

      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

    WHEN OTHERS.
*      MESSAGE |Không lock được bảng { iv_tab }.| TYPE 'S' DISPLAY LIKE 'E'.
      lv_msg = TEXT-152.
      REPLACE '&1' IN lv_msg WITH iv_tab.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

  ENDCASE.

ENDFORM.


FORM unlock_current_table USING iv_tab TYPE tabname.

  CALL FUNCTION 'DEQUEUE_E_TABLE'
    EXPORTING
      tabname = iv_tab.

ENDFORM.


*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_DDIC
*&---------------------------------------------------------------------*
*& Xử lý metadata, tạo itab động và fieldcatalog
*&---------------------------------------------------------------------*

"=== Build fieldcatalog cho ALV ===
FORM build_fieldcat USING p_field p_text.
  CLEAR gs_fieldcat.
  gs_fieldcat-fieldname = p_field.
  gs_fieldcat-seltext = p_text. " Tiêu đề cột
  gs_fieldcat-scrtext_m = p_text.   " Tên trung bình
  gs_fieldcat-reptext   = p_text.   " Tên report
  gs_fieldcat-coltext   = p_text.
  APPEND gs_fieldcat TO gt_fieldcat.
ENDFORM.

FORM build_fieldcat_all.

  REFRESH: gt_fieldcat, gt_fieldnames.

  "--- Lấy fieldcatalog từ DDIC
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name       = p_tab
    CHANGING
      ct_fieldcat            = gt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
    " Error handling logic
  ENDIF.
  IF gt_fieldcat IS INITIAL.
    lv_msg = TEXT-005.
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Ẩn MANDT nếu có
  FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    CLEAR: <fs_fcat>-checktable,  " Bỏ Check Table
           <fs_fcat>-ref_table,   " Bỏ tham chiếu tên Bảng gốc
           <fs_fcat>-ref_field.
    IF <fs_fcat>-fieldname = 'MANDT'.
      <fs_fcat>-no_out = abap_true.
      <fs_fcat>-tech   = abap_true.
    ENDIF.
  ENDLOOP.

  "--- Thêm 6 cột audit CHỈ KHI chưa có
  DATA: lv_colpos TYPE i,
        ls_fc     TYPE lvc_s_fcat.

  DESCRIBE TABLE gt_fieldcat LINES lv_colpos.

  DATA(lv_next_pos) = lv_colpos + 1.

  DEFINE _add_audit_col.
    READ TABLE gt_fieldcat WITH KEY fieldname = &1 TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      CLEAR ls_fc.
      ls_fc-fieldname   = &1.
      ls_fc-coltext     = &2.
      ls_fc-scrtext_m   = &2.
      ls_fc-reptext     = &2.
      ls_fc-seltext     = &2.
      ls_fc-col_pos     = lv_next_pos.
      lv_next_pos       = lv_next_pos + 1.
      APPEND ls_fc TO gt_fieldcat.
    ENDIF.
  END-OF-DEFINITION.

  _add_audit_col 'ERDAT' TEXT-182.
  _add_audit_col 'ERTIM' TEXT-183.
  _add_audit_col 'ERNAM' TEXT-184.
  _add_audit_col 'AEDAT' TEXT-185.
  _add_audit_col 'AETIM' TEXT-186.
  _add_audit_col 'AENAM' TEXT-187.

  "--- Thêm field kỹ thuật ẩn (CELLTAB, ROW_COLOR)
  READ TABLE gt_fieldcat WITH KEY fieldname = 'CELLTAB' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'CELLTAB'.
    ls_fc-tech      = abap_true.
    ls_fc-no_out    = abap_true.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  READ TABLE gt_fieldcat WITH KEY fieldname = 'ROW_COLOR' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ROW_COLOR'.
    ls_fc-tech      = abap_true.
    ls_fc-no_out    = abap_true.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- **TỐI ƯU HÓA ĐỘ RỘNG CỘT – GENERIC, **
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.

    "--- 1. Giới hạn độ rộng tối đa để tránh cột CHAR 50/132/255 quá rộng
    IF <fs_fcat>-outputlen > 40.
      <fs_fcat>-outputlen = 40.   " Tối đa 40 ký tự cho bất kỳ cột nào
    ENDIF.

    "--- 2. Fix width chính xác cho các kiểu dữ liệu phổ biến
    CASE <fs_fcat>-inttype.
      WHEN 'D'. " DATS - ngày
        <fs_fcat>-outputlen = 10.
        <fs_fcat>-datatype  = 'DATS'.
      WHEN 'T'.
        <fs_fcat>-outputlen = 8.
        <fs_fcat>-datatype  = 'TIMS'.
      WHEN 'N' OR 'I' OR 'P'. " Số
        IF <fs_fcat>-outputlen > 15.
          <fs_fcat>-outputlen = 15.
        ENDIF.
    ENDCASE.

    "--- 3. Fix width cố định cho các cột audit
    CASE <fs_fcat>-fieldname.
      WHEN 'ERDAT' OR 'AEDAT'.
        <fs_fcat>-outputlen = 10.
        <fs_fcat>-datatype  = 'DATS'.
        <fs_fcat>-inttype   = 'D'.
      WHEN 'ERTIM' OR 'AETIM'.
        <fs_fcat>-outputlen = 8.
        <fs_fcat>-datatype  = 'TIMS'.
        <fs_fcat>-inttype   = 'T'.
      WHEN 'ERNAM' OR 'AENAM'.
        <fs_fcat>-outputlen = 12.
    ENDCASE.

    "--- 4. Read-only cho cột audit
    IF <fs_fcat>-fieldname = 'ERDAT' OR <fs_fcat>-fieldname = 'ERTIM' OR
       <fs_fcat>-fieldname = 'ERNAM' OR <fs_fcat>-fieldname = 'AEDAT' OR
       <fs_fcat>-fieldname = 'AETIM' OR <fs_fcat>-fieldname = 'AENAM'.
      CLEAR: <fs_fcat>-edit, <fs_fcat>-f4availabl.
    ENDIF.

  ENDLOOP.

  "--- Bật optimize tự động theo nội dung dữ liệu
  gs_layout-cwidth_opt = 'X'.

  "---  Loại bỏ trùng lặp fieldcat
  PERFORM dedup_fieldcat.

  "--- Build danh sách tên cột (dùng cho export, validate...)
  CLEAR gt_fieldnames.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    IF <fs_fcat>-tech = abap_true OR <fs_fcat>-no_out = abap_true.
      CONTINUE.
    ENDIF.
    DATA(lv_name) = COND string(
      WHEN <fs_fcat>-coltext IS NOT INITIAL THEN <fs_fcat>-coltext
      ELSE <fs_fcat>-fieldname ).
    lv_name = to_upper( condense( lv_name ) ).
    CONDENSE lv_name NO-GAPS.
    APPEND lv_name TO gt_fieldnames.
  ENDLOOP.

  "--- Bật F4 nếu cần
  PERFORM enable_f4_in_fieldcat.

ENDFORM.



"=== Tạo itab động từ bảng p_tab ===
FORM create_dynamic_itab USING p_tabname TYPE tabname
CHANGING p_itab TYPE REF TO data.

  DATA: lo_descr TYPE REF TO cl_abap_structdescr,
        lo_table TYPE REF TO cl_abap_tabledescr.

  TRY.
      " Lấy mô tả cấu trúc của bảng p_tabname
      lo_descr ?= cl_abap_typedescr=>describe_by_name( p_tabname ).
      lo_table =  cl_abap_tabledescr=>create( lo_descr ).
      "=== Thêm 6 field audit tự động, tránh trùng tên ===
      DATA: lt_components TYPE abap_component_tab,
            ls_component  TYPE abap_componentdescr,
            lt_names      TYPE STANDARD TABLE OF string.

      DATA(lo_struct) = CAST cl_abap_structdescr( lo_table->get_table_line_type( ) ).
      lt_components = lo_struct->get_components( ).

      " Lấy danh sách field hiện có
      LOOP AT lt_components INTO ls_component.
        APPEND ls_component-name TO lt_names.
      ENDLOOP.

      DEFINE add_field_if_missing.
        READ TABLE lt_names WITH KEY table_line = &1 TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CLEAR ls_component.
          ls_component-name = &1.
          ls_component-type ?= cl_abap_elemdescr=>describe_by_name( &2 ).
          APPEND ls_component TO lt_components.
        ENDIF.
      END-OF-DEFINITION.

      add_field_if_missing 'ERDAT' 'DATS'.  " Created On
      add_field_if_missing 'ERTIM' 'TIMS'.  " Created Time
      add_field_if_missing 'ERNAM' 'UNAME'. " Created By
      add_field_if_missing 'AEDAT' 'DATS'.  " Changed On
      add_field_if_missing 'AETIM' 'TIMS'.  " Changed Time
      add_field_if_missing 'AENAM' 'UNAME'. " Changed By

      " Tạo lại mô tả cấu trúc có 6 field mới
      DATA(lo_new_struct) = cl_abap_structdescr=>create( lt_components ).
      DATA(lo_new_table)  = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

      CREATE DATA p_itab TYPE HANDLE lo_new_table.

*      CREATE DATA p_itab TYPE HANDLE lo_table.

    CATCH cx_sy_create_data_error INTO DATA(lx_create).
*      MESSAGE |Không tạo được itab động cho { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
      lv_msg = TEXT-006.
      REPLACE '&1' IN lv_msg WITH p_tabname.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

      RETURN.
  ENDTRY.

ENDFORM.





*---------------------------------------------------------------------*
* Đồng bộ fieldcatalog với line type của itab động (gr_data)
*---------------------------------------------------------------------*
FORM sync_fcat_with_itab CHANGING ct_fcat TYPE lvc_t_fcat.

  DATA: lo_tab  TYPE REF TO cl_abap_tabledescr,
        lo_line TYPE REF TO cl_abap_structdescr,
        lt_comp TYPE abap_component_tab.

  IF gr_data IS INITIAL.
    RETURN.
  ENDIF.

  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( gr_data ).
  lo_line ?= CAST cl_abap_structdescr( lo_tab->get_table_line_type( ) ).
  lt_comp = lo_line->get_components( ).

  LOOP AT ct_fcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
    READ TABLE lt_comp WITH KEY name = <fs_fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE ct_fcat.
    ENDIF.
  ENDLOOP.

  " Sau khi sync có thể có cột bị xóa → bật lại F4 cho chắc
  PERFORM enable_f4_in_fieldcat.


ENDFORM.



FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
CHANGING er_data TYPE REF TO data.

  DATA: lt_dfies      TYPE TABLE OF dfies,
        lt_components TYPE cl_abap_structdescr=>component_table,
        ls_component  LIKE LINE OF lt_components.

  " Lấy metadata từ DDIC
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tabname
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
*    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-007 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " Lọc các trường không phải style (tên field thường là CELLTAB)
  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'.
    ls_component-name = ls_dfies-fieldname.
    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
    APPEND ls_component TO lt_components.
  ENDLOOP.

  " Tạo cấu trúc động
  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
  lr_struct_type = cl_abap_structdescr=>create( lt_components ).

  " Tạo internal table động
  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
  lr_table_type = cl_abap_tabledescr=>create(
  p_line_type = lr_struct_type
  p_table_kind = cl_abap_tabledescr=>tablekind_std ).
  CREATE DATA er_data TYPE HANDLE lr_table_type.

ENDFORM.


*---------------------------------------------------------------------*
* Thêm 6 field audit (Created/Changed) vào cấu trúc động
*---------------------------------------------------------------------*
FORM add_audit_fields CHANGING ct_components TYPE cl_abap_structdescr=>component_table.
  DATA ls_component LIKE LINE OF ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERDAT'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  ls_component-type = cl_abap_elemdescr=>get_d( ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERTIM'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  ls_component-type = cl_abap_elemdescr=>get_t( ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERNAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AEDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AETIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AENAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.
ENDFORM.


*---------------------------------------------------------------------*
* Lấy metadata chi tiết từ DDIC (so với fieldcatalog ALV)
*---------------------------------------------------------------------*
FORM get_metadata USING p_tabname TYPE tabname
CHANGING ct_meta TYPE ddfields.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tabname
      langu          = sy-langu
      all_types      = 'X'
    TABLES
      dfies_tab      = ct_meta
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR ct_meta IS INITIAL.
*    MESSAGE |Không lấy được metadata cho bảng { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    lv_msg = TEXT-008.
    REPLACE '&1' IN lv_msg WITH p_tabname.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

    RETURN.
  ENDIF.

ENDFORM.

FORM enable_f4_in_fieldcat .
  DATA: lt_meta TYPE TABLE OF dfies,
        ls_meta TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_meta
    EXCEPTIONS
      OTHERS    = 1.

  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Mặc định tắt F4
    <fc>-f4availabl = abap_false.

    " Xác định có phải khóa?
    DATA(lv_is_key) = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    CLEAR ls_meta.
    READ TABLE lt_meta INTO ls_meta WITH KEY fieldname = <fc>-fieldname.

    " 1) Ưu tiên SH/FK
    IF sy-subrc = 0 AND ( ls_meta-f4availabl = 'X' OR ls_meta-checktable IS NOT INITIAL ).
      <fc>-f4availabl = abap_true.
    ELSE.
      " 2) Loại trừ kiểu không nên F4
      DATA(lv_is_disallowed) = abap_false.
      IF ls_meta-datatype = 'DATS' OR ls_meta-datatype = 'TIMS'.
        lv_is_disallowed = abap_true.
      ENDIF.
      IF ls_meta-datatype = 'QUAN' OR ls_meta-datatype = 'CURR'
         OR ls_meta-reffield  IS NOT INITIAL OR ls_meta-reftable IS NOT INITIAL.
        lv_is_disallowed = abap_true.
      ENDIF.

      " 3) Fallback chỉ cho non-key & không bị disallow
      IF lv_is_key = abap_false AND lv_is_disallowed = abap_false.
        CASE ls_meta-inttype.
          WHEN 'C' OR 'N' OR 'P' OR 'I' OR 'F'.
            <fc>-f4availabl = abap_true.
        ENDCASE.
      ENDIF.
    ENDIF.

    " 4) Whitelist / Blacklist
    READ TABLE gt_f4_whitelist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_true. ENDIF.

    READ TABLE gt_f4_blacklist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_false. ENDIF.

  ENDLOOP.
ENDFORM.



FORM register_f4_all .
  DATA: lt_f4   TYPE lvc_t_f4,
        ls_f4   TYPE lvc_s_f4,
        lt_seen TYPE HASHED TABLE OF lvc_fname WITH UNIQUE KEY table_line,
        lv_name TYPE lvc_fname.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  CLEAR: lt_f4, lt_seen.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    IF <fc>-f4availabl = abap_true.
      lv_name = <fc>-fieldname.
      IF lv_name IS INITIAL. CONTINUE. ENDIF.

      READ TABLE lt_seen WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. CONTINUE. ENDIF.
      INSERT lv_name INTO TABLE lt_seen.

      CLEAR ls_f4.
      ls_f4-fieldname = lv_name.
      ls_f4-register = abap_true.
      ls_f4-getbefore = abap_true.
      ls_f4-chngeafter = abap_false.

      INSERT ls_f4 INTO TABLE lt_f4.
    ENDIF.
  ENDLOOP.

  TRY.
      g_alv_grid->register_f4_for_fields( it_f4 = lt_f4 ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

"=== helper: chỉ thêm field vào fieldcatalog nếu chưa có
FORM add_fc_if_missing USING iv_field  TYPE lvc_fname
                              iv_text   TYPE string
                              iv_colpos TYPE i.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-coltext   = iv_text.
    gs_fieldcat-scrtext_m = iv_text.
    gs_fieldcat-reptext   = iv_text.
    gs_fieldcat-col_pos   = iv_colpos.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.

"=== helper: thêm cột kỹ thuật nếu chưa có (ẩn đi)
FORM add_fc_tech_if_missing USING iv_field  TYPE lvc_fname
                                   iv_colpos TYPE i
                                   iv_hidden TYPE abap_bool.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-col_pos   = iv_colpos.
    IF iv_hidden = abap_true.
      gs_fieldcat-no_out = abap_true.
      gs_fieldcat-tech   = abap_true.
    ENDIF.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_ALV
*&---------------------------------------------------------------------*

CLASS lcl_alv_handler DEFINITION.
  PUBLIC SECTION.
    METHODS handle_toolbar
      FOR EVENT toolbar OF cl_gui_alv_grid
      IMPORTING e_object e_interactive.

    METHODS handle_user_command
      FOR EVENT user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm.

    METHODS handle_onf4
      FOR EVENT onf4 OF cl_gui_alv_grid
      IMPORTING e_fieldname es_row_no er_event_data e_display.

    METHODS handle_data_changed
      FOR EVENT data_changed OF cl_gui_alv_grid
      IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.
ENDCLASS.

CLASS lcl_alv_handler IMPLEMENTATION.

  METHOD handle_toolbar.
    DATA: lt_toolbar     TYPE STANDARD TABLE OF stb_button,
          ls_btn         TYPE stb_button,
          lv_can_create  TYPE abap_bool,
          lv_can_change  TYPE abap_bool,
          lv_can_delete  TYPE abap_bool,
          lv_can_display TYPE abap_bool,
          lv_can_history TYPE abap_bool,
          lv_drop        TYPE abap_bool,
          ix             TYPE sy-tabix.

    FIELD-SYMBOLS: <b>  TYPE stb_button,
                   <fc> LIKE LINE OF gt_tb_excl.

    PERFORM has_actvt USING '01' CHANGING lv_can_create.
    PERFORM has_actvt USING '02' CHANGING lv_can_change.
    PERFORM has_actvt USING '06' CHANGING lv_can_delete.
    PERFORM has_actvt USING '03' CHANGING lv_can_display.
    PERFORM has_actvt USING '03' CHANGING lv_can_history.
    IF e_interactive IS INITIAL. ENDIF.

    " Lấy danh sách toolbar hiện tại
    lt_toolbar = e_object->mt_toolbar[].

    " Bước 1: Duyệt và đánh dấu các nút cần xóa (Clear function code)
    LOOP AT lt_toolbar ASSIGNING <b>.
      lv_drop = abap_false.

      " Check 1: Nằm trong danh sách loại trừ gt_tb_excl
      LOOP AT gt_tb_excl ASSIGNING <fc>.
        IF <b>-function = <fc>.
          lv_drop = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      " Check 2: Fallback các mã chuẩn
      IF lv_drop = abap_false.
        CASE <b>-function.
          WHEN 'INSR' OR 'APND' OR 'DELE' OR 'DUPL'    " Thao tác dòng
            OR 'COPY' OR 'PASTE' OR 'SCUT' OR 'UNDO'   " Clipbroad
            OR '&LOCAL&INSERT_ROW' OR '&LOCAL&APPEND'  " Mã chuẩn ALV
            OR '&LOCAL&DELETE_ROW' OR '&LOCAL&COPY_ROW'
            OR '&LOCAL&PASTE_NEW_ROW' OR '&LOCAL&CUT'
            OR '&LOCAL&UNDO'.
            lv_drop = abap_true.
        ENDCASE.
      ENDIF.

      " Nếu cần xóa -> Xóa mã function code
      IF lv_drop = abap_true.
        CLEAR <b>-function.
      ENDIF.
    ENDLOOP.

    " Bước 2: Xóa sạch các dòng đã đánh dấu ra khỏi bảng
    DELETE lt_toolbar WHERE function IS INITIAL.

    "=== 2) Thêm các nút custom (EVTG, SAVE, ADD, DELE, UPLD, XLSX, TMPL, HIST)
    "---- EVTG
    CLEAR ls_btn.
    ls_btn-function = 'EVTG'.
    IF gv_edit_md = abap_true.
      ls_btn-icon      = icon_display.
*      ls_btn-text      = 'View'.
      ls_btn-text      = TEXT-163.
*      ls_btn-quickinfo = 'Switch to view mode'.
      ls_btn-quickinfo = TEXT-164.
      ls_btn-disabled  = space.
    ELSE.
      ls_btn-icon      = icon_change.
*      ls_btn-text      = 'Edit'.
      ls_btn-text      = TEXT-165.
*      ls_btn-quickinfo = 'Switch to edit mode'.
      ls_btn-quickinfo = TEXT-166.
      ls_btn-disabled  = COND #( WHEN lv_can_change = abap_true THEN space ELSE 'X' ).
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "---- SAVE
    CLEAR ls_btn.
    ls_btn-function   = 'SAVE'.
    ls_btn-icon       = icon_system_save.
*    ls_btn-text       = 'Save'.
    ls_btn-text       = TEXT-167.
*    ls_btn-quickinfo  = 'Save changes'.
    ls_btn-quickinfo  = TEXT-168.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_change = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- ADD
    CLEAR ls_btn.
    ls_btn-function   = 'ADD'.
    ls_btn-icon       = icon_create.
*    ls_btn-text       = 'Add'.
    ls_btn-text       = TEXT-169.
*    ls_btn-quickinfo  = 'Add new entry'.
    ls_btn-quickinfo  = TEXT-170.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_create = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- DELE
    CLEAR ls_btn.
    ls_btn-function   = 'DELE'.
    ls_btn-icon       = icon_delete.
*    ls_btn-text       = 'Delete'.
    ls_btn-text       = TEXT-171.
*    ls_btn-quickinfo  = 'Delete selected entry'.
    ls_btn-quickinfo  = TEXT-172.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_delete = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- UPLD
    CLEAR ls_btn.
    ls_btn-function   = 'UPLD'.
    ls_btn-icon       = icon_import.
*    ls_btn-text       = 'Upload Data'.
    ls_btn-text       = TEXT-173.
*    ls_btn-quickinfo  = 'Upload from file'.
    ls_btn-quickinfo  = TEXT-174.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_change = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- XLSX
    CLEAR ls_btn.
    ls_btn-function   = 'XLSX'.
    ls_btn-icon       = icon_export.
*    ls_btn-text       = 'Export Data'.
    ls_btn-text       = TEXT-175.
*    ls_btn-quickinfo  = 'Export to Excel'.
    ls_btn-quickinfo  = TEXT-176.
    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- TMPL
    CLEAR ls_btn.
    ls_btn-function   = 'TMPL'.
    ls_btn-icon       = icon_export.
*    ls_btn-text       = 'Export Template'.
    ls_btn-text       = TEXT-177.
*    ls_btn-quickinfo  = 'Download template'.
    ls_btn-quickinfo  = TEXT-178.
    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- HIST
    CLEAR ls_btn.
    ls_btn-function   = 'HIST'.
    ls_btn-icon       = icon_history.
*    ls_btn-text       = 'History'.
    ls_btn-text       = TEXT-179.
*    ls_btn-quickinfo  = 'View version history & rollback'.
    ls_btn-quickinfo  = TEXT-180.
*    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_history = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    e_object->mt_toolbar[] = lt_toolbar.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA: ls_stbl               TYPE lvc_s_stbl,
          lv_has_change         TYPE abap_bool,
          lv_answer             TYPE c,
          lv_new_incomplete     TYPE abap_bool,
          lv_other_changes      TYPE abap_bool,
          lv_ans_conf           TYPE c,
          lv_question           TYPE c LENGTH 70,
          lv_msg                TYPE c LENGTH 200,
          lv_err                TYPE c LENGTH 200,
          lv_skip_unsaved_check TYPE abap_bool VALUE abap_false,
          lv_ok                 TYPE abap_bool.


    DATA: lv_saved_by_prompt     TYPE abap_bool VALUE abap_false,
          lv_discarded_by_prompt TYPE abap_bool VALUE abap_false.

    DATA: lv_dup           TYPE abap_bool,
          lv_dup_msg       TYPE string,
          lv_off_idx       TYPE i,
          lv_key_for_focus TYPE dd03l-fieldname.

    FIELD-SYMBOLS:
      <fs_tab>    TYPE STANDARD TABLE,
      <fs_row>    TYPE any,
      <fs_newrec> TYPE any,
      <fs_erdat>  TYPE any,  <fs_ertim> TYPE any,  <fs_ernam> TYPE any.

    CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

    " Gom dữ liệu đang edit về itab trước
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
    ENDIF.


    IF e_ucomm = 'DELE' OR e_ucomm = 'ADD' OR e_ucomm = 'UPLD'.
      lv_skip_unsaved_check = abap_true.
    ENDIF.

    " Kiểm tra thay đổi chưa lưu chi tiết
    DATA: lv_new_incomplete_cnt TYPE i,
          lv_new_complete_cnt   TYPE i,
          lv_edit_existing_cnt  TYPE i,
          lv_ans                TYPE c,
          lv_text               TYPE c LENGTH 200.

    PERFORM analyze_change_state_detailed
      CHANGING lv_has_change lv_new_incomplete_cnt lv_new_complete_cnt lv_edit_existing_cnt.

    IF e_ucomm <> 'SAVE'
       AND lv_has_change = abap_true
       AND lv_skip_unsaved_check <> abap_true.

      IF     lv_new_incomplete_cnt > 0
         AND lv_new_complete_cnt   = 0
         AND lv_edit_existing_cnt  = 0.

*        lv_text = |Có | && lv_new_incomplete_cnt &&
*                  | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và tiếp tục?|.
        lv_text = TEXT-009.
        REPLACE '&1' IN lv_text WITH CONV string( lv_new_incomplete_cnt ).
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-010
            text_question         = lv_text
            text_button_1         = TEXT-011
            text_button_2         = TEXT-012
            default_button        = '2'
            display_cancel_button = space
          IMPORTING
            answer                = lv_ans.

        IF lv_ans = '1'.
          PERFORM purge_incomplete_newrecs.
          gv_add_mode = abap_false.
          PERFORM apply_editability_and_push.
        ELSEIF lv_ans = '2'.
          PERFORM focus_key_on_newrec.
          RETURN.
        ENDIF.

      ELSEIF lv_new_complete_cnt > 0
         AND lv_edit_existing_cnt = 0
         AND lv_new_incomplete_cnt = 0.

*        lv_text = |Có | && lv_new_complete_cnt &&
*                  | dòng mới CHƯA LƯU. Lưu trước khi tiếp tục?|.
        lv_text = TEXT-013.
        REPLACE '&1' IN lv_text WITH CONV string( lv_new_complete_cnt ).

        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-014
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.

            " Save có lỗi thì ở lại edit

            DATA(lv_has_after)         = abap_false.
            DATA(lv_new_inc_after)     = 0.
            DATA(lv_new_comp_after)    = 0.
            DATA(lv_edit_exist_after)  = 0.

            PERFORM analyze_change_state_detailed
              CHANGING lv_has_after
                       lv_new_inc_after
                       lv_new_comp_after
                       lv_edit_exist_after.

            IF gv_edit_md = abap_true OR lv_has_after = abap_true.
              " còn gì đó chưa xong → ở lại
              RETURN.
            ELSE.
              " Lưu OK & không còn gì → cho phép chạy tiếp action
              lv_saved_by_prompt = abap_true.
            ENDIF.

          WHEN 'A'.
            RETURN.
          WHEN '2'.
            " KHÔNG LƯU: bỏ toàn bộ thay đổi tạm (xóa NEWREC) và về View
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.


      ELSEIF lv_edit_existing_cnt > 0
         AND lv_new_incomplete_cnt = 0
         AND lv_new_complete_cnt   = 0.

*        lv_text = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi tiếp tục?'.
        lv_text = TEXT-017.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-018
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.
            IF gv_edit_md = abap_true.
              RETURN.
            ELSE.
              lv_saved_by_prompt = abap_true.
            ENDIF.
          WHEN 'A'.
            RETURN.
          WHEN '2'.
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.

      ELSE.
*        lv_text = |Có thay đổi chưa lưu: | &&
*                  lv_new_incomplete_cnt && ' NEWREC thiếu khóa, ' &&
*                  lv_new_complete_cnt   && ' NEWREC đủ khóa, ' &&
*                  lv_edit_existing_cnt  && ' thay đổi dòng cũ. Lưu trước khi tiếp tục?'.
        lv_text = TEXT-019.

        REPLACE '&1' IN lv_text WITH CONV string( lv_new_incomplete_cnt ).
        REPLACE '&2' IN lv_text WITH CONV string( lv_new_complete_cnt ).
        REPLACE '&3' IN lv_text WITH CONV string( lv_edit_existing_cnt ).

        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-018
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.
            IF gv_edit_md = abap_true.
              RETURN.
            ELSE.
              lv_saved_by_prompt = abap_true.
            ENDIF.
          WHEN 'A'.
            RETURN.
          WHEN '2'.
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.
      ENDIF.

    ENDIF.


    "=== Xử lý các nút ===
    CASE e_ucomm.

      WHEN 'EVTG'.
        " 1. Kiểm tra quyền hạn
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE TEXT-020 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 2. Nếu vừa được Save/Discard từ Popup -> Refresh và thoát
        IF lv_saved_by_prompt = abap_true OR lv_discarded_by_prompt = abap_true.
          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.
          RETURN.
        ENDIF.

        " 3. Kiểm tra Upload chưa lưu
        IF gv_in_upload = abap_true AND gv_edit_md = abap_true.
          DATA(lv_ans_view) = ' '.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = TEXT-147
              text_question         = TEXT-146
              text_button_1         = TEXT-015
              text_button_2         = TEXT-016
              default_button        = '1'
              display_cancel_button = 'X'
            IMPORTING
              answer                = lv_ans_view.

          CASE lv_ans_view.
            WHEN '1'.
              PERFORM on_save.
              RETURN.
            WHEN 'A'.
              RETURN.
            WHEN '2'.
              MESSAGE TEXT-148 TYPE 'S' DISPLAY LIKE 'E'.
              PERFORM discard_unsaved_changes.
              gv_in_upload = abap_false.
          ENDCASE.
        ENDIF.

        " 4. Kiểm tra trùng khóa (Chỉ chạy khi đang ở Edit Mode và muốn về View)
        IF ( gv_edit_md = abap_true OR gv_add_mode = abap_true ).
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
          ENDIF.

          CLEAR: lv_dup, lv_dup_msg, lv_off_idx.
          PERFORM check_newrec_duplicate_all USING p_tab
                 CHANGING lv_dup lv_dup_msg lv_off_idx.

          IF lv_dup = abap_true.
            lv_msg = lv_dup_msg.
            MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

            IF g_alv_grid IS BOUND AND lv_off_idx > 0.
              DATA: ls_row TYPE lvc_s_row, ls_col TYPE lvc_s_col.
              ls_row-index = lv_off_idx.
              CLEAR lv_key_for_focus.
              READ TABLE gt_key_fields INDEX 1 INTO lv_key_for_focus.
              IF sy-subrc = 0. ls_col-fieldname = lv_key_for_focus. ENDIF.
              TRY.
                  g_alv_grid->set_current_cell_via_id( is_row_id = ls_row is_column_id = ls_col ).
                  g_alv_grid->set_scroll_info_via_id( is_row_info = ls_row is_col_info = ls_col ).
                CATCH cx_root.
              ENDTRY.
            ENDIF.
            RETURN. " CHẶN chuyển View nếu còn lỗi trùng
          ENDIF.
        ENDIF.

        " ================================================================
        " 5. LOGIC CHÍNH: TOGGLE VIEW/EDIT + LOCK/UNLOCK
        " ================================================================
        IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
          " --- CASE A: Đang Edit -> Chuyển về View ---

          " 1. Mở khóa bảng cho người khác dùng
          PERFORM unlock_current_table USING p_tab.

          " 2. Chuyển trạng thái biến toàn cục
          gv_edit_md      = abap_false.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'D'.

          " 3. Tắt nhập liệu trên ALV
          TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.

        ELSE.
          " --- CASE B: Đang View -> Chuyển sang Edit ---

          " 1. Cố gắng Lock bảng
          DATA lv_locked TYPE abap_bool.
          PERFORM lock_current_table USING p_tab CHANGING lv_locked.

          IF lv_locked = abap_false.
            " Nếu Lock thất bại (người khác đang dùng) -> Dừng lại, không chuyển mode
            RETURN.
          ENDIF.

          " 2. Chuyển trạng thái biến toàn cục
          gv_edit_md      = abap_true.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'E'.

          " 3. Bật nhập liệu trên ALV
          TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
        ENDIF.
        " ================================================================

        " 6. Refresh hiển thị
        PERFORM apply_editability_and_push.
        IF g_alv_grid IS BOUND.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          " ================================================================
          SET SCREEN 100.
          " ================================================================
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'ADD'.
        PERFORM has_actvt USING '01' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-020 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        IF gv_edit_md = abap_false.
          PERFORM lock_current_table USING p_tab CHANGING lv_ok.
          IF lv_ok = abap_false. RETURN. ENDIF.
        ENDIF.
        ASSIGN gr_data->* TO <fs_tab>.
        IF <fs_tab> IS ASSIGNED.
          APPEND INITIAL LINE TO <fs_tab> ASSIGNING <fs_row>.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <fs_row> TO <fs_newrec>.
          IF sy-subrc = 0. <fs_newrec> = 'X'. ENDIF.

          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <fs_row> TO <fs_erdat>.
          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <fs_row> TO <fs_ertim>.
          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <fs_row> TO <fs_ernam>.
          DATA: lv_user_tzone TYPE tznzone,
                lv_local_date TYPE d,
                lv_local_time TYPE t,
                ts_utc        TYPE timestamp.

          lv_user_tzone = sy-zonlo.
          IF lv_user_tzone IS INITIAL.
            TRY.
                lv_user_tzone = cl_abap_context_info=>get_user_time_zone( ).
              CATCH cx_abap_context_info_error.
                lv_user_tzone = 'UTC'.
            ENDTRY.
          ENDIF.

          GET TIME STAMP FIELD ts_utc.
          CONVERT TIME STAMP ts_utc TIME ZONE lv_user_tzone
                  INTO DATE lv_local_date TIME lv_local_time.

          IF <fs_erdat> IS ASSIGNED. <fs_erdat> = lv_local_date. ENDIF.
          IF <fs_ertim> IS ASSIGNED. <fs_ertim> = lv_local_time. ENDIF.
          IF <fs_ernam> IS ASSIGNED. <fs_ernam> = sy-uname. ENDIF.

          gv_add_mode     = abap_true.
          gv_edit_md      = abap_true.
          gv_toolbar_mode = 'E'.

          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
            g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

          PERFORM ensure_keys USING p_tab.
          READ TABLE gt_key_fields INDEX 1 INTO lv_key_for_focus.
          IF sy-subrc = 0 AND g_alv_grid IS BOUND.
            DATA ls_row_id TYPE lvc_s_row.
            DATA ls_col_id TYPE lvc_s_col.
            ls_row_id-index     = lines( <fs_tab> ).
            ls_col_id-fieldname = lv_key_for_focus.
            TRY.
                g_alv_grid->set_current_cell_via_id(
                  EXPORTING is_row_id    = ls_row_id
                            is_column_id = ls_col_id ).
                g_alv_grid->set_scroll_info_via_id(
                  EXPORTING is_row_info = ls_row_id
                            is_col_info = ls_col_id ).
              CATCH cx_root.
            ENDTRY.
          ENDIF.
        ENDIF.

      WHEN 'SAVE'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Change (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-021 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        PERFORM on_save.

        " ⬇️ SAU KHI SAVE BẰNG NÚT: KIỂM TRA LẠI COI CÒN NEWREC/LỖI KHÔNG
        DATA: lv_has_after2        TYPE abap_bool,
              lv_new_inc_after2    TYPE i,
              lv_new_comp_after2   TYPE i,
              lv_edit_exist_after2 TYPE i.

        PERFORM analyze_change_state_detailed
          CHANGING lv_has_after2
                   lv_new_inc_after2
                   lv_new_comp_after2
                   lv_edit_exist_after2.

        " Ở lại edit nếu còn lỗi
        IF gv_edit_md = abap_true OR lv_has_after2 = abap_true.
          " ở lại màn hình, không RETURN sớm, để ALV refresh ở dưới
        ELSE.
          " không còn gì
        ENDIF.

        RETURN.


      WHEN 'DELE'.
        PERFORM has_actvt USING '06' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Delete (ACTVT=06).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-022 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        DATA: lt_sel_idx TYPE lvc_t_row,
              ls_cur_row TYPE lvc_s_row,
              ls_cur_col TYPE lvc_s_col,
              lv_cnt     TYPE i.
        CLEAR lt_sel_idx.

        IF g_alv_grid IS BOUND.
          TRY. g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ). CATCH cx_root. ENDTRY.
        ENDIF.
        IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
          TRY.
              g_alv_grid->get_current_cell(
                IMPORTING es_row_id = ls_cur_row
                          es_col_id = ls_cur_col ).
            CATCH cx_root.
          ENDTRY.
          IF ls_cur_row-index > 0.
            APPEND VALUE lvc_s_row( index = ls_cur_row-index ) TO lt_sel_idx.
          ENDIF.
        ENDIF.

        lv_cnt = lines( lt_sel_idx ).
        IF lv_cnt = 0.
*          MESSAGE 'Vui lòng chọn dòng (hoặc đặt con trỏ) để xóa.' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-023 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        CLEAR gv_del_newrec_only.
        CLEAR: lv_new_incomplete, lv_other_changes.
        PERFORM is_newrec_target_for_delete CHANGING gv_del_newrec_only.
        PERFORM analyze_change_state       CHANGING lv_new_incomplete lv_other_changes.

        DATA lv_need_confirm TYPE abap_bool VALUE abap_false.
        CLEAR lv_question.

        IF gv_del_newrec_only = abap_true.
          lv_need_confirm = abap_false.
        ELSE.
          lv_need_confirm = abap_true.
*          lv_question     = |Bạn có chắc muốn xóa { lv_cnt } dòng đã chọn?|.
          lv_question = TEXT-024.
          REPLACE '&1' IN lv_question WITH CONV string( lv_cnt ).

        ENDIF.

        IF lv_need_confirm = abap_true.
          CLEAR lv_ans_conf.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = TEXT-025
              text_question         = lv_question(70)
              text_button_1         = TEXT-026
              text_button_2         = TEXT-027
              default_button        = '2'
              display_cancel_button = space
            IMPORTING
              answer                = lv_ans_conf.
          IF lv_ans_conf <> '1'.
            MESSAGE TEXT-149 TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
          ENDIF.
        ENDIF.

        CLEAR: lv_msg, lv_err.
        PERFORM delete_selected USING p_tab CHANGING lv_msg lv_err.
        IF lv_err IS INITIAL.
*          MESSAGE |{ COND string( WHEN lv_msg IS INITIAL THEN 'Đã xóa và ghi audit.' ELSE lv_msg ) }| TYPE 'S'.
          DATA(lv_final_msg) = COND string(
          WHEN lv_msg IS INITIAL THEN TEXT-028
          ELSE lv_msg
          ).

          MESSAGE lv_final_msg TYPE 'S'.

        ELSE.
          MESSAGE |{ lv_err }| TYPE 'S' DISPLAY LIKE 'E'.
        ENDIF.

        IF g_alv_grid IS BOUND.
          PERFORM ensure_celltab_component CHANGING gr_data.
          PERFORM apply_editability_and_push.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'UPLD'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Upload (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-029 TYPE'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        IF gv_edit_md = abap_false.
          PERFORM lock_current_table USING p_tab CHANGING lv_ok.
          IF lv_ok = abap_false. RETURN. ENDIF.

          " Upload thành công thì phải bật Edit mode luôn để giữ lock
          gv_edit_md = abap_true.
          gv_toolbar_mode = 'E'.
        ENDIF.
        PERFORM upload_data_strict_match.



      WHEN 'XLSX' OR 'TMPL' OR 'HIST'.
        PERFORM has_actvt USING '03' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Display (ACTVT=03).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-030 TYPE'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        CASE e_ucomm.
          WHEN 'XLSX'.
            FIELD-SYMBOLS: <lt_all>      TYPE STANDARD TABLE,
                           <lt_filtered> TYPE STANDARD TABLE,
                           <ls_any>      TYPE any,
                           <newrec_flag> TYPE any.

            DATA: lo_typedesc TYPE REF TO cl_abap_typedescr,
                  lo_tabdescr TYPE REF TO cl_abap_tabledescr,
                  lr_filtered TYPE REF TO data.

            IF g_alv_grid IS BOUND.
              TRY.
                  g_alv_grid->check_changed_data( ).
                CATCH cx_root.
              ENDTRY.
            ENDIF.

            ASSIGN gr_data->* TO <lt_all>.
            IF <lt_all> IS ASSIGNED.
              lo_typedesc = cl_abap_tabledescr=>describe_by_data_ref( REF #( <lt_all> ) ).
              lo_tabdescr ?= lo_typedesc.
              CREATE DATA lr_filtered TYPE HANDLE lo_tabdescr.
              ASSIGN lr_filtered->* TO <lt_filtered>.

              LOOP AT <lt_all> ASSIGNING <ls_any>.
                ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_any> TO <newrec_flag>.
                IF sy-subrc = 0 AND <newrec_flag> = 'X'.
                  CONTINUE.
                ENDIF.
                APPEND <ls_any> TO <lt_filtered>.
              ENDLOOP.

              IF <lt_filtered> IS INITIAL.
*                MESSAGE 'Không có dữ liệu đã lưu để export.' TYPE 'S' DISPLAY LIKE 'E'.
                MESSAGE TEXT-031 TYPE'S' DISPLAY LIKE 'E'.
                RETURN.
              ENDIF.

*              MESSAGE 'Các dòng chưa lưu sẽ không được export.' TYPE 'S'.
              MESSAGE TEXT-032 TYPE'S' DISPLAY LIKE 'E'.
              PERFORM download_excel_xlsx USING lr_filtered.
            ELSE.
*              MESSAGE 'Không có dữ liệu để export.' TYPE 'S' DISPLAY LIKE 'E'.
              MESSAGE TEXT-033 TYPE'S' DISPLAY LIKE 'E'.
            ENDIF.

          WHEN 'TMPL'. PERFORM download_template_xlsx.
          WHEN 'HIST'. PERFORM show_audit_history.
        ENDCASE.

    ENDCASE.

    cl_gui_cfw=>flush( ).
  ENDMETHOD.


  METHOD handle_onf4.
    er_event_data->m_event_handled = abap_true.
    DATA: lt_ret   TYPE STANDARD TABLE OF ddshretval,
          ls_ret   TYPE ddshretval,
          lv_value TYPE string,
          lv_done  TYPE abap_bool.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.
    " 1) DDIC search help (nếu có)
    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname    = p_tab
        fieldname  = e_fieldname
        display    = 'F'
      TABLES
        return_tab = lt_ret
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc = 0.
      " ĐÃ gọi được SH chuẩn → không fallback nữa
      IF lt_ret IS NOT INITIAL.
        READ TABLE lt_ret INDEX 1 INTO ls_ret.
        IF sy-subrc = 0.
          lv_value = ls_ret-fieldval.
          lv_done  = abap_true.
        ENDIF.
      ELSE.
        " Người dùng Cancel/không chọn → kết thúc, KHÔNG mở popup fallback
        er_event_data->m_event_handled = 'X'.
        RETURN.
      ENDIF.
    ENDIF.

    " 2) Fallback dynamic từ dữ liệu người dùng đang gõ
    IF lv_done IS INITIAL.
      DATA lv_current TYPE string.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, đổi internal -> external để dùng làm tiền tố filter
            DATA(lo_d1) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d1->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_current ).
                CATCH cx_abap_datfm.
                  lv_current = <cell>. " fallback
              ENDTRY.
            ELSE.
              lv_current = <cell>.
            ENDIF.
            CONDENSE lv_current.
          ENDIF.
        ENDIF.
      ENDIF.

      TYPES: BEGIN OF ty_val, fieldval TYPE char80, END OF ty_val.
      DATA: lt_vals TYPE STANDARD TABLE OF ty_val WITH DEFAULT KEY,
            ls_val  TYPE ty_val,
            lv_s    TYPE string.

      IF <outtab> IS ASSIGNED.
        LOOP AT <outtab> ASSIGNING <row>.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, hiển thị external trong popup
            DATA(lo_d2) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d2->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_s ).
                CATCH cx_abap_datfm.
                  lv_s = <cell>.
              ENDTRY.
            ELSE.
              lv_s = <cell>.
            ENDIF.

            CONDENSE lv_s.
            IF lv_s IS NOT INITIAL AND ( lv_current IS INITIAL OR lv_s CP lv_current && '*' ).
              ls_val-fieldval = lv_s.
              COLLECT ls_val INTO lt_vals.  " distinct
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.


      IF lt_vals IS NOT INITIAL.
        DATA: lt_field_tab TYPE TABLE OF dfies,
              ls_field_tab TYPE dfies,
              lv_coltext   TYPE string.

        " Lấy caption từ fieldcatalog
        lv_coltext = e_fieldname.
        LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>) WHERE fieldname = e_fieldname.
          IF <fc>-coltext IS NOT INITIAL.
            lv_coltext = <fc>-coltext.
          ELSEIF <fc>-scrtext_m IS NOT INITIAL.
            lv_coltext = <fc>-scrtext_m.
          ENDIF.
          EXIT.
        ENDLOOP.

        CLEAR ls_field_tab.
        ls_field_tab-fieldname = 'FIELDVAL'.
        ls_field_tab-datatype  = 'CHAR'.
        ls_field_tab-inttype   = 'C'.
        ls_field_tab-intlen    = 80.
        ls_field_tab-leng      = 80.
        ls_field_tab-outputlen = 80.
        ls_field_tab-decimals  = 0.
        ls_field_tab-reffield  = ''.
        ls_field_tab-reftable  = ''.
        ls_field_tab-reptext   = lv_coltext.
        ls_field_tab-scrtext_l = lv_coltext.
        ls_field_tab-scrtext_m = lv_coltext.
        ls_field_tab-scrtext_s = lv_coltext.
        APPEND ls_field_tab TO lt_field_tab.

        CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
          EXPORTING
            retfield   = 'FIELDVAL'
            value_org  = 'S'
            display    = 'F'
          TABLES
            value_tab  = lt_vals
            field_tab  = lt_field_tab
            return_tab = lt_ret
          EXCEPTIONS
            OTHERS     = 1.

        IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
          READ TABLE lt_ret INDEX 1 INTO ls_ret.
          IF sy-subrc = 0.
            lv_value = ls_ret-fieldval.
            lv_done = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    " 3) Gán lại vào ô hiện tại và refresh
    IF lv_done = abap_true.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            DATA(lo_desc) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).

            IF lo_desc->type_kind = cl_abap_typedescr=>typekind_date.
              DATA lv_date_int TYPE d.
              TRY.
                  cl_abap_datfm=>conv_date_ext_to_int(
                    EXPORTING im_datext = lv_value
                    IMPORTING ex_datint = lv_date_int ).
                  <cell> = lv_date_int.
                CATCH cx_abap_datfm .
                  TRY. <cell> = lv_value. CATCH cx_root. ENDTRY.
              ENDTRY.
            ELSE.
              <cell> = lv_value.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      TRY.
          g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        CATCH cx_root.
      ENDTRY.
      cl_gui_cfw=>flush( ).
      er_event_data->m_event_handled = 'X'.
    ENDIF.
  ENDMETHOD.

  METHOD handle_data_changed.
    DATA: lt_mod TYPE lvc_t_modi,
          ls_mod TYPE lvc_s_modi,
          lt_ins TYPE lvc_t_roid.

    DATA: lv_msg     TYPE string.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.

    ASSIGN gr_data->* TO <outtab>.
    IF <outtab> IS NOT ASSIGNED. RETURN. ENDIF.

    lt_mod = er_data_changed->mt_mod_cells.

    " Danh sách cột audit cần khóa tuyệt đối
    DATA: lt_audit TYPE TABLE OF lvc_fname WITH DEFAULT KEY.
    APPEND 'ERDAT' TO lt_audit. APPEND 'ERTIM' TO lt_audit. APPEND 'ERNAM' TO lt_audit.
    APPEND 'AEDAT' TO lt_audit. APPEND 'AETIM' TO lt_audit. APPEND 'AENAM' TO lt_audit.

    DATA(lv_nonnewrec_changed) = abap_false.

    LOOP AT lt_mod INTO ls_mod.

      " --- 0) Chặn tuyệt đối: AUDIT (kể cả paste)
      READ TABLE lt_audit WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).

            lv_msg = TEXT-034.
            REPLACE '&1' IN lv_msg WITH ls_mod-fieldname.

            er_data_changed->add_protocol_entry(
              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
              i_fieldname = ls_mod-fieldname i_row_id = ls_mod-row_id i_msgv1 = lv_msg ).
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      " --- 1) KEY: chỉ cho phép khi đang Add và dòng NEWREC = 'X'
      READ TABLE gt_key_fields WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. " Là KEY
        DATA(lv_block_key) = abap_true.
        IF gv_add_mode = abap_true AND ls_mod-row_id > 0.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0 AND <cell> = 'X'.
              lv_block_key = abap_false.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_block_key = abap_true.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0.
              er_data_changed->modify_cell(
                EXPORTING i_row_id    = ls_mod-row_id
                          i_fieldname = ls_mod-fieldname
                          i_value     = <cell> ).

              lv_msg = TEXT-035.
              REPLACE '&1' IN lv_msg WITH ls_mod-fieldname.

              er_data_changed->add_protocol_entry(
                i_msgid = '00' i_msgno = '398' i_msgty = 'E'
                i_fieldname = ls_mod-fieldname i_row_id = ls_mod-row_id i_msgv1 = lv_msg ).
            ENDIF.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      " --- 2) Non-key: chỉ cho phép khi đang Edit
      IF gv_edit_md <> abap_true.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).

            lv_msg = TEXT-036.
            REPLACE '&1' IN lv_msg WITH ls_mod-fieldname.

            er_data_changed->add_protocol_entry(
              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
              i_fieldname = ls_mod-fieldname i_row_id = ls_mod-row_id i_msgv1 = lv_msg ).
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      " --- 3) Đánh dấu dirty
      DATA(lv_is_newrec) = abap_false.
      IF ls_mod-row_id > 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> = 'X'.
            lv_is_newrec = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.

      IF lv_is_newrec = abap_false.
        DATA(lv_old_value) = VALUE string( ).
        DATA(lv_changed)   = abap_false.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            lv_old_value = |{ <cell> }|.
            IF lv_old_value <> ls_mod-value.
              lv_changed = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_changed = abap_true.
          DATA(lv_keyhash) = VALUE string( ).
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            PERFORM make_row_key USING <row> CHANGING lv_keyhash.
            IF lv_keyhash IS NOT INITIAL.
              INSERT lv_keyhash INTO TABLE gt_changed_existing_keys.
            ENDIF.
          ENDIF.
          lv_nonnewrec_changed = abap_true.
        ENDIF.
      ENDIF.

    ENDLOOP.

    gv_dirty = lv_nonnewrec_changed.

    " --- 4) Xử lý Paste dòng mới
    lt_ins = er_data_changed->mt_inserted_rows.
    IF lt_ins IS NOT INITIAL.
      FIELD-SYMBOLS: <celltab> TYPE lvc_t_styl.
      LOOP AT lt_ins INTO DATA(ls_ins).
        READ TABLE <outtab> INDEX ls_ins-row_id ASSIGNING <row>.
        IF sy-subrc <> 0.
          DATA(lv_need) = ls_ins-row_id - lines( <outtab> ).
          DO lv_need TIMES. APPEND INITIAL LINE TO <outtab>. ENDDO.
          READ TABLE <outtab> INDEX ls_ins-row_id ASSIGNING <row>.
        ENDIF.

        IF <row> IS ASSIGNED.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0. <cell> = 'X'. ENDIF.
          " Clear Audit fields & Celltab
          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
*          ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <row> TO <cell>.
*          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
*          ASSIGN COMPONENT 'AETIM' OF STRUCTURE <row> TO <cell>.
*          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
*          ASSIGN COMPONENT 'AENAM' OF STRUCTURE <row> TO <cell>.
*          IF sy-subrc = 0. CLEAR <cell>. ENDIF.
          ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <row> TO <celltab>.
          IF sy-subrc = 0. CLEAR <celltab>. ENDIF.
        ENDIF.
      ENDLOOP.

      gv_add_mode = abap_true.
      PERFORM apply_editability_and_push.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      ENDIF.
    ENDIF.

  ENDMETHOD.



ENDCLASS.


*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
  SET PF-STATUS 'MAIN100'.
  " ---------------------
  DATA: lv_title_text TYPE string.
  IF gv_edit_md = abap_true.
*    lv_title_text = |Đang thực hiện edit ở bảng { p_tab }|.
    lv_title_text = TEXT-231.
  ELSE.
*    lv_title_text = |Đang xem dữ liệu bảng { p_tab }|.
    lv_title_text = TEXT-232.
  ENDIF.

REPLACE '&1' IN lv_title_text WITH p_tab.
  " Lưu ý: Titlebar T100 trong GUI Status cần được định nghĩa là &1
  SET TITLEBAR 'T100' WITH lv_title_text.
  " -----------------------
  SET TITLEBAR 'T100'.
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PBO_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE pbo_0100 OUTPUT.
  PERFORM check_authorization.
  PERFORM ensure_keys USING p_tab.
  FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <fs_table>.

  IF <fs_table> IS ASSIGNED AND <fs_table> IS NOT INITIAL.
    PERFORM merge_audit_log USING p_tab CHANGING <fs_table>.
  ENDIF.

  IF <fs_table> IS NOT ASSIGNED.
*    MESSAGE 'Không thể gán dữ liệu ALV.' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-037 TYPE 'S' DISPLAY LIKE 'E'.
    LEAVE TO SCREEN 0.
    RETURN.
  ENDIF.

  " Nếu bảng rỗng thì vẫn cho hiển thị ALV (không LEAVE)
  IF <fs_table> IS INITIAL.
*    MESSAGE 'Không có dữ liệu để hiển thị, mở ALV trống.' TYPE 'S' DISPLAY LIKE 'I'.
    MESSAGE TEXT-038 TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

  TRY.
      "=== Chuẩn bị Fieldcatalog ===
      IF gt_fieldcat IS INITIAL.
        PERFORM build_fieldcat_all.
      ENDIF.
      PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.
      PERFORM enable_f4_in_fieldcat. " Bật cờ F4 cho tất cả cột

      "=== Tạo container & grid nếu lần đầu ===
      IF g_container IS INITIAL OR g_alv_grid IS INITIAL.
        CREATE OBJECT g_container EXPORTING container_name = gc_cc_alv.
        CREATE OBJECT g_alv_grid EXPORTING i_parent = g_container.
        g_alv_grid->set_toolbar_interactive( ).

        " Gắn các handler
        IF g_handler IS INITIAL.
          CREATE OBJECT g_handler.
          SET HANDLER g_handler->handle_toolbar FOR g_alv_grid.
          SET HANDLER g_handler->handle_user_command FOR g_alv_grid.
          SET HANDLER g_handler->handle_onf4 FOR g_alv_grid.
          SET HANDLER g_handler->handle_data_changed FOR g_alv_grid.
        ENDIF.
        PERFORM ensure_rowcolor_component CHANGING gr_data.
        " Layout
        gs_layout = VALUE #( edit       = abap_true
                     zebra      = abap_true
                     cwidth_opt = abap_true
                     stylefname = 'CELLTAB'
                     ctab_fname = 'ROW_COLOR' ).

        PERFORM ensure_celltab_component CHANGING gr_data.
        ASSIGN gr_data->* TO <fs_table>.
        PERFORM build_excluding_toolbar.

        g_alv_grid->set_table_for_first_display(
          EXPORTING
            is_layout            = gs_layout
            it_toolbar_excluding = gt_tb_excl
          CHANGING
            it_outtab            = <fs_table>
            it_fieldcatalog      = gt_fieldcat ).
      ELSE.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
      ENDIF.
      PERFORM apply_editability_and_push.
      PERFORM register_f4_all.
      TRY.
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_enter ).
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_modified ).
        CATCH cx_root.
      ENDTRY.

      "=== Bật/tắt input cho grid ===
      g_alv_grid->set_ready_for_input(
      COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).

    CATCH cx_root.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      ENDIF.
  ENDTRY.


  cl_gui_cfw=>flush( ).
ENDMODULE.

*&---------------------------------------------------------------------*
*& Module PAI_0100 INPUT
*&---------------------------------------------------------------------*
MODULE pai_0100 INPUT.
  g_okcode = sy-ucomm.
  CLEAR sy-ucomm.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  TRY.

      CASE g_okcode.

          "==================================================================
        WHEN 'BACK' OR 'CANC' OR 'EXIT'.
          "==================================================================
          "=== Check nếu có dữ liệu upload chưa lưu ===
          IF gv_in_upload = abap_true.
            DATA(lv_ans_exit_upload) = ' '.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = TEXT-147
                text_question         = TEXT-146
                text_button_1         = TEXT-015
                text_button_2         = TEXT-016
                default_button        = '1'
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_ans_exit_upload.

            CASE lv_ans_exit_upload.
              WHEN '1'. " Lưu
                PERFORM on_save.
                IF gv_edit_md = abap_true. " lỗi save -> ở lại
                  RETURN.
                ELSE.
                  gv_in_upload = abap_false.
                  PERFORM unlock_current_table USING p_tab.
                  LEAVE TO SCREEN 0.
                ENDIF.

              WHEN '2'. " Không lưu
                MESSAGE TEXT-148 TYPE 'S' DISPLAY LIKE 'E'.
                PERFORM discard_unsaved_changes.
                gv_in_upload = abap_false.
                PERFORM unlock_current_table USING p_tab.
                LEAVE TO SCREEN 0.

              WHEN 'A'. " Cancel
                RETURN.
            ENDCASE.
          ENDIF.

          " Đẩy giá trị đang nhập về itab trước khi so sánh
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Phân tích thay đổi chi tiết
          DATA: lv_has_change_exit         TYPE abap_bool,
                lv_new_incomplete_cnt_exit TYPE i,
                lv_new_complete_cnt_exit   TYPE i,
                lv_edit_existing_cnt_exit  TYPE i,
                lv_ans_exit                TYPE c,
                lv_text_exit               TYPE c LENGTH 200.

          CLEAR: lv_has_change_exit,
                 lv_new_incomplete_cnt_exit,
                 lv_new_complete_cnt_exit,
                 lv_edit_existing_cnt_exit.

          PERFORM analyze_change_state_detailed
            CHANGING lv_has_change_exit
                     lv_new_incomplete_cnt_exit
                     lv_new_complete_cnt_exit
                     lv_edit_existing_cnt_exit.

          " Không có thay đổi -> thoát luôn
          IF lv_has_change_exit = abap_false.
            PERFORM unlock_current_table USING p_tab.
            LEAVE TO SCREEN 0.
          ELSE.

            " --- CASE 1: CHỈ NEWREC THIẾU KHÓA ---
            IF     lv_new_incomplete_cnt_exit > 0
               AND lv_new_complete_cnt_exit   = 0
               AND lv_edit_existing_cnt_exit  = 0.

*              lv_text_exit = |Có | && lv_new_incomplete_cnt_exit &&
*                             | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và thoát?|.
              lv_text_exit = TEXT-039.
              REPLACE '&1' IN lv_text_exit WITH CONV string( lv_new_incomplete_cnt_exit ).

              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = TEXT-010
                  text_question         = lv_text_exit
                  text_button_1         = TEXT-040
                  text_button_2         = TEXT-012
                  default_button        = '2'
                  display_cancel_button = space
                IMPORTING
                  answer                = lv_ans_exit.

              IF lv_ans_exit = '1'.
                PERFORM purge_incomplete_newrecs.
                PERFORM unlock_current_table USING p_tab.
                LEAVE TO SCREEN 0.
              ELSE.
                " Ở lại màn hình, GIỮ EDIT
                PERFORM stay_in_edit_and_focus.
                gv_edit_md      = abap_true.
                gv_toolbar_mode = 'E'.
                PERFORM apply_editability_and_push.
                IF g_alv_grid IS BOUND.
                  TRY.
                      g_alv_grid->set_ready_for_input( 1 ).
                      g_alv_grid->refresh_table_display(
                        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                      g_alv_grid->set_toolbar_interactive( ).
                    CATCH cx_root.
                  ENDTRY.
                ENDIF.
                CLEAR g_okcode.
                cl_gui_cfw=>flush( ).
              ENDIF.

              " --- CASE 2: CHỈ NEWREC ĐỦ KHÓA (chưa lưu) ---
            ELSEIF lv_new_complete_cnt_exit   > 0
               AND lv_edit_existing_cnt_exit  = 0
               AND lv_new_incomplete_cnt_exit = 0.

*              lv_text_exit = |Có | && lv_new_complete_cnt_exit &&
*                             | dòng mới CHƯA LƯU. Lưu trước khi thoát?|.
              lv_text_exit = TEXT-041.
              REPLACE '&1' IN lv_text_exit WITH CONV string( lv_new_complete_cnt_exit ).

              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = TEXT-014
                  text_question         = lv_text_exit
                  text_button_1         = TEXT-015
                  text_button_2         = TEXT-016
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'. " Lưu
                  PERFORM on_save.

                  " ⬇️ SAU KHI on_save: NẾU CÒN NEWREC/LỖI → KHÔNG CHO THOÁT
                  DATA: lv_has_af_exit        TYPE abap_bool,
                        lv_new_inc_af_exit    TYPE i,
                        lv_new_comp_af_exit   TYPE i,
                        lv_edit_exist_af_exit TYPE i.

                  PERFORM analyze_change_state_detailed
                    CHANGING lv_has_af_exit
                             lv_new_inc_af_exit
                             lv_new_comp_af_exit
                             lv_edit_exist_af_exit.

                  IF gv_edit_md = abap_true OR lv_has_af_exit = abap_true.
                    " còn đồ chưa sạch -> Ở LẠI
                    PERFORM stay_in_edit_and_focus.
                    gv_edit_md      = abap_true.
                    gv_toolbar_mode = 'E'.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    " không còn gì -> THOÁT
                    PERFORM unlock_current_table USING p_tab.
                    LEAVE TO SCREEN 0.
                  ENDIF.



                WHEN '2'. " Không lưu -> bỏ thay đổi rồi thoát
                  PERFORM discard_unsaved_changes.
                  PERFORM unlock_current_table USING p_tab.
                  LEAVE TO SCREEN 0.

                WHEN 'A'. " Cancel -> ở lại và giữ Edit
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

              " --- CASE 3: CHỈ sửa dòng DB cũ ---
            ELSEIF lv_edit_existing_cnt_exit  > 0
               AND lv_new_incomplete_cnt_exit = 0
               AND lv_new_complete_cnt_exit   = 0.

*              lv_text_exit = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi thoát?'.
              lv_text_exit = TEXT-042.

              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = TEXT-018
                  text_question         = lv_text_exit
                  text_button_1         = TEXT-015
                  text_button_2         = TEXT-016
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'.
                  PERFORM on_save.
                  IF gv_edit_md = abap_true. " còn ở Edit => lỗi
                    PERFORM stay_in_edit_and_focus.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    LEAVE TO SCREEN 0.
                  ENDIF.

                WHEN '2'.
                  PERFORM discard_unsaved_changes.
                  PERFORM unlock_current_table USING p_tab.
                  LEAVE TO SCREEN 0.

                WHEN 'A'.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

              " --- CASE 4: HỖN HỢP ---
            ELSE.
*              lv_text_exit = |Có thay đổi chưa lưu: | &&
*                             lv_new_incomplete_cnt_exit && ' NEWREC thiếu khóa, ' &&
*                             lv_new_complete_cnt_exit   && ' NEWREC đủ khóa, ' &&
*                             lv_edit_existing_cnt_exit  && ' thay đổi dòng cũ. Lưu trước khi thoát?'.
              lv_text_exit = TEXT-043.

              REPLACE '&1' IN lv_text_exit WITH CONV string( lv_new_incomplete_cnt_exit ).
              REPLACE '&2' IN lv_text_exit WITH CONV string( lv_new_complete_cnt_exit ).
              REPLACE '&3' IN lv_text_exit WITH CONV string( lv_edit_existing_cnt_exit ).

              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = TEXT-018
                  text_question         = lv_text_exit
                  text_button_1         = TEXT-015
                  text_button_2         = TEXT-016
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'.
                  PERFORM on_save.
                  IF gv_edit_md = abap_true. " còn ở Edit => lỗi
                    PERFORM stay_in_edit_and_focus.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    PERFORM unlock_current_table USING p_tab.
                    LEAVE TO SCREEN 0.
                  ENDIF.

                WHEN '2'.
                  PERFORM discard_unsaved_changes.
                  PERFORM unlock_current_table USING p_tab.
                  LEAVE TO SCREEN 0.

                WHEN 'A'.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

            ENDIF. " kết thúc ELSE có thay đổi

          ENDIF. " lv_has_change_exit

          "==================================================================
        WHEN 'SAVE'.
          "==================================================================

          PERFORM on_save.  "on_save tự quyết định: OK -> về View, Lỗi -> ở lại Edit

          " Áp lại editability & toolbar theo gv_edit_md mà on_save vừa set
          PERFORM apply_editability_and_push.

          IF g_alv_grid IS BOUND.
            TRY.
                g_alv_grid->set_ready_for_input( COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).
              CATCH cx_root.
            ENDTRY.

            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).

            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " KHÔNG xóa NEWREC ở đây. on_save sẽ xóa NEWREC SAU KHI COMMIT thành công.

          "==================================================================
        WHEN OTHERS.
          "==================================================================
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

      ENDCASE.

    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.


FORM apply_editability_and_push.
  " 0) Đảm bảo danh sách KEY
  PERFORM ensure_keys USING p_tab.

  "=== Danh sách field audit cần khóa cứng
  DATA: lt_audit TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit.
  APPEND 'ERTIM' TO lt_audit.
  APPEND 'ERNAM' TO lt_audit.
  APPEND 'AEDAT' TO lt_audit.
  APPEND 'AETIM' TO lt_audit.
  APPEND 'AENAM' TO lt_audit.

  " 1) Fieldcatalog (Cấp cột): Cấu hình Edit/F4 cơ bản
  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.
  DATA: lv_is_key   TYPE abap_bool,
        lv_is_audit TYPE abap_bool.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Audit? -> khóa cứng
    lv_is_audit = abap_false.
    READ TABLE lt_audit WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_is_audit = abap_true.
      CLEAR: <fc>-edit, <fc>-f4availabl.
      CONTINUE.
    ENDIF.

    " Key / Non-key
    lv_is_key = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    IF lv_is_key = abap_true.
      " Key: Chỉ mở edit khi đang ADD
      IF gv_add_mode = abap_true.
        <fc>-edit = 'X'.
      ELSE.
        CLEAR: <fc>-edit.
      ENDIF.
    ELSE.
      " Non-key: Mở edit khi Edit Mode
      IF gv_edit_md = abap_true.
        <fc>-edit = 'X'.
      ELSE.
        CLEAR: <fc>-edit.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Style theo dòng (Cấp ô) -> Xử lý chi tiết từng trường hợp

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <celltab> TYPE lvc_t_styl,
                 <newrec>  TYPE any,
                 <styl>    TYPE lvc_s_styl.
  DATA: ls_styl   TYPE lvc_s_styl,
        lv_key    TYPE dd03l-fieldname,
        lv_is_new TYPE abap_bool,
        lv_af     TYPE lvc_fname.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls> TO <celltab>.
      IF sy-subrc <> 0. CONTINUE. ENDIF.

      CLEAR <celltab>.

      " Check dòng mới?
      lv_is_new = abap_false.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'. lv_is_new = abap_true. ENDIF.

      " --- A. Xử lý Khóa/Mở nhập liệu cho KEY ---
      LOOP AT gt_key_fields INTO lv_key.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_key.
        IF gv_add_mode = abap_true AND lv_is_new = abap_true.
          ls_styl-style = cl_gui_alv_grid=>mc_style_enabled.
        ELSE.
          ls_styl-style = cl_gui_alv_grid=>mc_style_disabled.
        ENDIF.
        INSERT ls_styl INTO TABLE <celltab>.
      ENDLOOP.

      " --- B. Xử lý khóa Audit fields ---
      LOOP AT lt_audit INTO lv_af.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_af.
        ls_styl-style     = cl_gui_alv_grid=>mc_style_disabled.
        " Insert nếu chưa có
        READ TABLE <celltab> WITH KEY fieldname = ls_styl-fieldname TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          INSERT ls_styl INTO TABLE <celltab>.
        ENDIF.
      ENDLOOP.

      " --- C. XỬ LÝ ẨN/HIỆN F4 ---
      " Quy tắc:
      " 1. View Mode: Ẩn tất cả F4.
      " 2. Edit Mode + Dòng Cũ: Ẩn F4 của KEY (vì Key bị khóa), Hiện F4 của Non-Key.
      " 3. Edit Mode + Dòng Mới: Hiện tất cả F4 (mặc định không cần style NO_F4).

      IF gv_edit_md = abap_false.
        " --- VIEW MODE: Ẩn hết F4 ---
        LOOP AT gt_fieldcat ASSIGNING <fc> WHERE f4availabl = 'X'.
          PERFORM add_style_no_f4 USING <fc>-fieldname CHANGING <celltab>.
        ENDLOOP.

      ELSEIF gv_edit_md = abap_true AND lv_is_new = abap_false.
        " --- EDIT MODE (Dòng Cũ): Chỉ ẩn F4 của KEY ---
        LOOP AT gt_key_fields INTO lv_key.
          " Kiểm tra nếu field này có F4 thì mới cần ẩn
          READ TABLE gt_fieldcat ASSIGNING <fc> WITH KEY fieldname = lv_key.
          IF sy-subrc = 0 AND <fc>-f4availabl = 'X'.
            PERFORM add_style_no_f4 USING lv_key CHANGING <celltab>.
          ENDIF.
        ENDLOOP.

        " (Các cột Non-key sẽ tự động hiện F4 do không bị add style NO_F4)
      ENDIF.

    ENDLOOP.
  ENDIF.
  "2b) Tô màu
  PERFORM highlight_error_cells.

  " 3) Đẩy xuống frontend & refresh
  PERFORM dedup_fieldcat.

  IF g_alv_grid IS BOUND.
    " -----------------
    DATA: lv_grid_title TYPE lvc_title.
    IF gv_edit_md = abap_true.
*      lv_grid_title = |Đang thực hiện edit ở bảng { p_tab }|.
      lv_grid_title = TEXT-231.
    ELSE.
*      lv_grid_title = |Đang xem dữ liệu bảng { p_tab }|.
      lv_grid_title = TEXT-232.
    ENDIF.
    REPLACE '&1' IN lv_grid_title WITH p_tab.
    " Đặt tiêu đề cho lưới ALV
    g_alv_grid->set_gridtitle( i_gridtitle = lv_grid_title ).
    " ----------------
    TRY.
        g_alv_grid->set_frontend_fieldcatalog( it_fieldcatalog = gt_fieldcat ).
      CATCH cx_root.
    ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
  ENDIF.
ENDFORM.

"---------------------------------------------------------------------
" Helper FORM để thêm style NO_F4 gọn gàng
"---------------------------------------------------------------------
FORM add_style_no_f4 USING iv_fieldname TYPE lvc_fname
                     CHANGING ct_celltab TYPE lvc_t_styl.
  FIELD-SYMBOLS <styl> TYPE lvc_s_styl.
  DATA ls_new TYPE lvc_s_styl.

  READ TABLE ct_celltab ASSIGNING <styl> WITH KEY fieldname = iv_fieldname.
  IF sy-subrc = 0.
    " Đã có style (ví dụ Disabled), cộng thêm NO_F4
    <styl>-style = <styl>-style + cl_gui_alv_grid=>mc_style_f4_no.
  ELSE.
    " Chưa có style, thêm mới
    ls_new-fieldname = iv_fieldname.
    ls_new-style     = cl_gui_alv_grid=>mc_style_f4_no.
    INSERT ls_new INTO TABLE ct_celltab.
  ENDIF.
ENDFORM.



FORM stay_in_edit_and_focus.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.

  " 1) Giữ Edit; Add-mode nếu vẫn còn NEWREC
  gv_edit_md      = abap_true.
  gv_toolbar_mode = 'E'.

  gv_add_mode = abap_false.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        gv_add_mode = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " 2) Áp rule + bật input + rebuild toolbar
  PERFORM apply_editability_and_push.
  PERFORM register_f4_all.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_ready_for_input( 1 ).
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " 3) Focus về KEY của dòng NEWREC (nếu có)
  PERFORM focus_key_on_newrec.

  cl_gui_cfw=>flush( ).
ENDFORM.

FORM build_excluding_toolbar.
  CLEAR gt_tb_excl.

  " === 1. Nhóm thao tác dòng (Edit) ===
  APPEND cl_gui_alv_grid=>mc_fc_loc_insert_row TO gt_tb_excl. " Chèn dòng
  APPEND cl_gui_alv_grid=>mc_fc_loc_delete_row TO gt_tb_excl. " Xóa dòng
  APPEND cl_gui_alv_grid=>mc_fc_loc_append_row TO gt_tb_excl. " Thêm dòng cuối
  APPEND cl_gui_alv_grid=>mc_fc_loc_copy_row   TO gt_tb_excl. " Copy dòng
  APPEND cl_gui_alv_grid=>mc_fc_loc_copy       TO gt_tb_excl. " Copy (Ctrl+C)
  APPEND cl_gui_alv_grid=>mc_fc_loc_paste      TO gt_tb_excl. " Paste (Ctrl+V)
  APPEND cl_gui_alv_grid=>mc_fc_loc_cut        TO gt_tb_excl. " Cut (Ctrl+X)
  APPEND cl_gui_alv_grid=>mc_fc_loc_undo       TO gt_tb_excl. " Undo

  " === 2. Nhóm tiện ích chuẩn (Export/Print/View) ===
  APPEND cl_gui_alv_grid=>mc_mb_export         TO gt_tb_excl. " Menu Export chuẩn
  APPEND cl_gui_alv_grid=>mc_mb_view           TO gt_tb_excl. " Menu Views (Excel in place)
  APPEND cl_gui_alv_grid=>mc_fc_print          TO gt_tb_excl. " Nút Print
  APPEND cl_gui_alv_grid=>mc_fc_graph          TO gt_tb_excl. " Đồ thị
  APPEND cl_gui_alv_grid=>mc_fc_info           TO gt_tb_excl. " Nút Info (chữ i)

  " === 3. Các nút khác  ===
  " APPEND cl_gui_alv_grid=>mc_fc_check          TO gt_tb_excl. " Nút Check (cái icon cái cân)
  APPEND cl_gui_alv_grid=>mc_fc_refresh        TO gt_tb_excl. " Nút Refresh

ENDFORM.

*=====================================================================*
* INCLUDE ZFA25SAP23_IO - Đọc / Upload dữ liệu Excel (.XLSX, .XLS)
*=====================================================================*

TYPES: BEGIN OF alsmex_tabline,
         row   TYPE i,
         col   TYPE i,
         value TYPE string,
       END OF alsmex_tabline.
TYPES: ty_t_alsmex_tab TYPE STANDARD TABLE OF alsmex_tabline WITH DEFAULT KEY.
DATA: lv_date TYPE d,
      lv_time TYPE t,
      lr_desc TYPE REF TO cl_abap_tabledescr.
DATA: lt_bad_indexes TYPE TABLE OF i,
      lv_curr_index  TYPE i.
DATA: lt_bad_rows TYPE TABLE OF i. " Chứa danh sách Row Index bị lỗi
*----------------------------------------------------------------------*
* CLASS lcl_event_handler DEFINITION - Xử lý click trên bảng lỗi
*----------------------------------------------------------------------*
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: mt_error_log TYPE TABLE OF ty_upload_error.

    METHODS: on_link_click FOR EVENT link_click OF cl_salv_events_table
      IMPORTING row column.
ENDCLASS.

*----------------------------------------------------------------------*
* CLASS lcl_event_handler IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_link_click.
    " 1. Tìm dòng lỗi tương ứng trong bảng nội bộ
    READ TABLE mt_error_log INTO DATA(ls_err) INDEX row.
    IF sy-subrc <> 0. RETURN. ENDIF.

    " 2. Tính toán Index trong ALV chính
    " Excel Row 2 (dữ liệu đầu tiên) tương ứng với ALV Index 1
    DATA(lv_alv_index) = ls_err-row_id - 1.

    IF lv_alv_index <= 0. RETURN. ENDIF.

    " 3. Cuộn ALV chính tới dòng đó
    IF g_alv_grid IS BOUND.
      DATA: ls_row_id TYPE lvc_s_row.
      ls_row_id-index = lv_alv_index.

      CALL METHOD g_alv_grid->set_current_cell_via_id
        EXPORTING
          is_row_id = ls_row_id.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
*---------------------------------------------------------------------*
* FORM read_xlsx_clfdt - Đọc file .XLSX bằng class CL_FDT_XL_SPREADSHEET
*---------------------------------------------------------------------*
FORM read_xlsx_clfdt USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.

  DATA: lt_bin   TYPE solix_tab,
        lv_xstr  TYPE xstring,
        lv_file  TYPE string,
        lo_excel TYPE REF TO cl_fdt_xl_spreadsheet,
        lt_names TYPE if_fdt_doc_spreadsheet=>t_worksheet_names,
        lv_sheet TYPE string,
        lr_src   TYPE REF TO data,
        lt_cells TYPE STANDARD TABLE OF alsmex_tabline,
        ls_cell  TYPE alsmex_tabline.

  FIELD-SYMBOLS: <lt_src> TYPE STANDARD TABLE,
                 <ls_src> TYPE any,
                 <lv_any> TYPE any,
                 <lt_ret> TYPE STANDARD TABLE.

  lv_file = iv_file.

  "--- Upload file Excel (.xlsx) dạng nhị phân ---

  CALL METHOD cl_gui_frontend_services=>gui_upload
    EXPORTING
      filename                = lv_file
      filetype                = 'BIN'
      read_by_line            = space
    IMPORTING
      filelength              = DATA(lv_len)
    CHANGING
      data_tab                = lt_bin
    EXCEPTIONS
      file_open_error         = 1
      file_read_error         = 2
      no_batch                = 3
      gui_refuse_filetransfer = 4
      invalid_type            = 5
      no_authority            = 6
      unknown_error           = 7
      OTHERS                  = 8.
  IF sy-subrc <> 0.
*    MESSAGE 'Không đọc được file .xlsx từ frontend' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-044 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_xstr = cl_bcs_convert=>solix_to_xstring( lt_bin ).

  "--- Đọc nội dung file Excel ---
  CREATE OBJECT lo_excel
    EXPORTING
      xdocument     = lv_xstr
      document_name = 'UPLOAD_EXCEL'.

  lo_excel->if_fdt_doc_spreadsheet~get_worksheet_names(
  IMPORTING worksheet_names = lt_names ).
  READ TABLE lt_names INDEX 1 INTO lv_sheet.

  IF sy-subrc <> 0 OR lv_sheet IS INITIAL.
*    MESSAGE 'Không xác định được worksheet đầu tiên' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-045 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_src = lo_excel->if_fdt_doc_spreadsheet~get_itab_from_worksheet( lv_sheet ).
  ASSIGN lr_src->* TO <lt_src>.
  IF <lt_src> IS NOT ASSIGNED.
*    MESSAGE 'Không đọc được dữ liệu từ worksheet' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-046 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Lấy mô tả cấu trúc bảng ---
  DATA lo_tabdesc TYPE REF TO cl_abap_tabledescr.
  DATA lo_linedesc TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  lo_tabdesc ?= cl_abap_typedescr=>describe_by_data( <lt_src> ).
  lo_linedesc ?= CAST cl_abap_structdescr( lo_tabdesc->get_table_line_type( ) ).
  lt_comp = lo_linedesc->get_components( ).

  "--- Chuyển dữ liệu từ Excel → ALSMEX_TABLINE ---
  DATA lv_row TYPE i VALUE 0.
  LOOP AT <lt_src> ASSIGNING <ls_src>.
    lv_row = lv_row + 1.
    DATA(lv_col) = 0.
    LOOP AT lt_comp INTO DATA(ls_comp).
      ASSIGN COMPONENT ls_comp-name OF STRUCTURE <ls_src> TO <lv_any>.
      lv_col = lv_col + 1.

      CLEAR ls_cell.
      ls_cell-row = lv_row.
      ls_cell-col = lv_col.
      ls_cell-value = <lv_any>.
      APPEND ls_cell TO lt_cells.
    ENDLOOP.
  ENDLOOP.

  "--- Gán dữ liệu trả ra ---
  CREATE DATA cr_cells LIKE lt_cells.
  ASSIGN cr_cells->* TO <lt_ret>.
  IF <lt_ret> IS ASSIGNED.
    <lt_ret> = lt_cells.
  ENDIF.

  "--- Trích header (dòng 1) ---
  DATA lt_header TYPE STANDARD TABLE OF string.
  LOOP AT lt_cells INTO ls_cell WHERE row = 1.
    APPEND ls_cell-value TO lt_header.
  ENDLOOP.

  IF lt_header IS INITIAL.
*    MESSAGE 'Không xác định được tiêu đề (header) trong Excel' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-047 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  ct_header = lt_header.

  DESCRIBE TABLE lt_cells LINES DATA(lv_cnt).

  IF lv_cnt = 0.
*    MESSAGE 'Không đọc được dữ liệu từ Excel ' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-048 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
ENDFORM.


*---------------------------------------------------------------------*
* FORM read_xls_fm - Đọc file .XLS bằng FM cũ ALSM_EXCEL_TO_INTERNAL_TABLE
*---------------------------------------------------------------------*
*FORM read_xls_fm USING iv_file TYPE rlgrap-filename
*CHANGING cr_cells TYPE REF TO data
*ct_header TYPE STANDARD TABLE.
*  PERFORM read_xlsx_clfdt USING iv_file CHANGING cr_cells ct_header.
*ENDFORM.



* FORM upload_data_strict_match - Upload Excel → ALV data
FORM upload_data_strict_match.
  gv_in_upload = abap_false.
  TYPES: BEGIN OF alsmex_tabline,
           row   TYPE i,
           col   TYPE i,
           value TYPE string,
         END OF alsmex_tabline.
  DATA: lt_error_log TYPE TABLE OF ty_upload_error,
        ls_error_log TYPE ty_upload_error.
  DATA: lv_filename TYPE rlgrap-filename,
        lt_file     TYPE filetable,
        ls_file     TYPE file_table,
        ls_fc       TYPE lvc_s_fcat,
        lv_rc       TYPE i,
        lr_cells    TYPE REF TO data,
        lt_str      TYPE STANDARD TABLE OF alsmex_tabline,
        lt_header   TYPE STANDARD TABLE OF string,
        lv_msg      TYPE string.

  "=== 1) Hộp thoại chọn file Excel ===
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title      = CONV string( TEXT-049 )
      default_extension = 'XLSX'
*     file_filter       = 'Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls|All files (*.*)|*.*'
      file_filter       = CONV string( TEXT-200 )
      multiselection    = abap_false
    CHANGING
      file_table        = lt_file
      rc                = lv_rc
    EXCEPTIONS
      OTHERS            = 1.

  IF lv_rc < 1 OR sy-subrc <> 0.
*    MESSAGE 'Upload bị hủy hoặc lỗi khi chọn file' TYPE 'I'.
    MESSAGE TEXT-050 TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  READ TABLE lt_file INTO ls_file INDEX 1.
  IF sy-subrc <> 0 OR ls_file-filename IS INITIAL.
*    MESSAGE 'Không đọc được đường dẫn file' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-051 TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  lv_filename = ls_file-filename.
  "=== Tạo bảng tạm chứa dữ liệu Excel ===
  DATA: lr_upload TYPE REF TO data,
        lr_desc   TYPE REF TO cl_abap_tabledescr.

  FIELD-SYMBOLS: <lt_upload> TYPE STANDARD TABLE.

  lr_desc ?= cl_abap_tabledescr=>describe_by_data_ref( gr_data ).
  CREATE DATA lr_upload TYPE HANDLE lr_desc.
  ASSIGN lr_upload->* TO <lt_upload>.
  "=== 2) Đọc dữ liệu Excel ===
  IF lv_filename CP '*.xlsx' OR lv_filename CP '*.XLSX'.
    PERFORM read_xlsx_clfdt USING lv_filename CHANGING lr_cells lt_header.
*  ELSEIF lv_filename CP '*.xls' OR lv_filename CP '*.XLS'.
*    PERFORM read_xls_fm USING lv_filename CHANGING lr_cells lt_header.
  ELSE.
*    MESSAGE 'Định dạng file không được hỗ trợ (chỉ .xls / .xlsx)' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-052 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lr_cells IS INITIAL.
*    MESSAGE 'Không đọc được dữ liệu từ file Excel' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-048 TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  FIELD-SYMBOLS: <lt_str>      TYPE ty_t_alsmex_tab.

  ASSIGN lr_cells->* TO <lt_str>.
  IF <lt_str> IS INITIAL.
*    MESSAGE 'File Excel rỗng hoặc lỗi định dạng' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-053 TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  "=== 3b) Kiểm tra header Excel khớp DDIC ===
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        ls_ddic_field  TYPE dfies,
        lt_missing     TYPE STANDARD TABLE OF string,
        lt_extra       TYPE STANDARD TABLE OF string.

  DATA: lt_dfies     TYPE STANDARD TABLE OF dfies,
        lt_keys_meta TYPE STANDARD TABLE OF dd03l-fieldname.

  PERFORM get_metadata USING p_tab CHANGING lt_dfies.

  " Lấy key fields
  SELECT fieldname FROM dd03l INTO TABLE @lt_keys_meta
    WHERE tabname = @p_tab AND keyflag = 'X' AND fieldname <> 'MANDT'.

  PERFORM build_fieldcat_all.
  gt_key_fields = lt_keys_meta.

  lt_ddic_fields = lt_dfies.

  IF sy-subrc <> 0 OR lt_ddic_fields IS INITIAL.
*    MESSAGE |Không lấy được metadata của bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    lv_msg = TEXT-054.
    REPLACE '&1' IN lv_msg WITH p_tab.

    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.


    RETURN.
  ENDIF.

  " Bỏ các field kỹ thuật không cần upload ---
  DELETE lt_ddic_fields WHERE fieldname = 'MANDT'.
  " Chuẩn hóa tên header Excel
  LOOP AT lt_header INTO DATA(lv_header_norm).
    lv_header_norm = to_upper( condense( lv_header_norm ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_header_norm WITH ''.
    CONDENSE lv_header_norm NO-GAPS.
    MODIFY lt_header FROM lv_header_norm INDEX sy-tabix.
  ENDLOOP.

  "Chuẩn hóa tên field DDIC
  DATA lt_ddic_names TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
  LOOP AT lt_ddic_fields INTO ls_ddic_field.
    DATA(lv_ddic_norm) = to_upper( condense( ls_ddic_field-fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_ddic_norm WITH ''.
    CONDENSE lv_ddic_norm NO-GAPS.
    APPEND lv_ddic_norm TO lt_ddic_names.
  ENDLOOP.

  "So sánh 2 danh sách
  LOOP AT lt_ddic_names INTO DATA(lv_fieldname).
    READ TABLE lt_header WITH KEY table_line = lv_fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
*      APPEND |Thiếu cột trong Excel: { lv_fieldname }| TO lt_missing.
      lv_msg = TEXT-055.                        " TEXT-007: 'Thiếu cột trong Excel: &1'
      REPLACE '&1' IN lv_msg WITH lv_fieldname.

      APPEND lv_msg TO lt_missing.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_header INTO DATA(lv_hdrname).
    READ TABLE lt_ddic_names WITH KEY table_line = lv_hdrname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
*      APPEND |Cột thừa trong Excel: { lv_hdrname }| TO lt_extra.
      lv_msg = TEXT-056. "Cột thừa trong Excel: &1
      REPLACE '&1' IN lv_msg WITH lv_hdrname.
      APPEND lv_msg TO lt_extra.
    ENDIF.
  ENDLOOP.

  " Báo lỗi nếu có thiếu/thừa
  IF lt_missing IS NOT INITIAL.
    LOOP AT lt_missing INTO DATA(lv_miss).
      MESSAGE lv_miss TYPE 'S' DISPLAY LIKE 'E'.
    ENDLOOP.
*    MESSAGE |Header Excel bị thiếu cột so với bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    lv_msg = TEXT-057. "Header Excel bị thiếu cột so với bảng &1
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  IF lt_extra IS NOT INITIAL.
    LOOP AT lt_extra INTO DATA(lv_ext).
      MESSAGE lv_ext TYPE 'S' DISPLAY LIKE 'E'.
    ENDLOOP.
*    MESSAGE |Excel có thêm cột không nằm trong bảng { p_tab }| TYPE 'S'.
    lv_msg = TEXT-058. "Excel có thêm cột không nằm trong bảng &1
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " Gán dữ liệu vào GR_DATA ===
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any,
                 <val>     TYPE any.

  ASSIGN gr_data->* TO <lt_data>.
  IF sy-subrc <> 0 OR <lt_data> IS NOT ASSIGNED.
*    MESSAGE 'Lỗi gán GR_DATA' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-059 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  DATA lv_prev_row TYPE i VALUE 0.
  DATA lv_all_empty TYPE abap_bool.


  LOOP AT <lt_str> INTO DATA(ls_cell).

    "Bỏ header row
    IF ls_cell-row = 1.
      CONTINUE.
    ENDIF.

    "Chỉ kiểm tra rỗng 1 lần cho 1 row Excel
    IF lv_prev_row <> ls_cell-row.
      lv_prev_row = ls_cell-row.

      lv_all_empty = abap_true.
      LOOP AT <lt_str> INTO DATA(ls_check) WHERE row = ls_cell-row.
        IF ls_check-value IS NOT INITIAL.
          lv_all_empty = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_all_empty = abap_true.
        CONTINUE. "
      ENDIF.
    ENDIF.

    READ TABLE lt_header INDEX ls_cell-col INTO DATA(lv_hdr_fieldname).
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    " Chuẩn hóa tên Header từ Excel
    DATA(lv_field_excel_norm) = lv_hdr_fieldname.
    TRANSLATE lv_field_excel_norm TO UPPER CASE.
    CONDENSE lv_field_excel_norm NO-GAPS.
    REPLACE ALL OCCURRENCES OF '_' IN lv_field_excel_norm WITH ''.
    CONDENSE lv_field_excel_norm NO-GAPS.
    " Map ngược tên chuẩn hóa về tên Field thực tế trong DDIC
    DATA: lv_final_fieldname TYPE fieldname.
    CLEAR lv_final_fieldname.

    LOOP AT lt_ddic_fields INTO DATA(ls_ddic_check).
      " Chuẩn hóa tên field trong DDIC tương tự như Excel
      DATA(lv_ddic_norm_check) = ls_ddic_check-fieldname.
      TRANSLATE lv_ddic_norm_check TO UPPER CASE.
      REPLACE ALL OCCURRENCES OF '_' IN lv_ddic_norm_check WITH ''.
      CONDENSE lv_ddic_norm_check NO-GAPS.

      " So sánh
      IF lv_ddic_norm_check = lv_field_excel_norm.
        lv_final_fieldname = ls_ddic_check-fieldname.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_final_fieldname IS INITIAL.
      CONTINUE.
    ENDIF.
    "  Xử lý tạo dòng mới
    DATA(lv_row) = ls_cell-row.

    " Chuyển INDEX Excel -> INDEX trong <lt_upload>
    DATA(lv_target_index) = lv_row - 1.

    IF lv_target_index <= 0.
      CONTINUE.
    ENDIF.

    " Tạo đúng 1 dòng tương ứng row Excel
    READ TABLE <lt_upload> INDEX lv_target_index ASSIGNING <ls_data>.
    IF sy-subrc <> 0.
      APPEND INITIAL LINE TO <lt_upload> ASSIGNING <ls_data>.
    ENDIF.

    " Gán dữ liệu vào field thực tế
    ASSIGN COMPONENT lv_final_fieldname OF STRUCTURE <ls_data> TO <val>.

    " 4. Validate dữ liệu
    IF <val> IS ASSIGNED.

      " Lấy metadata field từ DDIC bằng tên CHUẨN (lv_final_fieldname)
      READ TABLE lt_ddic_fields INTO DATA(ls_ddic) WITH KEY fieldname = lv_final_fieldname.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      DATA(lv_val_excel) = ls_cell-value.

      "Chuẩn hóa giá trị đặc biệt ===
      IF ls_ddic-inttype = 'D' AND ( lv_val_excel = '00000000' OR lv_val_excel = '0' ).
        CLEAR lv_val_excel.
      ENDIF.
      IF ls_ddic-inttype = 'T' AND ( lv_val_excel = '000000' OR lv_val_excel = '0' ).
        CLEAR lv_val_excel.
      ENDIF.

      DATA(lv_type) = ls_ddic-inttype.
      DATA(lv_valid) = abap_true.

      "  Kiểm tra kiểu dữ liệu cơ bản
      CASE lv_type.
        WHEN 'D'. " Date
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_date) = CONV d( lv_val_excel ).
                CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
                  EXPORTING
                    date                      = lv_date
                  EXCEPTIONS
                    plausibility_check_failed = 1
                    OTHERS                    = 2.
                IF sy-subrc <> 0.
                  lv_valid = abap_false.
*                  lv_msg   = 'Ngày tháng không hợp lệ (YYYYMMDD)'.
                  lv_msg = TEXT-217.
                ENDIF.
              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
*                lv_msg   = 'Ngày tháng sai định dạng'.
                  lv_msg   = TEXT-218.
            ENDTRY.
          ENDIF.

        WHEN 'T'. " Time
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_time) = CONV t( lv_val_excel ).
                DATA(lv_dummy_date) = CONV d( '19700101' ).
                CONVERT DATE lv_dummy_date TIME lv_time INTO TIME STAMP DATA(lv_timestamp_t) TIME ZONE 'UTC'.
              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
*                lv_msg   = 'Thời gian sai định dạng'.
                lv_msg   = TEXT-219.
            ENDTRY.
          ENDIF.

        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
          TRY.
              lv_val_excel = lv_val_excel + 0.
            CATCH cx_sy_conversion_no_number cx_sy_conversion_error.
              lv_valid = abap_false.
*              lv_msg   = 'Giá trị không phải là số'.
               lv_msg   = TEXT-220.
          ENDTRY.

        WHEN 'N'. " NUMC
*          lv_val_excel = condense( to_upper( lv_val_excel ) ).
          lv_val_excel = condense( lv_val_excel ).
          IF lv_val_excel IS NOT INITIAL AND NOT lv_val_excel CO '0123456789'.
            lv_valid = abap_false.
*            lv_msg   = 'Trường số chỉ được chứa ký tự số'.
            lv_msg   = TEXT-221.
          ENDIF.

        WHEN OTHERS.
          lv_valid = abap_true.
      ENDCASE.

      " Nếu dữ liệu không hợp lệ -> Báo lỗi
      IF lv_valid = abap_false.
          ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag>).
          IF <lv_err_flag> IS ASSIGNED. <lv_err_flag> = 'X'. ENDIF.

        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_msg>).
        IF <lv_err_msg> IS ASSIGNED.
          lv_msg = TEXT-060.
          REPLACE '&1' IN lv_msg WITH lv_final_fieldname.
          REPLACE '&2' IN lv_msg WITH lv_val_excel.
          <lv_err_msg> = lv_msg.
        ENDIF.

        CLEAR ls_error_log.
        ls_error_log-row_id   = ls_cell-row.

        " Lấy tên cột
        IF ls_ddic-scrtext_m IS NOT INITIAL.
          ls_error_log-col_name = ls_ddic-scrtext_m.
        ELSE.
          ls_error_log-col_name = lv_final_fieldname.
        ENDIF.

        ls_error_log-value    = lv_val_excel.
        ls_error_log-message  = lv_msg.

        APPEND ls_error_log TO lt_error_log.
        APPEND ls_cell-row TO lt_bad_rows.
        " ============================================
        CONTINUE.
      ENDIF.

      " Kiểm tra Domain Values
      IF ls_ddic-domname IS NOT INITIAL.
        DATA(lt_dom_values) = VALUE dd07v_tab( ).
        CALL FUNCTION 'DD_DOMVALUES_GET'
          EXPORTING
            domname        = ls_ddic-domname
            text           = 'X'
          TABLES
            dd07v_tab      = lt_dom_values
          EXCEPTIONS
            wrong_textflag = 1
            OTHERS         = 2.

        IF sy-subrc = 0 AND lt_dom_values IS NOT INITIAL.
          DATA(lv_value_found) = abap_false.
          LOOP AT lt_dom_values INTO DATA(ls_dom).
            IF to_upper( ls_dom-domvalue_l ) = to_upper( lv_val_excel ).
              lv_value_found = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_value_found = abap_false.
*            ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag2>).
*            IF <lv_err_flag2> IS ASSIGNED. <lv_err_flag2> = 'X'. ENDIF.


            " 1. Ghi log
            CLEAR ls_error_log.
            ls_error_log-row_id   = ls_cell-row.

            IF ls_ddic-scrtext_m IS NOT INITIAL.
              ls_error_log-col_name = ls_ddic-scrtext_m.
            ELSE.
              ls_error_log-col_name = lv_final_fieldname.
            ENDIF.

            ls_error_log-value    = lv_val_excel.
*            ls_error_log-message  = 'Giá trị không nằm trong danh sách cho phép (Domain)'.
            ls_error_log-message = TEXT-222.
            APPEND ls_error_log TO lt_error_log.
            APPEND ls_cell-row TO lt_bad_rows.
            " 2. Xóa giá trị sai
            CLEAR <val>.
            " 3. Bỏ qua
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      " Gán giá trị cuối cùng
      TRY.
          <val> = lv_val_excel.
        CATCH cx_sy_conversion_error.
*          ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag3>).
*          IF <lv_err_flag3> IS ASSIGNED. <lv_err_flag3> = 'X'. ENDIF.
*          CONTINUE.

          " 1. Ghi log
          CLEAR ls_error_log.
          ls_error_log-row_id   = ls_cell-row.

          IF ls_ddic-scrtext_m IS NOT INITIAL.
            ls_error_log-col_name = ls_ddic-scrtext_m.
          ELSE.
            ls_error_log-col_name = lv_final_fieldname.
          ENDIF.

          ls_error_log-value    = lv_val_excel.
*          ls_error_log-message  = 'Lỗi chuyển đổi dữ liệu không xác định'.
          ls_error_log-message = TEXT-223.
          APPEND ls_error_log TO lt_error_log.
          APPEND ls_cell-row TO lt_bad_rows.
          " 2. Xóa giá trị sai
          CLEAR <val>.
          " 3. Bỏ qua
          CONTINUE.
      ENDTRY.

    ENDIF.
  ENDLOOP.

" --- ĐOẠN FIX LỖI (TINH CHỈNH) ---
  IF lt_bad_rows IS NOT INITIAL.
    SORT lt_bad_rows.
    DELETE ADJACENT DUPLICATES FROM lt_bad_rows.

    DATA(lv_total_lines) = lines( <lt_upload> ).
    " Duyệt ngược
    WHILE lv_total_lines > 0.
      " Dòng 1 trong <lt_upload> tương ứng dòng 2 trong Excel (do dòng 1 Excel là header)
      DATA(lv_excel_row_num) = lv_total_lines + 1.

      READ TABLE lt_bad_rows WITH KEY table_line = lv_excel_row_num TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        DELETE <lt_upload> INDEX lv_total_lines.
      ENDIF.

      lv_total_lines = lv_total_lines - 1.
    ENDWHILE.
  ENDIF.

  "Loại bỏ các dòng có KEY rỗng
  DATA lv_index TYPE sy-tabix.

  lv_index = 1.
  LOOP AT <lt_upload> ASSIGNING <ls_data>.
    DATA(lv_key_empty) = abap_true.

    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
      ASSIGN COMPONENT <k> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<valkey>).
      IF <valkey> IS ASSIGNED AND <valkey> IS NOT INITIAL.
        lv_key_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_key_empty = abap_true.
      DELETE <lt_upload> INDEX lv_index.
      " vì sau delete index tự shift, giảm không tăng
      CONTINUE.
    ENDIF.

    lv_index += 1. " chỉ tăng nếu không delete
  ENDLOOP.

  IF <lt_upload> IS INITIAL.
    MESSAGE TEXT-050 TYPE 'S' DISPLAY LIKE 'E'.   "Upload cancelled or file selection error.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.

  "Merge dữ liệu Excel vào ALV hiện tại
  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <lt_alv>.
IF lt_error_log IS NOT INITIAL.
    PERFORM show_upload_error_log USING lt_error_log.
  ENDIF.
  IF <lt_alv> IS ASSIGNED.

    DATA(lv_inserted) = 0.
    DATA(lv_updated)  = 0.

    LOOP AT <lt_upload> ASSIGNING FIELD-SYMBOL(<ls_new>).
      DATA(lv_found) = abap_false.

      LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_old>).
        DATA(lv_samekey) = abap_true.

        LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld>).
          FIELD-SYMBOLS: <v_old> TYPE any, <v_new> TYPE any.
          ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_old> TO <v_old>.
          ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_new> TO <v_new>.
          IF <v_old> IS ASSIGNED AND <v_new> IS ASSIGNED AND |{ <v_old> }| <> |{ <v_new> }|.
            lv_samekey = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_samekey = abap_true.
          "  So sánh xem có thay đổi không
          DATA(lv_changed) = abap_false.
          LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc_chk>).
            " Bỏ qua field kỹ thuật và audit
            IF <fc_chk>-tech = abap_true OR <fc_chk>-no_out = abap_true.
              CONTINUE.
            ENDIF.
            IF <fc_chk>-fieldname CP 'ER*' OR <fc_chk>-fieldname CP 'AE*' OR <fc_chk>-fieldname CP 'IS_*'.
              CONTINUE.
            ENDIF.

            ASSIGN COMPONENT <fc_chk>-fieldname OF STRUCTURE <ls_new> TO FIELD-SYMBOL(<v_n>).
            ASSIGN COMPONENT <fc_chk>-fieldname OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<v_o>).

            IF <v_n> IS ASSIGNED AND <v_o> IS ASSIGNED AND <v_n> <> <v_o>.
              lv_changed = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF lv_changed = abap_true.
            " Chỉ copy field thường, giữ nguyên 3 field create
            LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc_upd>).
              IF <fc_upd>-fieldname CP 'ER*' OR <fc_upd>-fieldname = 'MANDT'.
                CONTINUE.
              ENDIF.
              ASSIGN COMPONENT <fc_upd>-fieldname OF STRUCTURE <ls_new> TO FIELD-SYMBOL(<v_new2>).
              ASSIGN COMPONENT <fc_upd>-fieldname OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<v_old2>).
              IF <v_new2> IS ASSIGNED AND <v_old2> IS ASSIGNED.
                <v_old2> = <v_new2>.
              ENDIF.
            ENDLOOP.


            "  Chỉ đánh dấu IS_CHANGED, không update 3 field audit ở bước preview
            ASSIGN COMPONENT 'IS_CHANGED' OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<flag_upd>).
            IF sy-subrc = 0. <flag_upd> = 'X'. ENDIF.

            lv_updated += 1.
          ENDIF.

          lv_found = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.


      IF lv_found = abap_false.
        "Bỏ record nếu key rỗng
        lv_key_empty = abap_true.

        LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<key_upl>).
          ASSIGN COMPONENT <key_upl> OF STRUCTURE <ls_new> TO FIELD-SYMBOL(<vkey_upl>).
          IF <vkey_upl> IS ASSIGNED AND <vkey_upl> IS NOT INITIAL.
            lv_key_empty = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_key_empty = abap_true.
          CONTINUE.
        ENDIF.

        "  Record mới
        APPEND INITIAL LINE TO <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_newrow>).
        MOVE-CORRESPONDING <ls_new> TO <ls_newrow>.

        ASSIGN COMPONENT 'IS_NEW' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<flag_new>).
        IF sy-subrc = 0. <flag_new> = 'X'. ENDIF.

        ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<erdat>).
        ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<ertim>).
        ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<ernam>).
        IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
        IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
        IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.

        lv_inserted += 1.
      ENDIF.
    ENDLOOP.

    " Thông báo kết quả merge
    DATA(lv_total) = lv_inserted + lv_updated.
    IF lv_total > 0.
*      MESSAGE |Đã upload { lv_total } dòng dữ liệu tạm thời (INSERT={ lv_inserted }, UPDATE={ lv_updated }).| TYPE 'S'.
      DATA(lv_total_str)    = |{ lv_total }|.
      DATA(lv_inserted_str) = |{ lv_inserted }|.
      DATA(lv_updated_str)  = |{ lv_updated }|.

      lv_msg = TEXT-061. "Đã upload &1 dòng dữ liệu tạm thời (INSERT=&2, UPDATE=&3).
      REPLACE '&1' IN lv_msg WITH lv_total_str.
      REPLACE '&2' IN lv_msg WITH lv_inserted_str.
      REPLACE '&3' IN lv_msg WITH lv_updated_str.
      MESSAGE lv_msg TYPE 'S'.
      gv_in_upload = abap_true.
    ELSE.
      IF lt_error_log IS NOT INITIAL.
        " Thông báo dữ liệu lỗi (Bạn có thể tạo TEXT-XXX mới hoặc hardcode tạm)
        MESSAGE 'Dữ liệu không hợp lệ đã bị loại bỏ, vui lòng kiểm tra bảng log' TYPE 'S' DISPLAY LIKE 'E'.
        ELSE.
*      MESSAGE 'Không có thay đổi mới trong file Excel.' TYPE 'I'.
      MESSAGE TEXT-062 TYPE 'S' DISPLAY LIKE 'E'.
      ENDIF.
      gv_in_upload = abap_false.
      RETURN.
    ENDIF.

  ENDIF.
IF lt_error_log IS NOT INITIAL.
      PERFORM show_upload_error_log USING lt_error_log.
    ENDIF.

  " Refresh hiển thị preview
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root INTO DATA(lx_refresh).
        MESSAGE lx_refresh->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDIF.

  "  Kiểm tra trùng khóa chính trong Excel
  DATA(lt_keys) = VALUE string_table( ).
  LOOP AT lt_ddic_fields INTO DATA(ls_keyfld) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_keyfld-fieldname TO lt_keys.
  ENDLOOP.

  IF lt_keys IS NOT INITIAL.
    DATA(lt_seen_keys) = VALUE string_table( ).
    DATA(lv_key_string) = VALUE string( ).

    LOOP AT <lt_data> ASSIGNING <ls_data>.
      CLEAR lv_key_string.
      LOOP AT lt_keys INTO DATA(lv_keyfld).
        ASSIGN COMPONENT lv_keyfld OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_keyval3>).
        IF <lv_keyval3> IS ASSIGNED.
          lv_key_string = lv_key_string && to_upper( condense( <lv_keyval3> ) ) && '|'.
        ENDIF.
      ENDLOOP.

      IF lv_key_string IS INITIAL.
        CONTINUE.
      ENDIF.

      READ TABLE lt_seen_keys WITH KEY table_line = lv_key_string TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        ASSIGN COMPONENT 'IS_DUPLICATE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_dupflag>).
        IF <lv_dupflag> IS ASSIGNED.
          <lv_dupflag> = 'X'.
        ENDIF.
        CONTINUE.
      ELSE.
        APPEND lv_key_string TO lt_seen_keys.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "  Kiểm tra các trường bắt buộc (Key fields)

  DATA: lt_errors   TYPE STANDARD TABLE OF char255,
        lv_err_text TYPE char255.
  DATA(lt_required_fields) = VALUE string_table( ).

  LOOP AT lt_ddic_fields INTO DATA(ls_req) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_req-fieldname TO lt_required_fields.
  ENDLOOP.

  IF lt_required_fields IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      DATA(lv_missing_fields) = VALUE string( ).
      LOOP AT lt_required_fields INTO DATA(lv_req_field).
        ASSIGN COMPONENT lv_req_field OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_req_val>).
        IF <lv_req_val> IS ASSIGNED AND <lv_req_val> IS INITIAL.
          lv_missing_fields = lv_missing_fields && lv_req_field && ', '.
        ENDIF.
      ENDLOOP.

      IF lv_missing_fields IS NOT INITIAL.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag_req>).
        IF <lv_err_flag_req> IS ASSIGNED.
          <lv_err_flag_req> = 'X'.
        ENDIF.

        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_msg_flag>).
        IF <lv_msg_flag> IS ASSIGNED.
*          CONCATENATE 'Thiếu dữ liệu bắt buộc: ' lv_missing_fields INTO <lv_msg_flag>.
          lv_msg = TEXT-063. "Thiếu dữ liệu bắt buộc: &1
          REPLACE '&1' IN lv_msg WITH lv_missing_fields.
          <lv_msg_flag> = lv_msg.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
  "Xác định lại dòng INSERT / UPDATE
  PERFORM ensure_keys USING p_tab.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0.
      CLEAR <newrec>.
    ENDIF.

    " Xây điều kiện WHERE theo key
    DATA(lv_where2) = VALUE string( ).
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld2>).
      ASSIGN COMPONENT <keyfld2> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<valkey2>).
      IF <valkey2> IS ASSIGNED.
        DATA(lv_val2) = |{ <valkey2> }|.
        CONDENSE lv_val2 NO-GAPS.
        IF lv_where2 IS INITIAL.
          lv_where2 = |{ <keyfld2> } = '{ lv_val2 }'|.
        ELSE.
          lv_where2 = |{ lv_where2 } AND { <keyfld2> } = '{ lv_val2 }'|.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lv_where2 IS INITIAL.
      CONTINUE.
    ENDIF.

    " Kiểm tra tồn tại trong DB
    DATA lv_dummy TYPE i.

    TRY.
        SELECT SINGLE COUNT(*)
          FROM (p_tab)
          WHERE (lv_where2)
          INTO @lv_dummy.
      CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
        MESSAGE lx_sem->get_text( ) TYPE 'I'.
        CONTINUE.
    ENDTRY.
    IF sy-subrc <> 0 AND <newrec> IS ASSIGNED.
      <newrec> = 'X'. " dòng mới
    ENDIF.
  ENDLOOP.
  "Chuẩn hóa key NUMC để không mất leading zero ===
  LOOP AT <lt_data> ASSIGNING <ls_data>.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld3>).
      READ TABLE lt_ddic_fields INTO DATA(ls_meta3) WITH KEY fieldname = <keyfld3>.
      IF sy-subrc = 0 AND ls_meta3-inttype = 'N'.
        ASSIGN COMPONENT <keyfld3> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<val3>).
        IF <val3> IS ASSIGNED.
          DATA(lv_norm3) = condense( |{ <val3> }| ).
          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = lv_norm3
            IMPORTING
              output = lv_norm3.
          <val3> = lv_norm3.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  " Cập nhật logic insert/update cho 6 field audit ===
  DATA: lv_tabname TYPE tabname,
        lv_user    TYPE sy-uname,
        lv_tzone   TYPE tznzone,
        lv_ts      TYPE timestamp.

  lv_tabname = p_tab.
  lv_user    = sy-uname.

  " Lấy timezone thật của user (ví dụ ICT cho Việt Nam)
  TRY.
      lv_tzone = cl_abap_context_info=>get_user_time_zone( ).
    CATCH cx_abap_context_info_error.
      lv_tzone = 'UTC'.
  ENDTRY.

  GET TIME STAMP FIELD lv_ts.
  CONVERT TIME STAMP lv_ts TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.
  DATA(lv_new_count)     = 0.
  DATA(lv_changed_count) = 0.
  " Duyệt dữ liệu ALV hiện tại (đã merge)
  ASSIGN gr_data->* TO <lt_alv>.

  LOOP AT <lt_alv> ASSIGNING <ls_data>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_newrec_flag>).
    IF <lv_newrec_flag> IS ASSIGNED AND <lv_newrec_flag> = 'X'.
      lv_new_count += 1.

      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_erdat>).
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ertim>).
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ernam>).
      IF <lv_erdat> IS ASSIGNED. <lv_erdat> = lv_date. ENDIF.
      IF <lv_ertim> IS ASSIGNED. <lv_ertim> = lv_time. ENDIF.
      IF <lv_ernam> IS ASSIGNED. <lv_ernam> = lv_user. ENDIF.

      " Clear Changed*
      ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat_i>).
      ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim_i>).
      ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam_i>).
      IF <lv_aedat_i> IS ASSIGNED. CLEAR <lv_aedat_i>. ENDIF.
      IF <lv_aetim_i> IS ASSIGNED. CLEAR <lv_aetim_i>. ENDIF.
      IF <lv_aenam_i> IS ASSIGNED. CLEAR <lv_aenam_i>. ENDIF.

      CONTINUE.
    ENDIF.
    FIELD-SYMBOLS: <val_old> TYPE any,
                   <val_new> TYPE any.

    " Xây WHERE theo key để check record trong DB
    DATA(lv_where) = VALUE string( ).
    LOOP AT gt_key_fields ASSIGNING <keyfld>.
      ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_key>).
      IF <lv_key> IS ASSIGNED.
        IF lv_where IS INITIAL.
          lv_where = |{ <keyfld> } = '{ <lv_key> }'|.
        ELSE.
          lv_where = |{ lv_where } AND { <keyfld> } = '{ <lv_key> }'|.
        ENDIF.
      ENDIF.
    ENDLOOP.

    " Tạo record tạm để đọc DB
    DATA(lo_struct) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_name( lv_tabname ) ).
    DATA lr_db TYPE REF TO data.
    CREATE DATA lr_db TYPE HANDLE lo_struct.
    ASSIGN lr_db->* TO FIELD-SYMBOL(<ls_db>).

    DATA: lo_sql    TYPE REF TO cl_sql_statement,
          lo_result TYPE REF TO cl_sql_result_set,
          lx_sql2   TYPE REF TO cx_sql_exception.

    DATA(lv_sql) = |SELECT * FROM { lv_tabname } WHERE { lv_where }|.

    CREATE OBJECT lo_sql.

    TRY.
        lo_result = lo_sql->execute_query( lv_sql ).
        lo_result->set_param_struct( REF #( <ls_db> ) ).
        lo_result->next( ).
      CATCH cx_sql_exception INTO lx_sql2.
        CLEAR <ls_db>.
    ENDTRY.


    IF <ls_db> IS ASSIGNED AND <ls_db> IS NOT INITIAL.
      CLEAR lv_changed.

      LOOP AT lt_ddic_fields INTO DATA(ls_field).
        IF ls_field-fieldname CP 'MANDT' OR
           ls_field-fieldname CP 'AE*' OR
           ls_field-fieldname CP 'ER*'.
          CONTINUE.
        ENDIF.
        ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_data> TO <val_new>.
        ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_db>  TO <val_old>.
        IF <val_new> IS ASSIGNED AND <val_old> IS ASSIGNED.

          "=== Normalize giá trị theo kiểu dữ liệu
          READ TABLE lt_ddic_fields INTO DATA(ls_type) WITH KEY fieldname = ls_field-fieldname.
          IF sy-subrc = 0.
            DATA(lv_old_str) = |{ <val_old> }|.
            DATA(lv_new_str) = |{ <val_new> }|.

            CASE ls_type-inttype.
              WHEN 'N'.  " NUMC
                SHIFT lv_old_str LEFT DELETING LEADING '0'.
                SHIFT lv_new_str LEFT DELETING LEADING '0'.
              WHEN 'I' OR 'P' OR 'F' OR 'CURR' OR 'QUAN'.
                CONDENSE lv_old_str NO-GAPS.
                CONDENSE lv_new_str NO-GAPS.
              WHEN 'D'. " Date
                IF lv_old_str = '00000000'. CLEAR lv_old_str. ENDIF.
                IF lv_new_str = '00000000'. CLEAR lv_new_str. ENDIF.
              WHEN 'T'. " Time
                IF lv_old_str = '000000'. CLEAR lv_old_str. ENDIF.
                IF lv_new_str = '000000'. CLEAR lv_new_str. ENDIF.
              WHEN OTHERS.

            ENDCASE.

            IF lv_old_str <> lv_new_str.
              lv_changed = abap_true.
              EXIT.
            ENDIF.
          ENDIF.

        ENDIF.

      ENDLOOP.

      IF lv_changed = abap_true.
        lv_changed_count += 1.
        ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat>).
        ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim>).
        ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam>).
        IF <lv_aedat> IS ASSIGNED. <lv_aedat> = lv_date. ENDIF.
        IF <lv_aetim> IS ASSIGNED. <lv_aetim> = lv_time. ENDIF.
        IF <lv_aenam> IS ASSIGNED. <lv_aenam> = lv_user. ENDIF.
      ENDIF.

    ELSE.
      lv_new_count += 1.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_erdat_i>).
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ertim_i>).
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ernam_i>).
      IF <lv_erdat_i> IS ASSIGNED. <lv_erdat_i> = lv_date. ENDIF.
      IF <lv_ertim_i> IS ASSIGNED. <lv_ertim_i> = lv_time. ENDIF.
      IF <lv_ernam_i> IS ASSIGNED. <lv_ernam_i> = lv_user. ENDIF.

      ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat_new>).
      ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim_new>).
      ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam_new>).
      IF <lv_aedat_new> IS ASSIGNED. CLEAR <lv_aedat_new>. ENDIF.
      IF <lv_aetim_new> IS ASSIGNED. CLEAR <lv_aetim_new>. ENDIF.
      IF <lv_aenam_new> IS ASSIGNED. CLEAR <lv_aenam_new>. ENDIF.
    ENDIF.



  ENDLOOP.

  DESCRIBE TABLE <lt_data> LINES DATA(lv_count).
  IF lv_count = 0.
*    MESSAGE 'Không có dữ liệu hợp lệ sau upload!' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-064 TYPE 'S' DISPLAY LIKE 'E'.
    gv_in_upload = abap_false.
    RETURN.
  ENDIF.
  DATA(lv_total_changed) = lv_new_count + lv_changed_count.

  IF lv_total_changed > 0.
*    MESSAGE |Đã upload { lv_total_changed } dòng dữ liệu tạm thời ({ lv_new_count } dòng mới, { lv_changed_count } dòng cập nhật).| TYPE 'S'.
    lv_msg = TEXT-065. "Đã upload &1 dòng dữ liệu tạm thời (&2 dòng mới, &3 dòng cập nhật).
    REPLACE '&1' IN lv_msg WITH |{ lv_total_changed }|.
    REPLACE '&2' IN lv_msg WITH |{ lv_new_count }|.
    REPLACE '&3' IN lv_msg WITH |{ lv_changed_count }|.
    MESSAGE lv_msg TYPE 'S'.
  ELSE.
  ENDIF.
* Reorder 6 field thủ công xuống cuối ALV (bản đảm bảo)
  PERFORM build_fieldcat_all.

  DATA: lt_audit_fields TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_other_fields TYPE STANDARD TABLE OF string,
        lt_final_fields TYPE STANDARD TABLE OF string.

  " Danh sách 6 field thủ công chuẩn
  APPEND 'ERDAT' TO lt_audit_fields.
  APPEND 'ERTIM' TO lt_audit_fields.
  APPEND 'ERNAM' TO lt_audit_fields.
  APPEND 'AEDAT' TO lt_audit_fields.
  APPEND 'AETIM' TO lt_audit_fields.
  APPEND 'AENAM' TO lt_audit_fields.

  " Tách field thường và field audit
  LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
    DATA(lv_name) = <fs_fc>-fieldname.
    READ TABLE lt_audit_fields WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CONTINUE. " sẽ append sau
    ELSE.
      APPEND lv_name TO lt_other_fields.
    ENDIF.
  ENDLOOP.

  " Gộp lại: thường trước, audit sau
  APPEND LINES OF lt_audit_fields TO lt_other_fields.
  lt_final_fields = lt_other_fields.

  " Cập nhật lại col_pos theo thứ tự chuẩn
  DATA(lv_pos) = 1.
  LOOP AT lt_final_fields INTO DATA(lv_field).
    READ TABLE gt_fieldcat ASSIGNING <fs_fc> WITH KEY fieldname = lv_field.
    IF sy-subrc = 0.
      <fs_fc>-col_pos = lv_pos.
      lv_pos += 1.
    ENDIF.
  ENDLOOP.

  " Cập nhật ALV hiển thị theo fieldcatalog mới

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_frontend_fieldcatalog( gt_fieldcat ).
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root INTO DATA(lx_err).
        MESSAGE lx_err->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDIF.

  IF lv_new_count > 0.
    gv_add_mode = abap_true.
  ENDIF.

  PERFORM apply_editability_and_push.


ENDFORM.
FORM download_excel_xlsx USING ir_data TYPE REF TO data.

  FIELD-SYMBOLS: <lt_original> TYPE STANDARD TABLE,
                 <ls_original> TYPE any,
                 <lt_no_style> TYPE STANDARD TABLE,
                 <ls_no_style> TYPE any.

  DATA: lr_data_no_style TYPE REF TO data,
        lv_filename      TYPE string,
        lv_path          TYPE string,
        lv_fullpath      TYPE string,
        lv_action        TYPE i,
        lv_xstring       TYPE xstring,
        lt_bin           TYPE solix_tab,
        lt_cols          TYPE if_fdt_doc_spreadsheet=>t_column.
  "  Hộp thoại lưu file
  cl_gui_frontend_services=>file_save_dialog(
    EXPORTING
      default_extension = 'xlsx'
      default_file_name  = |DATA_{ p_tab }_{ sy-datum }_{ sy-uzeit }.xlsx|
*      file_filter        = 'Excel Files (*.xlsx) | *.xlsx'
       file_filter       = CONV string( TEXT-201 )
  CHANGING
    filename     = lv_filename
    path         = lv_path
    fullpath     = lv_fullpath
    user_action  = lv_action
  EXCEPTIONS
    OTHERS = 1 ).
  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
*    MESSAGE 'Export bị hủy' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-067 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  " Loại bỏ style
  ASSIGN ir_data->* TO <lt_original>.

  IF <lt_original> IS NOT ASSIGNED.
*    MESSAGE 'Dữ liệu gốc không được assign' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-068 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM create_dynamic_itab_no_style USING p_tab CHANGING lr_data_no_style.
  ASSIGN lr_data_no_style->* TO <lt_no_style>.

  IF <lt_no_style> IS NOT ASSIGNED.
*    MESSAGE 'Không tạo được cấu trúc dữ liệu cho export' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-069 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  LOOP AT <lt_original> ASSIGNING <ls_original>.
    APPEND INITIAL LINE TO <lt_no_style> ASSIGNING <ls_no_style>.
    MOVE-CORRESPONDING <ls_original> TO <ls_no_style>.
  ENDLOOP.

  " Ẩn cột MANDT nếu có

  DATA: lo_anydesc  TYPE REF TO cl_abap_typedescr,
        lo_tabdesc  TYPE REF TO cl_abap_tabledescr,
        lo_struct   TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_filtered TYPE REF TO data.
  FIELD-SYMBOLS: <lt_filtered> TYPE STANDARD TABLE,
                 <ls_filtered> TYPE any.
  lo_anydesc = cl_abap_typedescr=>describe_by_data_ref( REF #( <lt_no_style> ) ).
  lo_tabdesc ?= lo_anydesc.
  lo_struct  ?= lo_tabdesc->get_table_line_type( ).
  lt_comp    = lo_struct->get_components( ).
  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'MANDT' OR ls_comp-name = 'mandt'.
      DELETE lt_comp INDEX sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF sy-subrc = 0.
    lo_newline = cl_abap_structdescr=>create( lt_comp ).
    lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
    CREATE DATA lr_filtered TYPE HANDLE lo_newtab.
    ASSIGN lr_filtered->* TO <lt_filtered>.
    LOOP AT <lt_no_style> ASSIGNING <ls_no_style>.
      APPEND INITIAL LINE TO <lt_filtered> ASSIGNING <ls_filtered>.
      MOVE-CORRESPONDING <ls_no_style> TO <ls_filtered>.
    ENDLOOP.
    lr_data_no_style = lr_filtered.
  ENDIF.
  "Nếu bảng có 6 field thủ công thì đẩy chúng xuống cuối

  DATA: lt_audit_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_keep        TYPE STANDARD TABLE OF string,
        lt_remove      TYPE STANDARD TABLE OF string,
        lt_ddic        TYPE TABLE OF dfies,
        ls_ddic        TYPE dfies.

  APPEND 'ERDAT' TO lt_audit_order.
  APPEND 'ERTIM' TO lt_audit_order.
  APPEND 'ERNAM' TO lt_audit_order.
  APPEND 'AEDAT' TO lt_audit_order.
  APPEND 'AETIM' TO lt_audit_order.
  APPEND 'AENAM' TO lt_audit_order.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic
    EXCEPTIONS
      OTHERS    = 1.
  IF sy-subrc <> 0.

    lv_msg = TEXT-202.
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  DATA: lt_normal TYPE STANDARD TABLE OF string,
        lt_audit  TYPE STANDARD TABLE OF string.

  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.

    READ TABLE lt_audit_order WITH KEY table_line = ls_ddic-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND ls_ddic-fieldname TO lt_audit.
    ELSE.
      APPEND ls_ddic-fieldname TO lt_normal.
    ENDIF.
  ENDLOOP.

  IF lt_audit IS NOT INITIAL.
    DATA lt_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    APPEND LINES OF lt_normal TO lt_order.
    APPEND LINES OF lt_audit  TO lt_order.
    PERFORM reorder_components_ref USING lr_data_no_style lt_order.
  ENDIF.
  " Xuất Excel
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
        EXPORTING
          columns       = lt_cols
          itab          = lr_data_no_style
          iv_call_type  = 2
          iv_sheet_name = 'DATA'
        RECEIVING
          xdocument     = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.
  " Ghi ra frontend
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).
  cl_gui_frontend_services=>gui_download(
    EXPORTING
      filename     = lv_fullpath
      filetype     = 'BIN'
      bin_filesize = xstrlen( lv_xstring )
    CHANGING
      data_tab     = lt_bin
    EXCEPTIONS
      OTHERS = 1 ).
  IF sy-subrc = 0.
*    MESSAGE |Xuất dữ liệu thành công: { lv_filename }| TYPE 'S'.
    lv_msg = TEXT-070.
    REPLACE '&1' IN lv_msg WITH lv_filename.
    MESSAGE lv_msg TYPE 'S'.
  ELSE.
*    MESSAGE 'Lỗi khi ghi file dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-071 TYPE 'S' DISPLAY LIKE 'E'.

  ENDIF.
ENDFORM.

* FORM download_template_xlsx - Export Excel Template
*FORM download_template_xlsx.
*
*  FIELD-SYMBOLS: <lt_template> TYPE STANDARD TABLE.
*
*  "=== 1) Hộp thoại lưu file ===
*  DATA: lv_filename TYPE string,
*        lv_path     TYPE string,
*        lv_fullpath TYPE string,
*        lv_action   TYPE i.
*
*  cl_gui_frontend_services=>file_save_dialog(
*    EXPORTING
*      default_extension = 'xlsx'
*      default_file_name = |TEMPLATE_{ p_tab }.xlsx|
**      file_filter       = 'Excel Files (*.xlsx) | *.xlsx'
*       file_filter = CONV string( TEXT-201 )
*    CHANGING
*      filename          = lv_filename
*      path              = lv_path
*      fullpath          = lv_fullpath
*      user_action       = lv_action
*    EXCEPTIONS
*      OTHERS            = 1 ).
*
*  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
**    MESSAGE 'Download template bị hủy' TYPE 'I'.
*    MESSAGE TEXT-072 TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  " Tạo dòng mẫu dựa trên cấu trúc bảng ===
*  DATA: lr_template TYPE REF TO data,
*        lv_xstring  TYPE xstring,
*        lt_cols     TYPE if_fdt_doc_spreadsheet=>t_column.
*
*  PERFORM create_dynamic_itab USING p_tab
*    CHANGING lr_template.
*
*  " Loại bỏ 6 field thủ công nếu không có trong DDIC ===
*  DATA: lt_ddic   TYPE TABLE OF dfies,
*        lt_keep   TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
*        lt_remove TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
*        ls_ddic   TYPE dfies.
*
*  CALL FUNCTION 'DDIF_FIELDINFO_GET'
*    EXPORTING
*      tabname   = p_tab
*    TABLES
*      dfies_tab = lt_ddic
*    EXCEPTIONS
*      OTHERS    = 1.
*  IF sy-subrc <> 0.
*    lv_msg = TEXT-202.
*    REPLACE '&1' IN lv_msg WITH p_tab.
*    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
*    APPEND ls_ddic-fieldname TO lt_keep.
*  ENDLOOP.
*
*  " Tạo danh sách audit WITHOUT VALUE constructor ---
*  DATA lt_audit TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
*  APPEND 'ERDAT' TO lt_audit.
*  APPEND 'ERTIM' TO lt_audit.
*  APPEND 'ERNAM' TO lt_audit.
*  APPEND 'AEDAT' TO lt_audit.
*  APPEND 'AETIM' TO lt_audit.
*  APPEND 'AENAM' TO lt_audit.
*
*  " Nếu field audit KHÔNG có trong DDIC thì đưa vào lt_remove ---
*  DATA lv_field TYPE string.
*  LOOP AT lt_audit INTO lv_field.
*    " Kiểm tra membership theo kiểu classic
*    READ TABLE lt_keep WITH KEY table_line = lv_field TRANSPORTING NO FIELDS.
*    IF sy-subrc <> 0.
*      APPEND lv_field TO lt_remove.
*    ENDIF.
*  ENDLOOP.
*  " Luôn ẩn field MANDT nếu bảng có MANDT ---
*  READ TABLE lt_ddic WITH KEY fieldname = 'MANDT' TRANSPORTING NO FIELDS.
*  IF sy-subrc = 0.
*    APPEND 'MANDT' TO lt_remove.
*  ENDIF.
*
*  IF lt_remove IS NOT INITIAL.
*    PERFORM remove_components_from_ref USING lr_template lt_remove.
*  ENDIF.
*  " Nếu bảng có các field audit thì đẩy chúng xuống cuối ===
*  DATA: lt_audit_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
*        lt_keep_order  TYPE STANDARD TABLE OF dfies,
*        lt_normal      TYPE TABLE OF dfies,
*        lt_audit2      TYPE TABLE OF dfies.  " ⬅️ đổi tên khác
*
*  APPEND 'ERDAT' TO lt_audit_order.
*  APPEND 'ERTIM' TO lt_audit_order.
*  APPEND 'ERNAM' TO lt_audit_order.
*  APPEND 'AEDAT' TO lt_audit_order.
*  APPEND 'AETIM' TO lt_audit_order.
*  APPEND 'AENAM' TO lt_audit_order.
*
*  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
*    READ TABLE lt_audit_order WITH KEY table_line = ls_ddic-fieldname TRANSPORTING NO FIELDS.
*    IF sy-subrc = 0.
*      APPEND ls_ddic TO lt_audit2.
*    ELSE.
*      APPEND ls_ddic TO lt_normal.
*    ENDIF.
*  ENDLOOP.
*
*  IF lt_audit2 IS NOT INITIAL.
*    " Reorder cấu trúc template: normal trước, audit sau
*    DATA: lt_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
*    LOOP AT lt_normal INTO ls_ddic.
*      APPEND ls_ddic-fieldname TO lt_order.
*    ENDLOOP.
*    LOOP AT lt_audit2 INTO ls_ddic.
*      APPEND ls_ddic-fieldname TO lt_order.
*    ENDLOOP.
*    PERFORM reorder_components_ref USING lr_template lt_order.
*  ENDIF.
*
*
*  " Tạo 1 dòng trống để có cấu trúc export ===
*  ASSIGN lr_template->* TO <lt_template>.
*  IF <lt_template> IS ASSIGNED.
*    CLEAR <lt_template>.
*    APPEND INITIAL LINE TO <lt_template>.
*  ELSE.
**    MESSAGE 'Không tạo được template từ bảng dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
*    MESSAGE TEXT-073 TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  " Xuất nội dung ra file Excel ===
*  TRY.
*      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
*        EXPORTING
*          itab         = lr_template
*          iv_call_type = 2
*          iv_sheet_name = 'TEMPLATE'
*        RECEIVING
*          xdocument = lv_xstring ).
*    CATCH cx_root INTO DATA(lx).
*      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
*      RETURN.
*  ENDTRY.
*
*  "Ghi file ra frontend
*  DATA lt_bin TYPE solix_tab.
*  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).
*
*  cl_gui_frontend_services=>gui_download(
*    EXPORTING
*      filename     = lv_fullpath
*      filetype     = 'BIN'
*      bin_filesize = xstrlen( lv_xstring )
*    CHANGING
*      data_tab     = lt_bin
*    EXCEPTIONS
*      OTHERS       = 1 ).
*
*  IF sy-subrc = 0.
**    MESSAGE |Tải template thành công: { lv_filename }| TYPE 'S'.
*    lv_msg = TEXT-074. "Tải template thành công: &1
*    REPLACE '&1' IN lv_msg WITH lv_filename.
*    MESSAGE lv_msg TYPE 'S'.
*  ELSE.
**    MESSAGE 'Lỗi khi ghi file template' TYPE 'S' DISPLAY LIKE 'E'.
*    MESSAGE TEXT-075 TYPE 'S' DISPLAY LIKE 'E'.
*  ENDIF.
*
*ENDFORM.
FORM download_template_xlsx.
  FIELD-SYMBOLS: <lt_template> TYPE STANDARD TABLE,
                 <ls_template> TYPE any.

  DATA: lr_template_no_style TYPE REF TO data,
        lv_filename          TYPE string,
        lv_path              TYPE string,
        lv_fullpath          TYPE string,
        lv_action            TYPE i,
        lv_xstring           TYPE xstring,
        lt_bin               TYPE solix_tab,
        lt_cols              TYPE if_fdt_doc_spreadsheet=>t_column.

  " 1. Hộp thoại lưu file
  cl_gui_frontend_services=>file_save_dialog(
    EXPORTING
      default_extension = 'xlsx'
      default_file_name = |TEMPLATE_{ p_tab }.xlsx|
      file_filter       = CONV string( TEXT-201 )
    CHANGING
      filename          = lv_filename
      path              = lv_path
      fullpath          = lv_fullpath
      user_action       = lv_action
    EXCEPTIONS
      OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE TEXT-072 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2. Tạo cấu trúc No Style
  PERFORM create_dynamic_itab_no_style USING p_tab CHANGING lr_template_no_style.
  ASSIGN lr_template_no_style->* TO <lt_template>.

  IF <lt_template> IS NOT ASSIGNED.
    MESSAGE TEXT-073 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 3. Loại bỏ cột MANDT bằng RTTS
  DATA: lo_anydesc  TYPE REF TO cl_abap_typedescr,
        lo_tabdesc  TYPE REF TO cl_abap_tabledescr,
        lo_struct   TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_filtered TYPE REF TO data.

  lo_anydesc = cl_abap_typedescr=>describe_by_data_ref( REF #( <lt_template> ) ).
  lo_tabdesc ?= lo_anydesc.
  lo_struct  ?= lo_tabdesc->get_table_line_type( ).
  lt_comp    = lo_struct->get_components( ).

  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'MANDT' OR ls_comp-name = 'mandt'.
      DELETE lt_comp INDEX sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF sy-subrc = 0.
    lo_newline = cl_abap_structdescr=>create( lt_comp ).
    lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
    CREATE DATA lr_filtered TYPE HANDLE lo_newtab.
    lr_template_no_style = lr_filtered.
    ASSIGN lr_template_no_style->* TO <lt_template>.
  ENDIF.

  " 4. Sắp xếp 6 field Audit xuống cuối
  DATA: lt_audit_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_ddic        TYPE TABLE OF dfies,
        ls_ddic        TYPE dfies,
        lt_normal      TYPE STANDARD TABLE OF string,
        lt_audit       TYPE STANDARD TABLE OF string.

  APPEND 'ERDAT' TO lt_audit_order.
  APPEND 'ERTIM' TO lt_audit_order.
  APPEND 'ERNAM' TO lt_audit_order.
  APPEND 'AEDAT' TO lt_audit_order.
  APPEND 'AETIM' TO lt_audit_order.
  APPEND 'AENAM' TO lt_audit_order.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic
    EXCEPTIONS
      OTHERS    = 1.

  IF sy-subrc = 0.
    LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
      READ TABLE lt_audit_order WITH KEY table_line = ls_ddic-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        APPEND ls_ddic-fieldname TO lt_audit.
      ELSE.
        APPEND ls_ddic-fieldname TO lt_normal.
      ENDIF.
    ENDLOOP.

    IF lt_audit IS NOT INITIAL.
      DATA lt_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
      APPEND LINES OF lt_normal TO lt_order.
      APPEND LINES OF lt_audit  TO lt_order.
      PERFORM reorder_components_ref USING lr_template_no_style lt_order.
      ASSIGN lr_template_no_style->* TO <lt_template>.
    ENDIF.
  ENDIF.

  " 5. Tạo 1 dòng trống cho Template
  APPEND INITIAL LINE TO <lt_template>.

  " 6. Xuất nội dung ra file Excel
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
        EXPORTING
          itab         = lr_template_no_style
          iv_call_type = 2
          iv_sheet_name = 'TEMPLATE'
        RECEIVING
          xdocument = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  " 7. Ghi file ra máy tính người dùng
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).
  cl_gui_frontend_services=>gui_download(
    EXPORTING
      filename     = lv_fullpath
      filetype     = 'BIN'
      bin_filesize = xstrlen( lv_xstring )
    CHANGING
      data_tab     = lt_bin
    EXCEPTIONS
      OTHERS = 1 ).

  IF sy-subrc = 0.
    lv_msg = TEXT-074. "Tải template thành công: &1
    REPLACE '&1' IN lv_msg WITH lv_filename.
    MESSAGE lv_msg TYPE 'S'.
  ELSE.
    MESSAGE TEXT-075 TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.
ENDFORM.

* Xóa component khỏi data ref động
FORM remove_components_from_ref USING ir_table TYPE REF TO data
                                      it_fields TYPE STANDARD TABLE.

  DATA: lo_table   TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF ir_table IS INITIAL.
    RETURN.
  ENDIF.

  lo_table ?= cl_abap_tabledescr=>describe_by_data_ref( ir_table ).
  lo_line  ?= lo_table->get_table_line_type( ).
  lt_comp   = lo_line->get_components( ).

  LOOP AT it_fields ASSIGNING FIELD-SYMBOL(<f>).
    DELETE lt_comp WHERE name = <f>.
  ENDLOOP.

  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
  CREATE DATA lr_new TYPE HANDLE lo_newtab.

  ASSIGN ir_table->* TO <lt_old>.
  ASSIGN lr_new->*  TO <lt_new>.
  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  ir_table = lr_new.

ENDFORM.

* Sắp xếp lại thứ tự component trong data ref động
FORM reorder_components_ref USING ir_table TYPE REF TO data
                                  it_order TYPE STANDARD TABLE.

  DATA: lo_table   TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lt_newcomp TYPE abap_component_tab,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF ir_table IS INITIAL OR it_order IS INITIAL.
    RETURN.
  ENDIF.

  lo_table ?= cl_abap_tabledescr=>describe_by_data_ref( ir_table ).
  lo_line  ?= lo_table->get_table_line_type( ).
  lt_comp  = lo_line->get_components( ).

  LOOP AT it_order ASSIGNING FIELD-SYMBOL(<f_name>).
    READ TABLE lt_comp INTO ls_comp WITH KEY name = <f_name>.
    IF sy-subrc = 0.
      APPEND ls_comp TO lt_newcomp.
    ENDIF.
  ENDLOOP.

  IF lt_newcomp IS INITIAL.
    RETURN.
  ENDIF.

  lo_newline = cl_abap_structdescr=>create( lt_newcomp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
  CREATE DATA lr_new TYPE HANDLE lo_newtab.

  ASSIGN ir_table->* TO <lt_old>.
  ASSIGN lr_new->*  TO <lt_new>.
  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  ir_table = lr_new.

ENDFORM.

*& Form SHOW_UPLOAD_ERROR_LOG

FORM show_upload_error_log USING ut_error_log TYPE STANDARD TABLE.
  DATA: lo_alv_err TYPE REF TO cl_salv_table,
        lo_funcs   TYPE REF TO cl_salv_functions_list,
        lo_cols    TYPE REF TO cl_salv_columns_table,
        lo_col     TYPE REF TO cl_salv_column_table,
        lo_events  TYPE REF TO cl_salv_events_table,
        lo_handler TYPE REF TO lcl_event_handler,
        lo_display TYPE REF TO cl_salv_display_settings.

  TRY.
      "  Tạo ALV
      cl_salv_table=>factory(
        IMPORTING r_salv_table = lo_alv_err
        CHANGING  t_table      = ut_error_log ).

      " Cấu hình Popup
      lo_alv_err->set_screen_popup(
        start_column = 10 end_column = 110
        start_line   = 5  end_line   = 20 ).

      lo_display = lo_alv_err->get_display_settings( ).
      lo_display->set_list_header( 'INVALID DATA LIST (Click row number to view details)' ).
      lo_display->set_striped_pattern( abap_true ).

      lo_funcs = lo_alv_err->get_functions( ).
      lo_funcs->set_all( abap_true ).

      lo_cols = lo_alv_err->get_columns( ).
      lo_cols->set_optimize( abap_true ).

      " Cấu hình cột & HOTSPOT
      TRY.
          " Cột Dòng Excel -> Biến thành Link Click được
          lo_col ?= lo_cols->get_column( 'ROW_ID' ).
          lo_col->set_short_text( 'Excel Row' ).
*          lo_col->set_short_text( TEXT-225 ).
          lo_col->set_cell_type( if_salv_c_cell_type=>hotspot ).

          lo_col ?= lo_cols->get_column( 'COL_NAME' ).
          lo_col->set_short_text( 'Column' ).
*          lo_col->set_short_text( TEXT-226 ).

          lo_col ?= lo_cols->get_column( 'VALUE' ).
          lo_col->set_medium_text( 'Invalid Value' ).
          lo_col->set_long_text( 'Invalid Value' ).
          lo_col->set_short_text( 'Value' ).
*           lo_col->set_medium_text( TEXT-228 ).
*           lo_col->set_long_text( TEXT-228 ).
*           lo_col->set_short_text( TEXT-227 ).

          lo_col ?= lo_cols->get_column( 'MESSAGE' ).
          lo_col->set_medium_text( 'Error Message' ).
          lo_col->set_long_text( 'Error Message' ).
          lo_col->set_short_text( 'Error' ).
*          lo_col->set_medium_text( TEXT-229 ).
*          lo_col->set_long_text( TEXT-229 ).
*          lo_col->set_short_text( TEXT-230 ).
        CATCH cx_salv_not_found.
      ENDTRY.

      " Đăng ký sự kiện Click
      " Truyền dữ liệu vào class tĩnh để tra cứu
      lcl_event_handler=>mt_error_log = ut_error_log.

      " Tạo handler và lắng nghe sự kiện
      CREATE OBJECT lo_handler.
      lo_events = lo_alv_err->get_event( ).
      SET HANDLER lo_handler->on_link_click FOR lo_events.

      "Hiển thị
      lo_alv_err->display( ).

    CATCH cx_salv_msg INTO DATA(lx_msg).
      DATA(lv_txt) = lx_msg->get_text( ).
      MESSAGE lv_txt TYPE 'I' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_AUDIT (classic-syntax, no templates/inline)
*&---------------------------------------------------------------------*

* Cache key fields for current table
FORM ensure_keys USING iv_tab TYPE tabname.
  DATA lv_tab TYPE tabname.
  IF gv_keys_tabname <> iv_tab.
    CLEAR gt_key_fields.
    gv_keys_tabname = iv_tab.
  ENDIF.

  " Upper-case để khớp DDIC
  lv_tab = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  IF gt_key_fields IS INITIAL.
    SELECT fieldname
      FROM dd03l
      INTO TABLE @gt_key_fields
      WHERE tabname  = @lv_tab
        AND as4local = 'A'
        AND keyflag  = 'X'
        AND fieldname <> 'MANDT'.
  ENDIF.

  " Fallback từ fieldcatalog nếu DD03L không trả về
  IF gt_key_fields IS INITIAL AND gt_fieldcat IS NOT INITIAL.
    FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
    LOOP AT gt_fieldcat ASSIGNING <fc>.
      IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
        CONTINUE.
      ENDIF.
      IF <fc>-key = 'X' AND to_upper( <fc>-fieldname ) <> 'MANDT'.
        APPEND <fc>-fieldname TO gt_key_fields.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM ensure_rowcolor_component CHANGING cr_tab TYPE REF TO data.
  DATA: lo_tab     TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lo_any     TYPE REF TO cl_abap_typedescr,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data,
        lr_row     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab  ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp  = lo_line->get_components( ).

  " Đã có ROW_COLOR chưa?
  LOOP AT lt_comp INTO ls_comp WHERE name = 'ROW_COLOR'.
    RETURN.
  ENDLOOP.

  " Thêm ROW_COLOR: LVC_T_SCOL
  lo_any ?= cl_abap_typedescr=>describe_by_name( 'LVC_T_SCOL' ).
  CLEAR ls_comp.
  ls_comp-name = 'ROW_COLOR'.
  ls_comp-type ?= lo_any.
  APPEND ls_comp TO lt_comp.

  " Dựng lại line type
  lo_newline = cl_abap_structdescr=>create( lt_comp ).

  " Dựng lại table type
  lo_newtab  = cl_abap_tabledescr=>create( p_line_type = lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    CREATE DATA lr_row TYPE HANDLE lo_newline.
    ASSIGN lr_row->* TO <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
    APPEND <ls_new> TO <lt_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.

FORM ensure_celltab_component CHANGING cr_tab TYPE REF TO data.
  TYPE-POOLS abap.

  DATA: lo_tab      TYPE REF TO cl_abap_tabledescr,
        lo_line     TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lv_has_cell TYPE abap_bool,
        lv_has_new  TYPE abap_bool,
        lo_cell_any TYPE REF TO cl_abap_typedescr,
        lo_cell_dat TYPE REF TO cl_abap_datadescr,
        lo_bool_dat TYPE REF TO cl_abap_datadescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_new      TYPE REF TO data,
        lr_row      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).

  CLEAR: lv_has_cell, lv_has_new.
  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'CELLTAB'. lv_has_cell = abap_true. ENDIF.
    IF ls_comp-name = 'NEWREC'.  lv_has_new  = abap_true. ENDIF.
  ENDLOOP.

  IF lv_has_cell = abap_true AND lv_has_new = abap_true.
    RETURN. " đã có đủ hai cột kỹ thuật
  ENDIF.

  " Thêm CELLTAB: LVC_T_STYL
  IF lv_has_cell = abap_false.
    lo_cell_any = cl_abap_typedescr=>describe_by_name( 'LVC_T_STYL' ).
    lo_cell_dat ?= lo_cell_any.
    CLEAR ls_comp.
    ls_comp-name = 'CELLTAB'.
    ls_comp-type = lo_cell_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Thêm NEWREC: C(1)
  IF lv_has_new = abap_false.
    lo_bool_dat = cl_abap_elemdescr=>get_c( 1 ).
    CLEAR ls_comp.
    ls_comp-name = 'NEWREC'.
    ls_comp-type = lo_bool_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Tạo lại line type + table type mới
  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  IF <lt_old> IS ASSIGNED AND <lt_new> IS ASSIGNED.
    LOOP AT <lt_old> ASSIGNING <ls_old>.
      CREATE DATA lr_row TYPE HANDLE lo_newline.
      ASSIGN lr_row->* TO <ls_new>.
      MOVE-CORRESPONDING <ls_old> TO <ls_new>.
      APPEND <ls_new> TO <lt_new>.
    ENDLOOP.
    cr_tab = lr_new. " ref mới có CELLTAB + NEWREC
  ENDIF.
ENDFORM.

*=== Helper: escape dấu nháy đơn cho literal SQL
FORM _escape_single_quote USING    iv_in  TYPE string
                          CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH ''''''.
ENDFORM.

* Build dynamic WHERE from key fields (type-aware, with escaping)
FORM make_where_from_key USING    is_str  TYPE any
                                  it_keys TYPE STANDARD TABLE
                         CHANGING ev_where TYPE string
                                  ev_err   TYPE string.

  CLEAR: ev_where, ev_err.
  DATA lv_cond TYPE string.
  FIELD-SYMBOLS: <val>   TYPE any, <fname> TYPE dd03l-fieldname.

  DATA all_empty TYPE abap_bool VALUE abap_true.

  LOOP AT it_keys ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE is_str TO <val>.
    IF sy-subrc = 0 AND <val> IS ASSIGNED AND <val> IS NOT INITIAL.
      all_empty = abap_false.

      "  Phải lấy mô tả kiểu *trong từng vòng lặp*
      DATA(lo_td) = cl_abap_typedescr=>describe_by_data_ref( REF #( <val> ) ).
      DATA(lv_tk) = lo_td->type_kind.

      DATA(lv_piece) = ``.

      "  Bỏ 'N' ra khỏi danh sách số, vì NUMC cần dấu nháy đơn trong SQL động ---
      IF lv_tk = 'I' OR lv_tk = 'P' OR lv_tk = 'F'.
        " Kiểu số thực sự: Không cần nháy đơn
        lv_piece = |{ <fname> } = { <val> }|.
      ELSE.
        " Kiểu chuỗi (C, String) HOẶC NUMC (N), DATS (D), TIMS (T): Cần nháy đơn
        DATA(lv_s) = |{ <val> }|.

        " Nếu giá trị nhập vào là '1' nhưng DB lưu '00001' (NUMC)
        IF lv_tk = 'N'.
          DATA(lv_len_n) = lo_td->length / cl_abap_char_utilities=>charsize.
          " Shift right để bù số 0 nếu cần (tương tự UNPACK)
          DATA lv_numc_fmt TYPE string.
          lv_numc_fmt = lv_s.
          SHIFT lv_numc_fmt RIGHT DELETING TRAILING space.
          OVERLAY lv_numc_fmt WITH '0000000000000000000000000000000000000000'. "Overlay với chuỗi 0 dài
          lv_s = lv_numc_fmt+0(lv_len_n). " Cắt đúng độ dài field
        ENDIF.

        PERFORM _escape_single_quote USING lv_s CHANGING lv_s.
        lv_piece = |{ <fname> } = '{ lv_s }'|.
      ENDIF.

      IF lv_cond IS INITIAL.
        lv_cond = lv_piece.
      ELSE.
        lv_cond = |{ lv_cond } AND { lv_piece }|.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF all_empty = abap_true.
*    ev_err = 'Tất cả trường khóa đều rỗng.'.
    ev_err = TEXT-076.
    RETURN.
  ENDIF.

  IF lv_cond IS INITIAL.
*    ev_err = 'Không tạo được điều kiện khóa.'.
    ev_err = TEXT-077.
  ELSE.
    ev_where = lv_cond.
  ENDIF.

ENDFORM.


* Serialize any structure to JSON (fallback XML) into ZDE_JSON_TXT
FORM to_json USING is_any TYPE any
             CHANGING cv_json TYPE zde_json_txt.
  DATA lv_str TYPE string.
  CLEAR lv_str.
  " Đồng bộ pretty_mode-none để khớp json_to_itab
  TRY.
      lv_str = /ui2/cl_json=>serialize(
                 data        = is_any
                 pretty_name = /ui2/cl_json=>pretty_mode-none ).
    CATCH cx_root.
      TRY.
          CALL TRANSFORMATION id
            SOURCE data = is_any
            RESULT XML lv_str.
        CATCH cx_root.
          lv_str = '<<serialize failed>>'.
      ENDTRY.
  ENDTRY.
  cv_json = lv_str.
ENDFORM.



FORM on_save.
  DATA: lv_mod TYPE i,
        lv_err TYPE string,
        lv_msg TYPE c LENGTH 200.

  DATA: lr_to_save TYPE REF TO data,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lo_tab     TYPE REF TO cl_abap_tabledescr.
  FIELD-SYMBOLS: <lt_to_save> TYPE STANDARD TABLE,
                 <ls_to_save> TYPE any.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.
  DATA: lv_where  TYPE string,
        lv_we     TYPE string,
        lv_is_new TYPE abap_bool.
  DATA: lr_db_struct TYPE REF TO cl_abap_structdescr,
        lr_now_db    TYPE REF TO data,
        lr_old_db    TYPE REF TO data.
  FIELD-SYMBOLS: <ls_db_now> TYPE any,
                 <ls_db_old> TYPE any,
                 <fs_mandt>  TYPE any.
  DATA: lr_old       TYPE REF TO data.
  FIELD-SYMBOLS: <ls_old>    TYPE any.
  DATA: lxsql        TYPE REF TO cx_sy_dynamic_osql_syntax.

  " Biến cho logic mới
  DATA: lv_has_error TYPE abap_bool.
  DATA: ls_stbl TYPE lvc_s_stbl.
  CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  " -----------------------------------------------------------------
  " BƯỚC 1: Đẩy dữ liệu từ màn hình xuống itab
  " -----------------------------------------------------------------
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  " -----------------------------------------------------------------
  " BƯỚC 2: Chuẩn bị dữ liệu
  " -----------------------------------------------------------------
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    MESSAGE TEXT-086 TYPE 'S' DISPLAY LIKE 'E'. " Không có dữ liệu
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING p_tab.
  IF gt_key_fields IS INITIAL.
    MESSAGE TEXT-087 TYPE 'S' DISPLAY LIKE 'E'. " Không tìm thấy key
    RETURN.
  ENDIF.

  " -----------------------------------------------------------------
  " BƯỚC 3: VALIDATE TOÀN BỘ
  " -----------------------------------------------------------------
  PERFORM validate_full_dataset CHANGING lv_has_error.

  " -----------------------------------------------------------------
  " BƯỚC 4: XỬ LÝ KẾT QUẢ VALIDATION
  " -----------------------------------------------------------------
  IF lv_has_error = abap_true.
    " 4a. Có lỗi -> Tô màu đỏ
    PERFORM highlight_error_cells.

    " 4b. Chuyển sang Edit Mode (để sửa)
    gv_dirty        = abap_true.
    gv_add_mode     = abap_true. " Để mở khóa key fields
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
    PERFORM apply_editability_and_push.

    " 4c. Refresh ALV để hiện màu
    IF g_alv_grid IS BOUND.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    ENDIF.

    " 4d. Thông báo và hiển thị popup list lỗi
    MESSAGE TEXT-153 TYPE 'S' DISPLAY LIKE 'E'. " Có dữ liệu lỗi...
    PERFORM show_validation_log.
    RETURN.
  ELSE.
    " 4e. Không lỗi -> Reset màu
    PERFORM highlight_error_cells.
  ENDIF.

  " -----------------------------------------------------------------
  " BƯỚC 5: LOGIC LƯU DB
  " -----------------------------------------------------------------
  REFRESH gt_audit.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( p_tab ).
  CREATE DATA lr_now_db TYPE HANDLE lr_db_struct.
  CREATE DATA lr_old_db TYPE HANDLE lr_db_struct.
  ASSIGN lr_now_db->* TO <ls_db_now>.
  ASSIGN lr_old_db->* TO <ls_db_old>.

  DATA: lt_ins_fp_ok TYPE HASHED TABLE OF ty_fp WITH UNIQUE KEY fp,
        ls_fp        TYPE ty_fp,
        lv_fp        TYPE string.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    " NEWREC?
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_is_new = abap_true.
    ELSE.
      lv_is_new = abap_false.
    ENDIF.

    " WHERE theo khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields CHANGING lv_where lv_we.
    IF lv_where IS INITIAL.
      lv_msg = TEXT-089.
      REPLACE '&1' IN lv_msg WITH lv_we.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    " Lazy init danh sách cần lưu
    IF lo_line IS INITIAL.
      lo_line ?= cl_abap_typedescr=>describe_by_data( <ls_data> ).
      lo_tab  = cl_abap_tabledescr=>create( p_line_type = lo_line ).
      CREATE DATA lr_to_save TYPE HANDLE lo_tab.
      ASSIGN lr_to_save->* TO <lt_to_save>.
    ENDIF.

    " Đọc bản ghi cũ từ DB
    CREATE DATA lr_old LIKE <ls_data>.
    ASSIGN lr_old->* TO <ls_old>.
    CLEAR <ls_old>.

    TRY.
        SELECT SINGLE * FROM (p_tab)
          WHERE (lv_where)
          INTO CORRESPONDING FIELDS OF @<ls_old>.
      CATCH cx_sy_dynamic_osql_syntax INTO lxsql.
        MESSAGE lxsql->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
        CLEAR <ls_old>.
        sy-subrc = 4.
    ENDTRY.

    IF lv_is_new = abap_true.
      " Insert logic...
      " Set Created*
      FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO <erdat>.
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO <ertim>.
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO <ernam>.
      IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.
      "Ðóng gói
      DATA(ls_a_i) = VALUE ty_audit(
        tabname = p_tab
        action  = 'INSERT'
        uname   = sy-uname
        udate   = sy-datum
        utime   = sy-uzeit ).
      PERFORM to_json USING <ls_data> CHANGING ls_a_i-after_json.
      TRY.
          ls_a_i-logid = cl_system_uuid=>create_uuid_c32_static( ).
        CATCH cx_uuid_error.
          CLEAR ls_a_i-logid.
      ENDTRY.
      "Chuẩn bị lưu
      APPEND ls_a_i TO gt_audit.
      APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
      MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
      PERFORM log_audit_action USING p_tab 'C' <ls_data>.
      CLEAR lv_fp.
      "Ðánh dấu thành công
      PERFORM build_key_fingerprint USING <ls_data> gt_key_fields CHANGING lv_fp.
      IF lv_fp IS NOT INITIAL.
        ls_fp-fp = lv_fp.
        INSERT ls_fp INTO TABLE lt_ins_fp_ok.
      ENDIF.

    ELSE.
      " Update logic...
      CLEAR: <ls_db_now>, <ls_db_old>.
      MOVE-CORRESPONDING <ls_data> TO <ls_db_now>.
      MOVE-CORRESPONDING <ls_old>  TO <ls_db_old>.
      ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_db_now> TO <fs_mandt>.
      IF sy-subrc = 0 AND <fs_mandt> IS ASSIGNED.
        <fs_mandt> = sy-mandt.
      ENDIF.

      IF <ls_db_old> <> <ls_db_now>.
        FIELD-SYMBOLS: <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any.
        ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO <aedat>.
        ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO <aetim>.
        ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO <aenam>.
        IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
        IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
        IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.

        DATA(ls_a_u) = VALUE ty_audit(
          tabname = p_tab
          action  = 'UPDATE'
          uname   = sy-uname
          udate   = sy-datum
          utime   = sy-uzeit ).
        PERFORM to_json USING <ls_old>  CHANGING ls_a_u-before_json.
        PERFORM to_json USING <ls_data> CHANGING ls_a_u-after_json.
        TRY.
            ls_a_u-logid = cl_system_uuid=>create_uuid_c32_static( ).
          CATCH cx_uuid_error.
            CLEAR ls_a_u-logid.
        ENDTRY.
        APPEND ls_a_u TO gt_audit.
        APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
        MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
        PERFORM log_audit_action USING p_tab 'U' <ls_data>.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF <lt_to_save> IS NOT ASSIGNED OR <lt_to_save> IS INITIAL.
    MESSAGE TEXT-092 TYPE 'S' DISPLAY LIKE 'E'. "No data changes to save
    RETURN.
  ENDIF.

  " 5) Lưu DB
  PERFORM save_data USING p_tab
                    CHANGING lr_to_save
                             lv_mod
                             lv_err.

  IF lv_err IS NOT INITIAL.
    ROLLBACK WORK.
    gv_dirty        = abap_true.
    gv_add_mode     = abap_false.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
      TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
    ENDIF.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 6) Ghi audit
  TYPES: BEGIN OF ty_audit_db,
           mandt       TYPE mandt,
           logid       TYPE char32,
           uname       TYPE syuname,
           udate       TYPE sydatum,
           utime       TYPE syuzeit,
           tabname     TYPE tabname,
           action      TYPE char10,
           before_json TYPE zde_json_txt,
           after_json  TYPE zde_json_txt,
         END OF ty_audit_db.
  DATA wa_log TYPE ty_audit_db.
  LOOP AT gt_audit ASSIGNING FIELD-SYMBOL(<a>).
    CLEAR wa_log.
    MOVE-CORRESPONDING <a> TO wa_log.
    wa_log-mandt = sy-mandt.
    INSERT zaudit_log FROM wa_log.
  ENDLOOP.

  " 7) Commit + clear NEWREC cho những dòng insert ok
  COMMIT WORK AND WAIT.
  gv_in_upload = abap_false.
  DATA: lv_ins_cnt TYPE i,
        lv_upd_cnt TYPE i,
        lv_del_cnt TYPE i,
        lt_changes TYPE zty_change_tab.

  lv_ins_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT acc = acc + 1 ).
  lv_upd_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT acc = acc + 1 ).
  lv_del_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'DELETE' ) NEXT acc = acc + 1 ).

  PERFORM notify_save_smtp
    USING    p_tab
             lv_ins_cnt
             lv_upd_cnt
             lv_del_cnt
    CHANGING lt_changes.

  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS ASSIGNED AND lt_ins_fp_ok IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        CLEAR lv_fp.
        PERFORM build_key_fingerprint USING <ls_data> gt_key_fields CHANGING lv_fp.
        IF lv_fp IS NOT INITIAL AND line_exists( lt_ins_fp_ok[ fp = lv_fp ] ).
          CLEAR <newrec>.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  CLEAR gt_changed_existing_keys.

  PERFORM resort_and_refresh_alv.
  " 7.1) Đồng bộ bản gốc
  FIELD-SYMBOLS: <lt_cur> TYPE STANDARD TABLE,
                 <lt_ori> TYPE STANDARD TABLE.

  ASSIGN gr_data->* TO <lt_cur>.
  IF <lt_cur> IS ASSIGNED.
    CREATE DATA gr_data_original LIKE <lt_cur>.
    ASSIGN gr_data_original->* TO <lt_ori>.
    IF <lt_ori> IS ASSIGNED.
      <lt_ori> = <lt_cur>.
    ENDIF.
  ENDIF.

  " 8) Về View (Happy Path)
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  PERFORM unlock_current_table USING p_tab.
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

  DATA(lv_ins) = REDUCE i( INIT x = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT x = x + 1 ).
  DATA(lv_upd) = REDUCE i( INIT y = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT y = y + 1 ).
  DATA(lv_cnt) = lines( <lt_to_save> ).

  lv_msg = TEXT-093.
  REPLACE '&1' IN lv_msg WITH |{ lv_cnt }|.
  REPLACE '&2' IN lv_msg WITH |{ lv_ins }|.
  REPLACE '&3' IN lv_msg WITH |{ lv_upd }|.
  MESSAGE lv_msg TYPE 'S'.
ENDFORM.


*--------- delete ----------------------------
FORM delete_selected USING    iv_tab TYPE tabname
                     CHANGING ev_msg TYPE c
                              ev_err TYPE c.

  CLEAR: ev_msg, ev_err.

  " Ghi nhớ trạng thái để restore
  DATA lv_keep_edit TYPE abap_bool.
  IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
    lv_keep_edit = abap_true.
  ELSE.
    lv_keep_edit = abap_false.
  ENDIF.

  FIELD-SYMBOLS: <tab> TYPE STANDARD TABLE, <wa> TYPE any.
  ASSIGN gr_data->* TO <tab>.
  IF <tab> IS NOT ASSIGNED OR <tab> IS INITIAL.
*    ev_err = 'Không có dữ liệu để xóa.'.
    ev_err = TEXT-094.
    RETURN.
  ENDIF.

  " Lấy selection hoặc dòng hiện tại
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_sel_idx TYPE lvc_s_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col.
  CLEAR lt_sel_idx.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index IS INITIAL.
*      ev_err = 'Vui lòng chọn hoặc đặt con trỏ vào dòng cần xóa.'.
      ev_err = TEXT-095.
      RETURN.
    ENDIF.
    ls_sel_idx-index = ls_rowid-index.
    APPEND ls_sel_idx TO lt_sel_idx.
  ENDIF.

  " Đảo giảm dần để xóa không lệch
  SORT lt_sel_idx BY index DESCENDING.

  " Đảm bảo có key trong DDIC đối với xóa DB
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
*    ev_err = 'Bảng không có khóa trong DDIC — không thể xóa.'.
    ev_err = TEXT-096.
    RETURN.
  ENDIF.

  " Buffer audit
  REFRESH gt_audit.

  " Biến thống kê
  DATA: lv_deleted        TYPE i VALUE 0,  " xóa DB
        lv_newrec_deleted TYPE i VALUE 0.  " xóa chỉ trên lưới

  " Xử lý theo từng index
  FIELD-SYMBOLS: <newrec> TYPE any,
                 <comp>   TYPE any.
  DATA: lv_where  TYPE string,
        lv_we     TYPE string,
        lv_exists TYPE abap_bool.

  LOOP AT lt_sel_idx INTO ls_sel_idx.
    READ TABLE <tab> ASSIGNING <wa> INDEX ls_sel_idx-index.
    IF sy-subrc <> 0 OR <wa> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    " 1) NEWREC => xóa khỏi lưới
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <wa> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      DELETE <tab> INDEX ls_sel_idx-index.
      lv_newrec_deleted = lv_newrec_deleted + 1.
      CONTINUE.
    ENDIF.

    " 2) Dòng cũ => kiểm tra key đủ chưa
    DATA any_empty TYPE abap_bool VALUE abap_false.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kfld>).
      ASSIGN COMPONENT <kfld> OF STRUCTURE <wa> TO <comp>.
      IF sy-subrc = 0 AND <comp> IS INITIAL.
        any_empty = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF any_empty = abap_true.
      " không đủ khóa -> xóa khỏi lưới (không xóa DB)
      DELETE <tab> INDEX ls_sel_idx-index.
      CONTINUE.
    ENDIF.

    " Build WHERE từ khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <wa> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
*      ev_err = 'Không xây được điều kiện khóa để xóa.'.
      ev_err = TEXT-097.
      EXIT.
    ENDIF.

    " Tồn tại DB?
    CLEAR lv_exists.
    TRY.
        SELECT SINGLE @abap_true FROM (iv_tab) WHERE (lv_where) INTO @lv_exists.
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax1).
        ev_err = lx_syntax1->get_text( ).
        EXIT.
    ENDTRY.

    IF ev_err IS NOT INITIAL. EXIT. ENDIF.

    IF lv_exists = abap_true.
      " Lấy bản cũ để audit (CORRESPONDING để tránh thiếu field kỹ thuật)
      DATA lr_old TYPE REF TO data.
      CREATE DATA lr_old LIKE <wa>.
      FIELD-SYMBOLS <wa_old> TYPE any.
      ASSIGN lr_old->* TO <wa_old>.
      CLEAR <wa_old>.

      TRY.
          SELECT SINGLE * FROM (iv_tab) WHERE (lv_where)
            INTO CORRESPONDING FIELDS OF @<wa_old>.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax2).
          ev_err = lx_syntax2->get_text( ).
          EXIT.
      ENDTRY.
      IF ev_err IS NOT INITIAL. EXIT. ENDIF.
      IF sy-subrc <> 0. <wa_old> = <wa>. ENDIF.

      " Xóa DB
      TRY.
          DELETE FROM (iv_tab) WHERE (lv_where).
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax3).
          ev_err = lx_syntax3->get_text( ).
          EXIT.
      ENDTRY.
      IF sy-subrc <> 0.
*        ev_err = 'Xóa DB thất bại cho 1 dòng; dừng lại.'.
        ev_err = TEXT-099.
        EXIT.
      ENDIF.

      DATA lv_del_err TYPE string.
      PERFORM delete_audit_log USING iv_tab <wa_old> CHANGING lv_del_err.  " Dùng <wa_old> hoặc <wa> (snapshot cũ)
      IF lv_del_err IS NOT INITIAL.
        ev_err = lv_del_err.
        EXIT.  " Hoặc ROLLBACK WORK nếu muốn rollback delete DB
      ENDIF.

      " Xóa trên lưới + audit
      DELETE <tab> INDEX ls_sel_idx-index.

      DATA ls_a TYPE ty_audit.
      CLEAR ls_a.
      ls_a-tabname = iv_tab.
      ls_a-action  = 'DELETE'.
      ls_a-uname   = sy-uname.
      ls_a-udate   = sy-datum.
      ls_a-utime   = sy-uzeit.
      PERFORM to_json USING <wa_old> CHANGING ls_a-before_json.
      TRY.
          ls_a-logid = cl_system_uuid=>create_uuid_c32_static( ).
        CATCH cx_uuid_error.
          CLEAR ls_a-logid.
      ENDTRY.
      APPEND ls_a TO gt_audit.

      lv_deleted = lv_deleted + 1.

    ELSE.
      " Không còn DB -> xóa khỏi lưới
      DELETE <tab> INDEX ls_sel_idx-index.
    ENDIF.
  ENDLOOP.

  IF ev_err IS NOT INITIAL.
    ROLLBACK WORK.
    RETURN.
  ENDIF.

  " Ghi audit vào bảng log (nếu có)
  IF gt_audit IS NOT INITIAL.
    TYPES: BEGIN OF ty_audit_db,
             mandt       TYPE mandt,
             logid       TYPE char32,
             uname       TYPE syuname,
             udate       TYPE sydatum,
             utime       TYPE syuzeit,
             tabname     TYPE tabname,
             action      TYPE char10,
             before_json TYPE zde_json_txt,
             after_json  TYPE zde_json_txt,
           END OF ty_audit_db.
    DATA wa_log TYPE ty_audit_db.
    DATA lv_audit_tab TYPE tabname VALUE 'ZAUDIT_LOG'.

    FIELD-SYMBOLS <a> TYPE ty_audit.
    LOOP AT gt_audit ASSIGNING <a>.
      CLEAR wa_log.
      wa_log-mandt       = sy-mandt.
      wa_log-logid       = <a>-logid.
      wa_log-uname       = <a>-uname.
      wa_log-udate       = <a>-udate.
      wa_log-utime       = <a>-utime.
      wa_log-tabname     = <a>-tabname.
      wa_log-action      = <a>-action.
      wa_log-before_json = <a>-before_json.
      INSERT (lv_audit_tab) FROM wa_log.
    ENDLOOP.
  ENDIF.

  " Gửi mail thông báo DELETE (nếu có bản ghi bị xóa)
  IF lv_deleted > 0 AND gt_audit IS NOT INITIAL.
    DATA lt_dummy TYPE zty_change_tab.
    PERFORM notify_delete_smtp
      USING    iv_tab
      CHANGING lt_dummy.
  ENDIF.


  " Cập nhật trạng thái chung
  DATA lv_still_has_newrec TYPE abap_bool VALUE abap_false.
  LOOP AT <tab> ASSIGNING <wa>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <wa> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_still_has_newrec = abap_true.
      EXIT.
    ENDIF.
  ENDLOOP.

  lv_msg = TEXT-100. "Đã xóa &1 dòng DB và &2 dòng NEWREC.
  REPLACE '&1' IN lv_msg WITH |{ lv_deleted }|.
  REPLACE '&2' IN lv_msg WITH |{ lv_newrec_deleted }|.
  ev_msg = lv_msg.


  gv_dirty    = abap_false. "Dữ liệu ở database và màn hình khớp nên vẫn giữ false
  gv_add_mode = COND #( WHEN lv_still_has_newrec = abap_true THEN abap_true ELSE abap_false ).
  IF lv_keep_edit = abap_true.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
  ELSE.
    gv_edit_md      = abap_false.
    gv_toolbar_mode = 'D'.
  ENDIF.

  " Áp lại style (xám khóa, audit…), rồi caller sẽ refresh
  PERFORM apply_editability_and_push.

  " Nếu còn NEWREC thì focus vào key
  IF lv_still_has_newrec = abap_true.
    PERFORM focus_key_on_newrec.
  ENDIF.
ENDFORM.




*-------------------------------------------------------------*
* Popup hiển thị log rollback
*-------------------------------------------------------------*
FORM show_audit_log_popup USING iv_tab TYPE tabname.
  DATA: lt_log      TYPE STANDARD TABLE OF zaudit_log,
        ls_log      TYPE zaudit_log,
        ls_selfield TYPE slis_selfield.

  SELECT *
  FROM zaudit_log
  INTO TABLE @lt_log
  WHERE tabname = @iv_tab
  ORDER BY udate DESCENDING, utime DESCENDING.

  IF lt_log IS INITIAL.
*    MESSAGE 'Không có log nào để rollback' TYPE 'I'.
    MESSAGE TEXT-101 TYPE 'I'.
    RETURN.
  ENDIF.
  lv_msg = TEXT-102. "Chọn log rollback cho bảng &1
  REPLACE '&1' IN lv_msg WITH iv_tab.
  CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
    EXPORTING
      i_title               = lv_msg
      i_zebra               = 'X'
      i_tabname             = 'ZAUDIT_LOG'
      i_screen_start_column = 10
      i_screen_start_line   = 5
      i_screen_end_column   = 100
      i_screen_end_line     = 20
    IMPORTING
      es_selfield           = ls_selfield
    TABLES
      t_outtab              = lt_log
    EXCEPTIONS
      OTHERS                = 1.

  IF sy-subrc = 0 AND ls_selfield-tabindex > 0.
    READ TABLE lt_log INDEX ls_selfield-tabindex INTO ls_log.
    IF sy-subrc = 0.
      PERFORM rollback_from_log USING ls_log.
    ENDIF.
  ENDIF.
ENDFORM.

*-------------------------------------------------------------*
* Rollback từ 1 log
*-------------------------------------------------------------*
FORM rollback_from_log USING is_log TYPE zaudit_log.
  DATA: lr_before    TYPE REF TO data,
        lr_curr_data TYPE REF TO data,
        lv_err       TYPE string,
        lv_mod       TYPE i,
        lv_json      TYPE zde_json_txt,
        lv_curr_json TYPE zde_json_txt.

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <ls_curr> TYPE any.

  IF is_log-tabname IS INITIAL.
*    MESSAGE 'Tên bảng không được để trống' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-103 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_json = is_log-before_json.
  IF lv_json IS INITIAL AND is_log-action <> 'INSERT'.
*    MESSAGE 'JSON trước đó rỗng, không thể rollback' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-104 TYPE'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM json_to_itab USING is_log-tabname lv_json CHANGING lr_before.
  ASSIGN lr_before->* TO <lt>.
  IF <lt> IS NOT ASSIGNED.
*    MESSAGE 'Không parse được JSON để rollback' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-105 TYPE'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_dyn_itab USING is_log-tabname CHANGING lr_curr_data.
  IF lr_curr_data IS NOT BOUND.
*    MESSAGE 'Không tạo được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-106 TYPE'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  ASSIGN lr_curr_data->* TO <lt_curr>.
  IF <lt_curr> IS NOT ASSIGNED.
*    MESSAGE 'Không assign được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-107 TYPE'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING is_log-tabname.
  IF gt_key_fields IS INITIAL.
*    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    lv_msg = TEXT-108. "Không tìm thấy key fields cho bảng &1
    REPLACE '&1' IN lv_msg WITH is_log-tabname.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_curr>.
  DATA: lo_tabledesc TYPE REF TO cl_abap_tabledescr,
        lo_linedesc  TYPE REF TO cl_abap_structdescr.
  lo_tabledesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_before ).
  lo_linedesc  ?= lo_tabledesc->get_table_line_type( ).

  LOOP AT <lt> ASSIGNING <ls>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
*      MESSAGE |Không xây được điều kiện khóa: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      lv_msg = TEXT-109.
      REPLACE '&1' IN lv_msg WITH lv_we.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

      RETURN.
    ENDIF.

    DATA lr_line TYPE REF TO data.
    CREATE DATA lr_line TYPE HANDLE lo_linedesc.
    ASSIGN lr_line->* TO <ls_curr>.
    IF <ls_curr> IS NOT ASSIGNED.
*      MESSAGE 'Không tạo được cấu trúc dòng cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
      MESSAGE TEXT-110 TYPE 'S' DISPLAY LIKE 'E'.

      RETURN.
    ENDIF.

    TRY.
        SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_rb1).
        MESSAGE lx_rb1->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.
    IF sy-subrc = 0.
      APPEND <ls_curr> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  IF <lt_curr> IS NOT INITIAL.
    /ui2/cl_json=>serialize(
      EXPORTING data        = <lt_curr>
                pretty_name = /ui2/cl_json=>pretty_mode-none
      RECEIVING r_json      = lv_curr_json ).
  ELSE.
    lv_curr_json = '[]'.
  ENDIF.

  PERFORM save_data USING is_log-tabname
                    CHANGING lr_before lv_mod lv_err.

  IF lv_err IS INITIAL.
    DATA: lv_newlogid TYPE char32,
          ls_new      TYPE zaudit_log.
    TRY.
        lv_newlogid = cl_system_uuid=>create_uuid_c32_static( ).
      CATCH cx_uuid_error.
        CLEAR lv_newlogid.
    ENDTRY.

    CLEAR ls_new.
    ls_new-mandt       = sy-mandt.
    ls_new-logid       = lv_newlogid.
    ls_new-uname       = sy-uname.
    ls_new-udate       = sy-datum.
    ls_new-utime       = sy-uzeit.
    ls_new-tabname     = is_log-tabname.
    ls_new-action      = 'ROLLBACK'.
    ls_new-before_json = lv_curr_json.
    ls_new-after_json  = lv_json.

*    INSERT zaudit_log FROM ls_new.
*    COMMIT WORK AND WAIT.
*    gv_dirty = abap_false.
*    DATA lv_subj TYPE so_obj_des.
*    DATA lv_mail_rc TYPE i.
*    lv_subj = |[RB OK] { is_log-tabname } LOG { lv_newlogid(8) }|.
*    PERFORM send_mail_min USING lv_subj 'thanhchse171611@fpt.edu.vn'.
*    lv_mail_rc = sy-subrc.
*  ELSE.
*    ROLLBACK WORK.
*    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
*  ENDIF.
*ENDFORM.

    INSERT zaudit_log FROM ls_new.
    COMMIT WORK AND WAIT.
    gv_dirty = abap_false.

    PERFORM notify_rollback_smtp
      USING ls_new          " Log record vừa insert (chứa LogID mới)
            1               " Số dòng thay đổi (Rollback 1 dòng)
            lv_curr_json    " Snapshot dữ liệu TRƯỚC khi rollback (để so sánh)
            lv_json         " Snapshot dữ liệu SAU khi rollback (để so sánh)
            ''.             " Ghi chú (để trống)

  ELSE.
    ROLLBACK WORK.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.
ENDFORM.

**---------------------------------------------------------------------*
** Gửi mail tối giản (raw)
**---------------------------------------------------------------------*
*FORM send_mail_min USING iv_subject TYPE so_obj_des
*iv_to TYPE ad_smtpadr.
*  DATA: lo_req      TYPE REF TO cl_bcs,
*        lo_doc      TYPE REF TO cl_document_bcs,
*        lo_rcpt     TYPE REF TO if_recipient_bcs,
*        lt_text     TYPE bcsy_text,
*        ls_line     LIKE LINE OF lt_text,
*        lv_to_local TYPE ad_smtpadr.
*
*  lv_to_local = iv_to.
*  IF lv_to_local IS INITIAL.
*    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
*  ENDIF.
*
*  CLEAR lt_text.
*  ls_line-line = |Rollback thành công từ { sy-repid } (user { sy-uname }).|.
*  APPEND ls_line TO lt_text.
*
*  TRY.
*      lo_req = cl_bcs=>create_persistent( ).
*      lo_doc = cl_document_bcs=>create_document(
*                 i_type    = 'RAW'
*                 i_text    = lt_text
*                 i_subject = iv_subject ).
*      lo_req->set_document( lo_doc ).
*      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).
*
*      " (A) TẮT thông báo trạng thái gửi (không nhận status mail/express)
*      lo_req->set_status_attributes(
*        i_requested_status = 'N'  " no MDN/status request
*        i_status_mail      = 'N'    " no status mail back to sender
*      ).
*
*      " (B) GỬI CHO BẠN VÀO SBWP NHƯNG KHÔNG EXPRESS (=> KHÔNG POPUP)
*      lo_req->add_recipient(
*        i_recipient = cl_sapuser_bcs=>create( sy-uname )
*        i_express   = abap_false ).
*
*      " (C) GỬI RA EMAIL INTERNET – cũng KHÔNG express
*      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
*      lo_req->add_recipient(
*        i_recipient = lo_rcpt
*        i_express   = abap_false
*        i_copy      = abap_false
*        i_blind_copy = abap_false ).
*
*      lo_req->set_send_immediately( abap_true ).
*      lo_req->send( i_with_error_screen = abap_false ).
*      COMMIT WORK AND WAIT.
*      sy-subrc = 0.
*    CATCH cx_root.
*      sy-subrc = 4.
*  ENDTRY.
*
*ENDFORM.

*---------------------------------------------------------------------*
* Restore data từ JSON (dùng cho rollback)
*---------------------------------------------------------------------*
FORM restore_data USING iv_tabname TYPE tabname
                        iv_json    TYPE zde_json_txt
                  CHANGING ev_err  TYPE string
                           ev_mod  TYPE i.

  DATA: lr_data  TYPE REF TO data,
        lv_where TYPE string,
        lv_msg   TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any.

  CLEAR: ev_err, ev_mod.

  PERFORM json_to_itab USING iv_tabname iv_json CHANGING lr_data.
  ASSIGN lr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
*    ev_err = |Không parse được JSON để restore cho bảng { iv_tabname }|.
    lv_msg = TEXT-112.
    REPLACE '&1' IN lv_msg WITH iv_tabname.
    ev_err = lv_msg.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING iv_tabname.
  IF gt_key_fields IS INITIAL.
*    ev_err = |Không tìm thấy key fields cho bảng { iv_tabname }|.
    lv_msg = TEXT-113.
    REPLACE '&1' IN lv_msg WITH iv_tabname.
    ev_err = lv_msg.
    RETURN.
  ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields
      CHANGING lv_where lv_msg.
    IF lv_where IS INITIAL.
*      ev_err = |Không tạo được WHERE: { lv_msg }|.
      DATA(lv_msg2) = lv_msg. " giữ nguyên nội dung cũ
      lv_msg = TEXT-161.
      REPLACE '&1' IN lv_msg WITH lv_msg2.
      ev_err = lv_msg.

      RETURN.
    ENDIF.

    TRY.
        DELETE FROM (iv_tabname) WHERE (lv_where).
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_r1).
        ev_err = lx_r1->get_text( ).
        RETURN.
    ENDTRY.

    INSERT (iv_tabname) FROM <ls_data>.
    IF sy-subrc = 0.
      ev_mod = ev_mod + 1.
    ELSE.
*      ev_err = |Không insert được dòng trong { iv_tabname } với WHERE { lv_where }|.
      lv_msg = TEXT-115.
      REPLACE '&1' IN lv_msg WITH iv_tabname.
      REPLACE '&2' IN lv_msg WITH lv_where.
      ev_err = lv_msg.

      RETURN.
    ENDIF.
  ENDLOOP.
ENDFORM.

*-------------------------------------------------------------*
* JSON -> itab động (rollback) – đồng bộ pretty_mode = none
*-------------------------------------------------------------*
FORM json_to_itab USING iv_tab  TYPE tabname
                        iv_json TYPE zde_json_txt
                  CHANGING cr_data TYPE REF TO data.
  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_any    TYPE REF TO data,
        lr_row    TYPE REF TO data.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  TRY.
      lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
      lo_table  = cl_abap_tabledescr=>create( lo_struct ).
      CREATE DATA lr_any TYPE HANDLE lo_table.
      ASSIGN lr_any->* TO <lt_data>.

      /ui2/cl_json=>deserialize(
  EXPORTING json        = iv_json
            pretty_name = /ui2/cl_json=>pretty_mode-none
  CHANGING  data        = <lt_data> ).

      IF <lt_data> IS INITIAL.
        CREATE DATA lr_row TYPE HANDLE lo_struct.
        ASSIGN lr_row->* TO <ls_row>.
        /ui2/cl_json=>deserialize(
          EXPORTING json        = iv_json
                    pretty_name = /ui2/cl_json=>pretty_mode-none
          CHANGING  data        = <ls_row> ).
        APPEND <ls_row> TO <lt_data>.
      ENDIF.

      cr_data = lr_any.
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail cho manager
*---------------------------------------------------------------------*
*FORM get_manager_for_tab
*  USING    iv_tabname       TYPE tabname
*  CHANGING ev_manager_user  TYPE syuname
*           ev_manager_email TYPE ad_smtpadr.
*
*  CLEAR: ev_manager_user.
*  CLEAR: ev_manager_email.
*
*  SELECT SINGLE
*         manager_uname,
*         manager_email
*    FROM ztab_manager
*    WHERE tabname = @iv_tabname
*      AND ( active = 'X' OR active IS INITIAL )
*    INTO (@ev_manager_user, @ev_manager_email).
*
*ENDFORM.

FORM get_manager_for_tab
  USING    iv_tabname  TYPE tabname
  CHANGING ct_managers TYPE string_table. " Dùng string_table để tương thích

  CLEAR ct_managers.

  " Lỗi 1: Đưa INTO TABLE xuống cuối cùng
  SELECT manager_email
    FROM ztab_manager
    WHERE tabname = @iv_tabname
      AND ( active = 'X' OR active IS INITIAL )
    INTO TABLE @ct_managers.

ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail sau khi rollback – (wrapper, có fallback) — FINAL (SO_OBJ_DES)
*---------------------------------------------------------------------*
FORM notify_rollback_smtp
  USING is_log       TYPE zaudit_log
        iv_mod       TYPE i
        iv_curr_json TYPE zde_json_txt
        iv_prev_json TYPE zde_json_txt
        iv_note      TYPE string.

  DATA: lt_emails TYPE string_table. " Dùng bảng string

  " 1) Lấy danh sách người nhận
  PERFORM get_notify_recipient
    USING    is_log-tabname
    CHANGING lt_emails.

  " 2) Gọi form gửi mail chi tiết
  PERFORM send_mail_rb_detail
    USING is_log-tabname        " iv_tab
          is_log-logid          " iv_logid
          iv_mod                " iv_rows
          lt_emails             " <--- Truyền bảng email
          iv_curr_json          " iv_json_curr
          iv_prev_json          " iv_json_after
          iv_note               " iv_note
          ''                    " iv_subject_override
          ''.                   " iv_html_override

ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail rollback chi tiết (HTML) – có hỗ trợ override cho SAVE
*---------------------------------------------------------------------*
FORM send_mail_rb_detail
  USING iv_tab              TYPE tabname
        iv_logid            TYPE zaudit_log-logid
        iv_rows             TYPE i
        it_to               TYPE string_table
        iv_json_curr        TYPE zde_json_txt
        iv_json_after       TYPE zde_json_txt
        iv_note             TYPE string
        iv_subject_override TYPE so_obj_des
        iv_html_override    TYPE string.

  DATA: lo_req    TYPE REF TO cl_bcs,
        lo_doc    TYPE REF TO cl_document_bcs,
        lo_rcpt   TYPE REF TO if_recipient_bcs,
        lo_rcptso TYPE REF TO if_recipient_bcs,
        lt_body   TYPE bcsy_text,
        lv_subj   TYPE so_obj_des,
        lv_html   TYPE string,
        lt_emails TYPE string_table,
        lv_email  TYPE string.

  " Resolve người nhận: Copy từ tham số vào biến local
  lt_emails = it_to.

  " Nếu danh sách rỗng -> Thêm email mặc định (Fallback)
  IF lt_emails IS INITIAL.
    PERFORM get_manager_for_tab USING 'OWNER' CHANGING lt_emails.
  ENDIF.


  " Subject: ưu tiên override (dùng cho SAVE); nếu rỗng -> subject rollback mặc định
  IF iv_subject_override IS NOT INITIAL.
    lv_subj = iv_subject_override.
  ELSE.
*    lv_subj = |[ROLLBACK OK] { iv_tab } - LOG { iv_logid(8) } - { iv_rows } row(s)|.
    lv_subj = TEXT-162.

    REPLACE '&1' IN lv_subj WITH iv_tab.
    REPLACE '&2' IN lv_subj WITH iv_logid.
    REPLACE '&3' IN lv_subj WITH |{ iv_rows }|.


  ENDIF.

  " Body HTML:
  IF iv_html_override IS INITIAL.
    " Header + meta (rollback)
    lv_html =
      |<html><head><meta charset="utf-8"></head>| &&
      |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
      |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
      |<h3 style="font-size:16px;margin:0 0 8px 0">Rollback successfully | &&
      |<span style="display:inline-block;padding:2px 8px;border-radius:999px;background:#e2f3e8;color:#065f46;font-size:12px">{ iv_rows } row(s)</span>| &&
      |</h3>| &&
      |<table style="border-collapse:collapse">| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Table</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tab }</td></tr>| &&
*      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Log ID</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_logid }</td></tr>| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>User</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
*      |<tr><td style="padding:4px 8px;vertical-align:top"><b>program</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-repid }</td></tr>| &&
*      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Time</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
      |</table></div>|.

    " Diff HTML
    DATA lv_diff_html TYPE string.
    PERFORM build_html_diff USING    iv_tab
                                     iv_json_curr
                                     iv_json_after
                            CHANGING lv_diff_html.
    lv_html = lv_html && lv_diff_html && |</body></html>|.

  ELSE.
    " Dùng body override do caller truyền vào (SAVE)
    lv_html = iv_html_override.
  ENDIF.

  " Convert HTML string -> bcsy_text
  PERFORM _string_to_bcs_text USING lv_html CHANGING lt_body.

  " Gửi qua BCS
  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'HTM'
                 i_text    = lt_body
                 i_subject = lv_subj ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " Tắt status notification
      lo_req->set_status_attributes(
        i_requested_status = 'N'
        i_status_mail      = 'N' ).

      " SBWP: người đang chạy, không express
      lo_rcptso = cl_sapuser_bcs=>create( sy-uname ).
      lo_req->add_recipient(
        i_recipient = lo_rcptso
        i_express   = abap_false ).

      " VÒNG LẶP THÊM NHIỀU NGƯỜI NHẬN
      LOOP AT lt_emails INTO lv_email.
        IF lv_email IS NOT INITIAL.
          TRY.
              lo_rcpt = cl_cam_address_bcs=>create_internet_address( CONV #( lv_email ) ).
              lo_req->add_recipient(
                i_recipient  = lo_rcpt
                i_express    = abap_false
                i_copy       = abap_false
                i_blind_copy = abap_false ).
            CATCH cx_root.
              " Nếu 1 email lỗi định dạng, bỏ qua và tiếp tục người sau
              CONTINUE.
          ENDTRY.
        ENDIF.
      ENDLOOP.

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Helper: chọn người nhận notify (owner > manager > fallback)
*---------------------------------------------------------------------*
FORM get_notify_recipient
  USING    iv_tabname TYPE tabname
  CHANGING ct_to      TYPE string_table.

  DATA: lt_managers TYPE string_table.

  CLEAR ct_to.

  " --- BƯỚC 1: Tìm Manager cấu hình riêng cho bảng này ---
  PERFORM get_manager_for_tab USING iv_tabname CHANGING lt_managers.

  IF lt_managers IS NOT INITIAL.
    " Nếu tìm thấy manager riêng -> Dùng luôn
    APPEND LINES OF lt_managers TO ct_to.
  ELSE.
    " --- BƯỚC 2: Nếu không có, tìm cấu hình Mặc định (Key = 'DEFAULT') ---
    PERFORM get_manager_for_tab USING 'OWNER' CHANGING lt_managers.

    IF lt_managers IS NOT INITIAL.

      APPEND LINES OF lt_managers TO ct_to.
    ENDIF.
  ENDIF.
ENDFORM.




*---------------------------------------------------------------------*
* Gửi mail sau khi SAVE (summary + chi tiết như rollback)
* Dùng build_html_diff (JSON thô) cho từng record trong gt_audit
*---------------------------------------------------------------------*
FORM notify_save_smtp
  USING    iv_tabname TYPE tabname
           iv_ins     TYPE i
           iv_upd     TYPE i
           iv_del     TYPE i
  CHANGING ct_changes TYPE zty_change_tab.

  DATA: lv_subject  TYPE so_obj_des,
        lv_html     TYPE string,
        lt_emails   TYPE string_table,
        lv_rows     TYPE i,
        lv_cnt      TYPE i VALUE 0,
        lv_max_rows TYPE i VALUE 50.

  lv_rows = iv_ins + iv_upd + iv_del.
  IF lv_rows = 0. RETURN. ENDIF.

  " 1) Lấy người nhận
  PERFORM get_notify_recipient USING iv_tabname CHANGING lt_emails.

  " 2) Subject override
  lv_subject = |[SAVE] { iv_tabname }|.

  " 3) Header + summary (Giữ nguyên logic HTML cũ của bạn)
  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">Changes after SAVE</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Table</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tabname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>User</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |</table></div>| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
    |<p style="margin:0"><b>Result:</b> +{ iv_ins } { TEXT-203 } , ~{ iv_upd } { TEXT-204 } , –{ iv_del } { TEXT-205 }</p>| &&
    |</div>| .

  " 4) Chi tiết (Giữ nguyên logic cũ)
  FIELD-SYMBOLS <a> TYPE ty_audit.
  LOOP AT gt_audit ASSIGNING <a> WHERE tabname = iv_tabname.
    ADD 1 TO lv_cnt.
    IF lv_cnt > lv_max_rows.
      lv_html = lv_html && |<div style="margin-top:8px;color:#6b7280;font-size:12px"><i>(Rút gọn...)</i></div>|.
      EXIT.
    ENDIF.
    DATA(lv_diff_html) = VALUE string( ).
    PERFORM build_html_diff USING iv_tabname <a>-before_json <a>-after_json CHANGING lv_diff_html.
    lv_html = lv_html && lv_diff_html.
  ENDLOOP.
  lv_html = lv_html && |</body></html>|.

  " 5) Gửi mail (Truyền lt_emails thay vì biến đơn)
  PERFORM send_mail_rb_detail
    USING iv_tabname space lv_rows lt_emails '' '' '' lv_subject lv_html.

ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail sau khi DELETE
*---------------------------------------------------------------------*
FORM notify_delete_smtp
  USING    iv_tabname TYPE tabname
  CHANGING ct_changes TYPE zty_change_tab.

  DATA: lv_subject  TYPE so_obj_des,
        lv_html     TYPE string,
        lt_emails   TYPE string_table, "
        lv_rows     TYPE i,
        lv_cnt      TYPE i VALUE 0,
        lv_max_rows TYPE i VALUE 50.

  lv_rows = REDUCE i( INIT x = 0 FOR a IN gt_audit
                      WHERE ( tabname = iv_tabname AND action = 'DELETE' )
                      NEXT x = x + 1 ).
  IF lv_rows = 0. RETURN. ENDIF.

  " Lấy người nhận
  PERFORM get_notify_recipient USING iv_tabname CHANGING lt_emails.

  lv_subject = |[DELETE] { iv_tabname } – { lv_rows } rows|.

  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">DELETE</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Table</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tabname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>User</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |</table></div>| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
    |<p style="margin:0"><b>Result :</b> –{ lv_rows }delete</p>| &&
    |</div>|.

  " Build chi tiết
  FIELD-SYMBOLS <a> TYPE ty_audit.
  LOOP AT gt_audit ASSIGNING <a> WHERE tabname = iv_tabname AND action = 'DELETE'.
    DATA(lv_diff_html) = VALUE string( ).
    PERFORM build_html_diff USING iv_tabname <a>-before_json '' CHANGING lv_diff_html.
    lv_html = lv_html && lv_diff_html.
  ENDLOOP.
  lv_html = lv_html && |</body></html>|.

  " Gửi mail (Truyền lt_emails)
  PERFORM send_mail_rb_detail
    USING iv_tabname space lv_rows lt_emails '' '' '' lv_subject lv_html.

ENDFORM.


*---------------------------------------------------------------------*
* Helper: string -> bcsy_text (manual SPLIT 255 ký tự/line)
*---------------------------------------------------------------------*
FORM _string_to_bcs_text USING iv_str TYPE string
CHANGING ct_text TYPE bcsy_text.
  DATA: lv_off  TYPE i VALUE 0,
        lv_len  TYPE i,
        lv_take TYPE i,
        ls      TYPE soli.
  CLEAR ct_text.
  lv_len = strlen( iv_str ).
  WHILE lv_off < lv_len.
    lv_take = lv_len - lv_off.
    IF lv_take > 255.
      lv_take = 255.
    ENDIF.
    CLEAR ls.
    ls-line = iv_str+lv_off(lv_take).
    APPEND ls TO ct_text.
    lv_off = lv_off + lv_take.
  ENDWHILE.
  IF ct_text IS INITIAL.
    CLEAR ls.
    APPEND ls TO ct_text.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: escape tối thiểu để nhúng json vào html safely
*---------------------------------------------------------------------*
FORM _html_escape USING iv_in TYPE string
CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '&' IN cv_out WITH '&amp;'.
  REPLACE ALL OCCURRENCES OF '<' IN cv_out WITH '&lt;'.
  REPLACE ALL OCCURRENCES OF '>' IN cv_out WITH '&gt;'.
  REPLACE ALL OCCURRENCES OF '"' IN cv_out WITH '&quot;'.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH '&#39;'.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: rút gọn string nếu vượt max_len
*---------------------------------------------------------------------*
FORM _ellipsize_html USING iv_in TYPE string
iv_max_len TYPE i
CHANGING cv_out TYPE string.
  DATA: lv_len  TYPE i, lv_max TYPE i, lv_take TYPE i.
  lv_max = iv_max_len.
  IF lv_max IS INITIAL OR lv_max < 1000.
    lv_max = 1000.
  ENDIF.
  lv_len = strlen( iv_in ).
  IF lv_len > lv_max.
    lv_take = lv_max - 15.
    IF lv_take < 0.
      lv_take = 0.
    ENDIF.
    cv_out = iv_in+0(lv_take).
*    cv_out = cv_out && |... (truncated)|.
    lv_msg = TEXT-181.
    cv_out = cv_out && lv_msg.
  ELSE.
    cv_out = iv_in.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
*  Build HTML diff (COMPACT TABLE): 1 record -> 1 bảng ngang
*   Header:  Mô tả | <Field 1> | <Field 2> | ...
*   Body:    Before | ...values...   (ô khác biệt tô đỏ nhạt)
*            After  | ...values...   (ô khác biệt tô xanh nhạt)
*---------------------------------------------------------------------*
FORM build_html_diff USING    iv_tab        TYPE tabname
                              iv_json_curr  TYPE zde_json_txt
                              iv_json_after TYPE zde_json_txt
                     CHANGING cv_html       TYPE string.

  DATA: lr_data_curr  TYPE REF TO data,
        lr_data_after TYPE REF TO data,
        lt_fieldinfo  TYPE TABLE OF dfies,
        ls_field      TYPE dfies,
        lv_tab_up     TYPE tabname.

  FIELD-SYMBOLS: <lt_curr>  TYPE STANDARD TABLE,
                 <lt_after> TYPE STANDARD TABLE,
                 <ls_curr>  TYPE any,
                 <ls_after> TYPE any,
                 <old>      TYPE any,
                 <new>      TYPE any.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Biến key (PHẢI là string để dùng CHANGING)
  DATA: lv_kc  TYPE string,
        lv_ka  TYPE string,
        lv_key TYPE string.

  " Tổng số field changed (cho legend cuối mail)
  DATA lv_changed_total TYPE i VALUE 0.

  " -- upper-case bảng
  lv_tab_up = iv_tab.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " 0) DDIC describe & field info
  lo_struct ?= cl_abap_typedescr=>describe_by_name( lv_tab_up ).
  IF lo_struct IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>Cannot describe DDIC structure.</i></div>'.
    RETURN.
  ENDIF.
  lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = lv_tab_up
      all_types = 'X'
    TABLES
      dfies_tab = lt_fieldinfo
    EXCEPTIONS
      OTHERS    = 1.
  IF sy-subrc <> 0.
    RETURN. " Nếu lỗi metadata thì không làm gì tiếp
  ENDIF.
  IF lt_fieldinfo IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No DDIC field info for table.</i></div>'.
    RETURN.
  ENDIF.

  " 1) JSON -> itab động (có thể rỗng)
  PERFORM json_to_itab USING lv_tab_up iv_json_curr  CHANGING lr_data_curr.
  PERFORM json_to_itab USING lv_tab_up iv_json_after CHANGING lr_data_after.
  IF lr_data_curr IS BOUND.  ASSIGN lr_data_curr->*  TO <lt_curr>.  ENDIF.
  IF lr_data_after IS BOUND. ASSIGN lr_data_after->* TO <lt_after>. ENDIF.

  IF ( <lt_curr>  IS NOT ASSIGNED OR <lt_curr>  IS INITIAL )
 AND ( <lt_after> IS NOT ASSIGNED OR <lt_after> IS INITIAL ).
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No parsable data for diff (both before/after empty).</i></div>'.
    RETURN.
  ENDIF.

  " 2) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING lv_tab_up IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key fields in DDIC.</i></div>'.
    RETURN.
  ENDIF.

  " 3) Hợp nhất các KEY từ cả Before/After
  DATA: lt_all_keys TYPE SORTED TABLE OF string WITH UNIQUE KEY table_line.
  IF <lt_curr> IS ASSIGNED.
    LOOP AT <lt_curr> ASSIGNING <ls_curr>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF <lt_after> IS ASSIGNED.
    LOOP AT <lt_after> ASSIGNING <ls_after>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_after> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF lt_all_keys IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key found to pair rows.</i></div>'.
    RETURN.
  ENDIF.

  " 4) Render: mỗi KEY = 1 bảng ngang (1 header + 2 dòng Before/After)
  CLEAR cv_html.
  DATA: lv_block  TYPE string,
        lv_tbl    TYPE string,
        lv_head   TYPE string,
        lv_row_b  TYPE string,
        lv_row_a  TYPE string,
        lv_title  TYPE string,
        lv_desc   TYPE string,
        lv_desc_h TYPE string,
        lv_old    TYPE string,
        lv_new    TYPE string,
        lv_old_h  TYPE string,
        lv_new_h  TYPE string,
        lv_cnt    TYPE i VALUE 0.

  LOOP AT lt_all_keys INTO lv_key.
    ADD 1 TO lv_cnt.

    " — Tìm bản ghi theo KEY ở Before / After
    UNASSIGN: <ls_curr>, <ls_after>.
    IF <lt_curr> IS ASSIGNED.
      LOOP AT <lt_curr> ASSIGNING <ls_curr>.
        CLEAR lv_kc.
        PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_kc.
        IF lv_kc = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.
    IF <lt_after> IS ASSIGNED.
      LOOP AT <lt_after> ASSIGNING <ls_after>.
        CLEAR lv_ka.
        PERFORM _make_key_str_any USING <ls_after> CHANGING lv_ka.
        IF lv_ka = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.

    " Nếu thiếu 1 phía -> tạo struct rỗng để vẫn render
    IF <ls_curr>  IS NOT ASSIGNED.
      DATA lr_zero_c TYPE REF TO data.
      CREATE DATA lr_zero_c TYPE HANDLE lo_struct.
      ASSIGN lr_zero_c->* TO <ls_curr>.
      CLEAR <ls_curr>.
    ENDIF.
    IF <ls_after> IS NOT ASSIGNED.
      DATA lr_zero_a TYPE REF TO data.
      CREATE DATA lr_zero_a TYPE HANDLE lo_struct.
      ASSIGN lr_zero_a->* TO <ls_after>.
      CLEAR <ls_after>.
    ENDIF.

    " — Title record
    lv_title = |{ TEXT-206 }{ lv_cnt } — KEY [{ lv_key }]| .

    lv_block =
      '<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">'
   && |<div style="font-weight:600;font-size:14px;margin-bottom:10px">{ lv_title }</div>|
   && '<div style="overflow-x:auto">'
   && '<table style="border-collapse:collapse;min-width:720px;font-family:Arial,sans-serif;font-size:12px">' ##NO_TEXT.

    " — Header (nền tối, chữ trắng)
    lv_head =
  '<tr>'
&& '<th style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left">Mô tả</th>'.

    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      " chọn nhãn dễ đọc
      lv_desc = ls_field-scrtext_l.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_m. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_s. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldtext.  ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldname.  ENDIF.
      PERFORM _html_escape USING lv_desc CHANGING lv_desc_h.

      lv_head &&=
        |<th style="background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left;white-space:nowrap">{ lv_desc_h }</th>|.
    ENDLOOP.
    lv_head &&= '</tr>'.

    " — Row BEFORE
    lv_row_b =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">Before</td>'.

    " — Row AFTER
    lv_row_a =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">After</td>'.

    " — Fill cells & đánh dấu thay đổi theo ô
    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      CLEAR: lv_old, lv_new, lv_old_h, lv_new_h.

      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_curr>  TO <old>.
      IF <old> IS ASSIGNED. lv_old = <old>. ENDIF.
      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_after> TO <new>.
      IF <new> IS ASSIGNED. lv_new = <new>. ENDIF.

      PERFORM _html_escape USING lv_old CHANGING lv_old_h.
      PERFORM _html_escape USING lv_new CHANGING lv_new_h.

      DATA(lv_changed) = xsdbool( lv_old_h <> lv_new_h ).
      IF lv_changed = abap_true.
        lv_changed_total = lv_changed_total + 1.
      ENDIF.

      " Before-cell (đỏ nhạt nếu đổi)
      lv_row_b &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#FEE2E2;color:#991B1B;' ELSE '' )
       && |">{ lv_old_h }</td>|.

      " After-cell (xanh nhạt nếu đổi)
      lv_row_a &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#D1FAE5;color:#065F46;' ELSE '' )
       && |">{ lv_new_h }</td>|.
    ENDLOOP.

    lv_row_b &&= '</tr>'.
    lv_row_a &&= '</tr>'.

    lv_tbl = lv_head && lv_row_b && lv_row_a && '</table></div>'. " đóng table + overflow

    " — Gộp block
    lv_block &&= lv_tbl && '</div>'.
    cv_html  &&= lv_block.
  ENDLOOP.

  " Legend
  cv_html &&=
    |<div style="margin-top:8px;font-size:12px;color:#374151">|
* && |<b>{ lv_changed_total }</b> field(s) changed across records. |
 && |<span style="display:inline-block;margin-left:8px;padding:2px 6px;background:#FEE2E2;color:#991B1B;border-radius:999px">Before changed</span>|
 && |<span style="display:inline-block;margin-left:6px;padding:2px 6px;background:#D1FAE5;color:#065F46;border-radius:999px">After changed</span>|
 && |</div>|.

ENDFORM.


*---------------------------------------------------------------------*
* Tạo KEY string ổn định từ 1 dòng dựa trên gt_key_fields
*---------------------------------------------------------------------*
FORM _make_key_str_any
  USING    is_row TYPE any
  CHANGING cv_key TYPE string.

  DATA: lv_name TYPE dd03l-fieldname,
        lv_tmp  TYPE string,
        lv_part TYPE string.
  FIELD-SYMBOLS: <v> TYPE any.

  CLEAR cv_key.
  LOOP AT gt_key_fields INTO lv_name.
    ASSIGN COMPONENT lv_name OF STRUCTURE is_row TO <v>.
    CLEAR lv_part.
    IF sy-subrc = 0 AND <v> IS ASSIGNED.
      lv_tmp = <v>.
      TRANSLATE lv_tmp TO UPPER CASE.
      CONDENSE  lv_tmp NO-GAPS.
      lv_part = lv_tmp.
    ENDIF.
    IF cv_key IS INITIAL.
      cv_key = lv_part.
    ELSE.
      CONCATENATE cv_key lv_part INTO cv_key SEPARATED BY '|'.
    ENDIF.
  ENDLOOP.

ENDFORM.


*---------------------------------------------------------------------*
*  Get Data Element short text (DD04T-DDTEXT)
*---------------------------------------------------------------------*
FORM get_dtel_text USING    iv_rollname TYPE rollname
                   CHANGING cv_text     TYPE string.

  DATA ls_dd04v TYPE dd04v.

  CALL FUNCTION 'DDIF_DTEL_GET'
    EXPORTING
      name     = iv_rollname
    IMPORTING
      dd04v_wa = ls_dd04v
    EXCEPTIONS
      OTHERS   = 1.

  IF sy-subrc = 0 AND cv_text IS INITIAL AND ls_dd04v-ddtext IS NOT INITIAL.
    cv_text = ls_dd04v-ddtext.
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
FORM check_unsaved_changes CHANGING ev_has_change TYPE abap_bool.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.

  ev_has_change = abap_false.

  " Nếu đang ở Add/Edit thì mới cần cảnh báo
  IF gv_add_mode = abap_true OR gv_edit_md = abap_true.

    " 1) Nếu đã có cờ bẩn => coi như chưa lưu
    IF gv_dirty = abap_true.
      ev_has_change = abap_true.
      RETURN.
    ENDIF.

    " 2) Hoặc có dòng NEWREC chưa lưu
    ASSIGN gr_data->* TO <lt_data>.
    IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
      LOOP AT <lt_data> ASSIGNING <ls_data>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          ev_has_change = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.

FORM analyze_change_state CHANGING cv_new_incomplete TYPE abap_bool
cv_other_changes  TYPE abap_bool.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_has_newrec      TYPE abap_bool VALUE abap_false,
        lv_all_keys_filled TYPE abap_bool,
        lv_key             TYPE dd03l-fieldname,
        lv_val_str         TYPE string.

  cv_new_incomplete = abap_false.
  cv_other_changes  = abap_false.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_has_newrec      = abap_true.
        lv_all_keys_filled = abap_true.

        LOOP AT gt_key_fields INTO lv_key.
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc <> 0 OR <cell> IS NOT ASSIGNED.
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.

          " Chuẩn hóa để check INITIAL cho cả char/num
          CLEAR lv_val_str.
          TRY.
              lv_val_str = <cell>.
            CATCH cx_root.
              " Nếu không gán được string (kiểu số), check INITIAL trực tiếp
          ENDTRY.

          IF lv_val_str IS NOT INITIAL.
            CONDENSE lv_val_str.
          ENDIF.

          IF ( lv_val_str IS INITIAL ) AND ( <cell> IS INITIAL ).
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_all_keys_filled = abap_false.
          cv_new_incomplete = abap_true.
          EXIT. " chỉ cần biết có 1 NEWREC thiếu khóa là đủ
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF ( gv_dirty = abap_true AND cv_new_incomplete = abap_false )
  OR ( gv_dirty_nonnewrec = abap_true ).
    cv_other_changes = abap_true.
  ENDIF.

ENDFORM.


FORM is_newrec_target_for_delete CHANGING ev_newrec_only TYPE abap_bool.
  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any, <v> TYPE any.
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col,
        lv_idx     TYPE i.

  ev_newrec_only = abap_false.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index > 0.
      APPEND VALUE lvc_s_row( index = ls_rowid-index ) TO lt_sel_idx.
    ENDIF.
  ENDIF.

  IF lines( lt_sel_idx ) <> 1.
    RETURN.
  ENDIF.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE lt_sel_idx INTO DATA(ls_sel) INDEX 1.
  IF sy-subrc <> 0. RETURN. ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX ls_sel-index.
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED. RETURN. ENDIF.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <v>.
  IF sy-subrc = 0 AND <v> = 'X'.
    " Kiểm tra xem dòng có trống hết key không
    DATA(lv_all_empty) = abap_true.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
      ASSIGN COMPONENT <k> OF STRUCTURE <ls> TO FIELD-SYMBOL(<val>).
      IF sy-subrc = 0 AND <val> IS NOT INITIAL.
        lv_all_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_all_empty = abap_true.
      ev_newrec_only = abap_true.
    ENDIF.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Discard all unsaved changes: KHÔI PHỤC HOÀN TOÀN TỪ BẢN GỐC (SAFE)  *
* - Phù hợp cả khi line type <lt_cur> và <lt_orig> KHÔNG đồng nhất    *
* - Không dump: dùng MOVE-CORRESPONDING theo từng dòng                *
*---------------------------------------------------------------------*
FORM discard_unsaved_changes.

  FIELD-SYMBOLS: <lt_cur>  TYPE STANDARD TABLE,
                 <ls_cur>  TYPE any,
                 <lt_orig> TYPE STANDARD TABLE,
                 <ls_orig> TYPE any.

  ASSIGN gr_data->*          TO <lt_cur>.
  ASSIGN gr_data_original->* TO <lt_orig>.
  IF <lt_cur> IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  "  Chỉ reset khi có bản gốc hợp lệ
  IF <lt_orig> IS ASSIGNED AND <lt_orig> IS NOT INITIAL.
    CLEAR <lt_cur>.
    LOOP AT <lt_orig> ASSIGNING <ls_orig>.
      APPEND INITIAL LINE TO <lt_cur> ASSIGNING <ls_cur>.
      MOVE-CORRESPONDING <ls_orig> TO <ls_cur>.
    ENDLOOP.
    PERFORM merge_audit_log
 USING    gv_keys_tabname
 CHANGING <lt_cur>.
  ELSE.
    " Không có bản gốc → KHÔNG được xóa màn hình
    " PERFORM reload_from_db CHANGING <lt_cur>.
  ENDIF.

  CLEAR gt_changed_existing_keys.
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.
  gv_in_upload    = abap_false.
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

ENDFORM.


FORM purge_incomplete_newrecs.
  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  " Dùng bảng chỉ số để xóa theo INDEX (key mặc định)
  DATA: lt_del     TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_missing TYPE abap_bool,
        lv_key     TYPE dd03l-fieldname,
        lv_purged  TYPE i VALUE 0,
        lv_has_new TYPE abap_bool VALUE abap_false,
        ls_stbl    TYPE lvc_s_stbl.

  CLEAR: ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  " 1) Thu thập index các NEWREC thiếu khóa; đồng thời ghi nhận còn NEWREC nào không
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      lv_has_new = abap_true. " có ít nhất một NEWREC trong lưới
      lv_missing = abap_false.

      LOOP AT gt_key_fields INTO lv_key.
        ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
        IF sy-subrc <> 0 OR <cell> IS INITIAL.
          lv_missing = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_missing = abap_true.
        APPEND sy-tabix TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Xóa các dòng NEWREC thiếu khóa (xóa từ index lớn xuống để an toàn)
  IF lt_del IS NOT INITIAL.
    SORT lt_del DESCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_del.
    LOOP AT lt_del ASSIGNING FIELD-SYMBOL(<idx>).
      DELETE <lt> INDEX <idx>.
      lv_purged = lv_purged + 1.
    ENDLOOP.
  ENDIF.

  " 3) Kiểm tra sau khi xóa còn NEWREC hợp lệ nào không?
  "   Nếu KHÔNG còn NEWREC → tắt add mode để tránh khóa nhầm KEY các dòng cũ
  IF lv_has_new = abap_true.
    DATA(lv_still_has_new) = abap_false.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
      IF sy-subrc = 0 AND <new> = 'X'.
        lv_still_has_new = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_still_has_new = abap_false.
      gv_add_mode = abap_false.
    ENDIF.
  ENDIF.

  " 4) Áp lại editability & refresh ALV
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " 5) Thông báo nhẹ cho người dùng (nếu có xóa)
  IF lv_purged > 0.
*    MESSAGE |Đã bỏ { lv_purged } NEWREC thiếu khóa.| TYPE 'S'.
    lv_msg = TEXT-155.
    REPLACE '&1' IN lv_msg WITH |{ lv_purged }|.
    MESSAGE lv_msg TYPE 'S'.


  ENDIF.
ENDFORM.


FORM focus_key_on_newrec.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.
  DATA: lv_idx TYPE i.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR g_alv_grid IS INITIAL.
    RETURN.
  ENDIF.

  lv_idx = 0.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_idx = sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF lv_idx = 0. RETURN. ENDIF.

  PERFORM ensure_keys USING p_tab.
  READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
  IF sy-subrc <> 0. RETURN. ENDIF.

  DATA ls_row TYPE lvc_s_row.
  DATA ls_col TYPE lvc_s_col.
  ls_row-index     = lv_idx.
  ls_col-fieldname = lv_first_key.

  TRY.
      g_alv_grid->set_current_cell_via_id(
      EXPORTING is_row_id    = ls_row
      is_column_id = ls_col ).
      g_alv_grid->set_scroll_info_via_id(
      EXPORTING is_row_info = ls_row
      is_col_info = ls_col ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

FORM analyze_change_state_detailed
  CHANGING ev_has_change          TYPE abap_bool
           ev_cnt_new_incomplete  TYPE i
           ev_cnt_new_complete    TYPE i
           ev_cnt_edited_existing TYPE i.

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <lt_orig> TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <ls_orig> TYPE any,
                 <newrec>  TYPE any,
                 <cell>    TYPE any.

  DATA: lv_is_key_missing TYPE abap_bool,
        lv_keyname        TYPE dd03l-fieldname.

  CLEAR: ev_has_change, ev_cnt_new_incomplete, ev_cnt_new_complete, ev_cnt_edited_existing.

  ASSIGN gr_data->* TO <lt>.
  ASSIGN gr_data_original->* TO <lt_orig>.

  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      " 1. Check dòng NEWREC (Dòng mới thêm)
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_is_key_missing = abap_false.
        LOOP AT gt_key_fields INTO lv_keyname.
          ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS INITIAL.
            lv_is_key_missing = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_is_key_missing = abap_true.
          ev_cnt_new_incomplete = ev_cnt_new_incomplete + 1.
        ELSE.
          ev_cnt_new_complete   = ev_cnt_new_complete + 1.
        ENDIF.
        CONTINUE. " Xong dòng mới, qua dòng tiếp
      ENDIF.

      " 2. Check dòng CŨ (So sánh Deep Compare với bản gốc)
      " Chỉ kiểm tra những dòng đã bị đánh dấu là 'từng sửa' để tối ưu hiệu năng
      DATA lv_key_curr TYPE string.
      PERFORM make_row_key USING <ls> CHANGING lv_key_curr.

      READ TABLE gt_changed_existing_keys WITH KEY table_line = lv_key_curr TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        " Dòng này có nằm trong danh sách nghi vấn -> Lôi bản gốc ra đối chiếu
        IF <lt_orig> IS ASSIGNED.
          DATA lv_key_orig TYPE string.
          DATA lv_found_orig TYPE abap_bool VALUE abap_false.

          " Tìm dòng tương ứng trong bảng gốc (Loop để tìm theo Key)
          LOOP AT <lt_orig> ASSIGNING <ls_orig>.
            PERFORM make_row_key USING <ls_orig> CHANGING lv_key_orig.
            IF lv_key_orig = lv_key_curr.
              lv_found_orig = abap_true.

              " So sánh từng ô (trừ cột kỹ thuật và cột Audit)
              DATA lv_diff TYPE abap_bool VALUE abap_false.
              LOOP AT gt_fieldcat INTO DATA(ls_fc_chk).
                IF ls_fc_chk-tech = 'X' OR ls_fc_chk-fieldname = 'MANDT'
                   OR ls_fc_chk-fieldname CP 'ER*' OR ls_fc_chk-fieldname CP 'AE*'.
                  CONTINUE.
                ENDIF.

                ASSIGN COMPONENT ls_fc_chk-fieldname OF STRUCTURE <ls> TO FIELD-SYMBOL(<val_c>).
                ASSIGN COMPONENT ls_fc_chk-fieldname OF STRUCTURE <ls_orig> TO FIELD-SYMBOL(<val_o>).

                IF <val_c> <> <val_o>.
                  lv_diff = abap_true. " Phát hiện khác biệt thật sự
                  EXIT.
                ENDIF.
              ENDLOOP.

              IF lv_diff = abap_true.
                ev_cnt_edited_existing = ev_cnt_edited_existing + 1.
              ENDIF.
              EXIT. " Đã tìm thấy bản gốc, thoát loop tìm kiếm
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " Tổng kết trạng thái
  ev_has_change = boolc( ev_cnt_new_incomplete > 0
                      OR ev_cnt_new_complete   > 0
                      OR ev_cnt_edited_existing > 0 ).

ENDFORM.


FORM build_key_fingerprint USING    is_row        TYPE any
                                     it_keyfields  TYPE STANDARD TABLE
                           CHANGING ev_fp         TYPE string.

  FIELD-SYMBOLS: <kfld> TYPE dd03l-fieldname,
                 <v>    TYPE any.

  DATA lv_s TYPE string.

  CLEAR ev_fp.

  LOOP AT it_keyfields ASSIGNING <kfld>.
    ASSIGN COMPONENT <kfld> OF STRUCTURE is_row TO <v>.
    IF sy-subrc <> 0.
      ev_fp = ev_fp && '|#|'.
      CONTINUE.
    ENDIF.
    lv_s = <v>.
    CONDENSE lv_s.
    ev_fp = ev_fp && lv_s && '|#|'.
  ENDLOOP.
ENDFORM.



FORM mark_row_error USING    iv_row TYPE i
                             iv_msg TYPE string.

  FIELD-SYMBOLS: <lt_tab>    TYPE STANDARD TABLE,
                 <ls_row>    TYPE any,
                 <celltab>   TYPE lvc_t_styl,
                 <msg_field> TYPE any.

  " 1) lấy itab đang hiển thị
  ASSIGN gr_data->* TO <lt_tab>.
  IF <lt_tab> IS NOT ASSIGNED OR iv_row <= 0.
    RETURN.
  ENDIF.

  READ TABLE <lt_tab> INDEX iv_row ASSIGNING <ls_row>.
  IF sy-subrc <> 0 OR <ls_row> IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  " 2) đảm bảo có CELLTAB
  ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls_row> TO <celltab>.
  IF sy-subrc <> 0 OR <celltab> IS NOT ASSIGNED.
    PERFORM ensure_celltab_component CHANGING gr_data.

    " đọc lại sau khi ensure
    READ TABLE <lt_tab> INDEX iv_row ASSIGNING <ls_row>.
    IF sy-subrc <> 0 OR <ls_row> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls_row> TO <celltab>.
    IF sy-subrc <> 0 OR <celltab> IS NOT ASSIGNED.
      RETURN.
    ENDIF.
  ENDIF.

  DATA ls_style TYPE lvc_s_styl.

  " 3) tô tất cả cột hiển thị nhưng giữ đúng sort order
  LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>)
       WHERE tech = abap_false AND no_out = abap_false.

    " check đã có style cho field này chưa
    READ TABLE <celltab> WITH TABLE KEY fieldname = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CONTINUE. " đã có -> khỏi chèn để tránh dump trùng key
    ENDIF.

    CLEAR ls_style.
    ls_style-fieldname = <fc>-fieldname.

    " dùng style có sẵn trong hệ thống bạn
    ls_style-style     = cl_gui_alv_grid=>mc_style_disabled.
    " nếu muốn vẫn cho sửa thì dùng:
    "* ls_style-style     = cl_gui_alv_grid=>mc_style_enabled.

    INSERT ls_style INTO TABLE <celltab>.
  ENDLOOP.

  " 4) gán message nếu có field IS_MESSAGE
  ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_row> TO <msg_field>.
  IF sy-subrc = 0 AND <msg_field> IS ASSIGNED.
    <msg_field> = iv_msg.
  ENDIF.

ENDFORM.


FORM make_row_key USING i_row TYPE any
                  CHANGING e_key TYPE string.
  DATA: lv_piece TYPE string.
  FIELD-SYMBOLS: <cell> TYPE any.
  CLEAR e_key.
  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
    ASSIGN COMPONENT <k> OF STRUCTURE i_row TO <cell>.
    IF sy-subrc = 0.
      lv_piece = |{ <cell> }|.
    ELSE.
      lv_piece = ''.
    ENDIF.
    " dùng ^ như delimiter an toàn
    e_key = COND string( WHEN e_key IS INITIAL THEN lv_piece ELSE e_key && '^' && lv_piece ).
  ENDLOOP.
ENDFORM.

FORM check_newrec_duplicate_all
  USING    iv_tabname                 TYPE tabname
  CHANGING ev_has_dup                 TYPE abap_bool
           ev_msg                     TYPE string
           ev_first_offending_row_idx TYPE i.

  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  DATA: lv_fp    TYPE string,
        lv_where TYPE string,
        lv_we    TYPE string.

  CLEAR: ev_has_dup, ev_msg, ev_first_offending_row_idx.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  " 1) Trùng khóa giữa các NEWREC trong lưới
  TYPES: BEGIN OF ty_fp, fp TYPE string, idx TYPE i, END OF ty_fp.
  DATA: lt_seen TYPE HASHED TABLE OF ty_fp WITH UNIQUE KEY fp,
        ls_seen TYPE ty_fp.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      CLEAR lv_fp.
      PERFORM build_key_fingerprint USING <ls> gt_key_fields CHANGING lv_fp.
      IF lv_fp IS INITIAL.
        CONTINUE.
      ENDIF.

      READ TABLE lt_seen WITH KEY fp = lv_fp INTO ls_seen.
      IF sy-subrc = 0.
        ev_has_dup = abap_true.
        ev_first_offending_row_idx = sy-tabix.  " vẫn giữ để focus
*        ev_msg = |Khóa bị trùng giữa các dòng NEWREC trong lưới.|.
        ev_msg = TEXT-156.
        RETURN.
      ELSE.
        ls_seen-fp  = lv_fp.
        ls_seen-idx = sy-tabix.
        INSERT ls_seen INTO TABLE lt_seen.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Trùng khóa với DB (chỉ kiểm tra các NEWREC đủ khóa)
  DATA lv_exist TYPE i.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.

      CLEAR: lv_where, lv_we, lv_exist.
      PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
      IF lv_where IS INITIAL.
        CONTINUE.
      ENDIF.

      SELECT COUNT( * ) FROM (iv_tabname) WHERE (lv_where) INTO @lv_exist.
      IF lv_exist > 0.
        ev_has_dup = abap_true.
        ev_first_offending_row_idx = sy-tabix.  " vẫn trả về để caller focus
*        ev_msg = |Khóa đã tồn tại trên hệ thống.|.
        ev_msg = TEXT-117.
        RETURN.
      ENDIF.

    ENDIF.
  ENDLOOP.

ENDFORM.

FORM validate_foreign_key USING    iv_tabname   TYPE tabname
                                   iv_fieldname TYPE fieldname
                                   iv_value     TYPE any
                          CHANGING ev_valid     TYPE abap_bool
                                   ev_err_msg   TYPE string.

  DATA: lv_checktab TYPE dd03l-checktable,
        lv_domname  TYPE dd03l-domname,
        lt_domval   TYPE TABLE OF dd07v.

  " Khai báo biến hứng kết quả SELECT thay vì dùng @DATA
  DATA: lv_dummy_client TYPE sy-mandt.
  DATA: lv_where        TYPE string.

  ev_valid = abap_true.
  CLEAR ev_err_msg.

  " 1. Lấy checktable và domname
  SELECT SINGLE checktable, domname
    INTO ( @lv_checktab, @lv_domname )
    FROM dd03l
    WHERE tabname   = @iv_tabname
      AND fieldname = @iv_fieldname
      AND as4local  = 'A'.

  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

  " 2. Check domain fixed values
  IF lv_domname IS NOT INITIAL.
    CALL FUNCTION 'DD_DOMVALUES_GET'
      EXPORTING
        domname   = lv_domname
        langu     = sy-langu
      TABLES
        dd07v_tab = lt_domval
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc = 0 AND lt_domval IS NOT INITIAL.
      READ TABLE lt_domval TRANSPORTING NO FIELDS
        WITH KEY domvalue_l = iv_value.
      IF sy-subrc <> 0.
        READ TABLE lt_domval TRANSPORTING NO FIELDS
          WITH KEY domvalue_h = iv_value.
        IF sy-subrc <> 0.
          ev_valid = abap_false.
          ev_err_msg = |{ TEXT-209 } '{ iv_value }' { TEXT-210 } { lv_domname }|.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  " 3. Check check table (Foreign Key)
  IF lv_checktab IS NOT INITIAL AND ev_valid = abap_true.

    " Tạo câu điều kiện động
*    lv_where = |{ iv_fieldname } = @iv_value|.
    lv_where = |{ iv_fieldname } = @iv_value| ##NO_TEXT.



    " SỬA LỖI: Dùng biến tường minh @lv_dummy_client thay vì @DATA(...)
    SELECT SINGLE mandt
      FROM (lv_checktab)
      INTO @lv_dummy_client
      WHERE (lv_where).

    IF sy-subrc <> 0.
      ev_valid = abap_false.
      ev_err_msg = |{ TEXT-209 } '{ iv_value }' { TEXT-211 } { lv_checktab }|.
    ENDIF.

  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* FORM CHECK_ALL_FOREIGN_KEYS
* Kiểm tra toàn bộ dữ liệu trước khi lưu xem có vi phạm khóa ngoại không
*---------------------------------------------------------------------*
FORM check_all_foreign_keys USING    iv_tab       TYPE tabname
                            CHANGING ev_error     TYPE abap_bool
                                     ev_msg       TYPE string
                                     ev_err_idx   TYPE i
                                     ev_err_field TYPE fieldname.

  DATA: lt_fk_fields    TYPE STANDARD TABLE OF dd03l,
        ls_fk           TYPE dd03l,
        lv_dummy_client TYPE sy-mandt,
        lv_where        TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any,
                 <val>     TYPE any.

  CLEAR: ev_error, ev_msg, ev_err_idx.

  " 1. Lấy danh sách các cột có Check Table (Foreign Key) của bảng hiện tại
  " Chỉ lấy những trường có checktable và không phải là field hệ thống
  SELECT fieldname, checktable, domname
    FROM dd03l
    INTO CORRESPONDING FIELDS OF TABLE @lt_fk_fields
    WHERE tabname   = @iv_tab
      AND checktable <> ''      " Có bảng check
      AND checktable <> '*'     " Bỏ qua check đặc biệt
      AND fieldname  <> 'MANDT' " Bỏ qua Client
      AND as4local  = 'A'.

  IF lt_fk_fields IS INITIAL. RETURN. ENDIF.

  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED. RETURN. ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_row>.
    DATA(lv_idx) = sy-tabix.

    LOOP AT lt_fk_fields INTO ls_fk.
      ASSIGN COMPONENT ls_fk-fieldname OF STRUCTURE <ls_row> TO <val>.
      IF sy-subrc = 0 AND <val> IS NOT INITIAL.

        lv_where = |{ ls_fk-fieldname } = @<val>| ##NO_TEXT.

        TRY.
            SELECT SINGLE mandt FROM (ls_fk-checktable) INTO @lv_dummy_client WHERE (lv_where).
            IF sy-subrc <> 0.
              ev_error     = abap_true.
              ev_err_idx   = lv_idx.
              ev_err_field = ls_fk-fieldname.

              ev_msg = |{ TEXT-214 } { lv_idx }: { TEXT-209 } '{ <val> }' { TEXT-212 } { ls_fk-fieldname } { TEXT-213 } { ls_fk-checktable }.|.
              RETURN.
            ENDIF.
          CATCH cx_root.
            CONTINUE.
        ENDTRY.
      ENDIF.
    ENDLOOP.
  ENDLOOP.
ENDFORM.

*---------------------------------------------------------------------*
* FORM validate_full_dataset
* Kiểm tra toàn bộ dữ liệu: Key rỗng, Trùng khóa, Khóa ngoại
*---------------------------------------------------------------------*
FORM validate_full_dataset CHANGING ev_has_error TYPE abap_bool.

  CLEAR: ev_has_error, gt_val_errors.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any,
                 <newrec>  TYPE any,
                 <val>     TYPE any.

  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS INITIAL. RETURN. ENDIF.

  DATA: lv_idx TYPE i.
  DATA: lt_seen_fp TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line.
  DATA: lv_fp TYPE string.
  DATA: lv_where TYPE string, lv_dummy TYPE string.
  DATA: lv_exists TYPE i.
  DATA: ls_error LIKE LINE OF gt_val_errors.

  LOOP AT <lt_data> ASSIGNING <ls_row>.
    lv_idx = sy-tabix.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_row> TO <newrec>.

    " ---------------------------------------------------------
    " 1. KIỂM TRA KHÓA RỖNG (Chỉ check với dòng mới)
    " ---------------------------------------------------------
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      LOOP AT gt_key_fields INTO DATA(lv_keyfld).
        ASSIGN COMPONENT lv_keyfld OF STRUCTURE <ls_row> TO <val>.
        IF sy-subrc = 0 AND <val> IS INITIAL.
          " Ghi lỗi
          ls_error-row_idx   = lv_idx.
          ls_error-fieldname = lv_keyfld.
          ls_error-msg       = TEXT-098. " Trường khóa &1 đang rỗng
          REPLACE '&1' IN ls_error-msg WITH lv_keyfld.
          APPEND ls_error TO gt_val_errors.
        ENDIF.
      ENDLOOP.
    ENDIF.

    " ---------------------------------------------------------
    " 2. KIỂM TRA TRÙNG KHÓA (DUPLICATE) TRÊN LƯỚI
    " ---------------------------------------------------------
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      CLEAR lv_fp.
      PERFORM build_key_fingerprint USING <ls_row> gt_key_fields CHANGING lv_fp.

      IF lv_fp IS NOT INITIAL.
        READ TABLE lt_seen_fp TRANSPORTING NO FIELDS WITH KEY table_line = lv_fp.
        IF sy-subrc = 0.
          " Đã thấy key này trước đó -> Trùng
          ls_error-row_idx   = lv_idx.
          READ TABLE gt_key_fields INTO ls_error-fieldname INDEX 1. " Tô đỏ key đầu tiên
          ls_error-msg       = TEXT-156. " Trùng khóa trên lưới
          APPEND ls_error TO gt_val_errors.
        ELSE.
          INSERT lv_fp INTO TABLE lt_seen_fp.
        ENDIF.
      ENDIF.
    ENDIF.

    " ---------------------------------------------------------
    " 3. KIỂM TRA TRÙNG KHÓA DB (Chỉ check với dòng mới đủ khóa)
    " ---------------------------------------------------------
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      " Chỉ check nếu chưa bị lỗi rỗng/trùng lưới ở trên (để tiết kiệm DB call)
      " nếu lv_fp có dữ liệu nghĩa là đủ khóa
      IF lv_fp IS NOT INITIAL.
        CLEAR lv_where.
        PERFORM make_where_from_key USING <ls_row> gt_key_fields CHANGING lv_where lv_dummy.
        IF lv_where IS NOT INITIAL.
          SELECT SINGLE COUNT(*) FROM (p_tab) WHERE (lv_where) INTO @lv_exists.
          IF lv_exists > 0.
            ls_error-row_idx   = lv_idx.
            READ TABLE gt_key_fields INTO ls_error-fieldname INDEX 1.
            ls_error-msg       = TEXT-085. " Khóa đã tồn tại trong DB
            APPEND ls_error TO gt_val_errors.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    " ---------------------------------------------------------
    " 4. KIỂM TRA FOREIGN KEY (Check Table)
    " ---------------------------------------------------------
    DATA: lv_fk_err TYPE abap_bool, lv_fk_msg TYPE string.
    PERFORM validate_fk_row USING p_tab <ls_row> lv_idx CHANGING gt_val_errors.

  ENDLOOP.

  IF gt_val_errors IS NOT INITIAL.
    ev_has_error = abap_true.
  ENDIF.

ENDFORM.

" Helper check FK cho 1 dòng
FORM validate_fk_row USING iv_tab TYPE tabname
                           is_row TYPE any
                           iv_idx TYPE i
                     CHANGING ct_err LIKE gt_val_errors.

  DATA: lt_fk           TYPE STANDARD TABLE OF dd03l,
        ls_fk           TYPE dd03l,
        ls_err          LIKE LINE OF ct_err,
        lv_dummy_client TYPE sy-mandt.

  " Thêm biến để chứa câu lệnh WHERE động
  DATA: lv_where_sql TYPE string.

  FIELD-SYMBOLS <val> TYPE any.

  " Cache danh sách FK
  SELECT fieldname, checktable
    FROM dd03l
    INTO CORRESPONDING FIELDS OF TABLE @lt_fk
    WHERE tabname = @iv_tab AND checktable <> '' AND checktable <> '*' AND as4local = 'A'.

  LOOP AT lt_fk INTO ls_fk.
    ASSIGN COMPONENT ls_fk-fieldname OF STRUCTURE is_row TO <val>.
    IF sy-subrc = 0 AND <val> IS NOT INITIAL.
      TRY.
          " Tạo chuỗi điều kiện WHERE động
          lv_where_sql = |{ ls_fk-fieldname } = @<val>| ##NO_TEXT.

          SELECT SINGLE mandt FROM (ls_fk-checktable) INTO @lv_dummy_client
            WHERE (lv_where_sql).
          IF sy-subrc <> 0.
            ls_err-row_idx   = iv_idx.
            ls_err-fieldname = ls_fk-fieldname.
            ls_err-msg       = |{ TEXT-215 }: '{ <val> }' { TEXT-216 } { ls_fk-checktable }|.
            APPEND ls_err TO ct_err.
          ENDIF.
        CATCH cx_root.
      ENDTRY.
    ENDIF.
  ENDLOOP.
ENDFORM.

*---------------------------------------------------------------------*
* FORM highlight_error_cells
* Tô màu đỏ (Color 6) cho các ô bị lỗi, reset màu cũ
*---------------------------------------------------------------------*
FORM highlight_error_cells.
  FIELD-SYMBOLS: <lt_data>   TYPE STANDARD TABLE,
                 <ls_row>    TYPE any,
                 <row_color> TYPE lvc_t_scol.
  DATA: ls_scol TYPE lvc_s_scol.

  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS INITIAL. RETURN. ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_row>.
    ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls_row> TO <row_color>.
    IF sy-subrc <> 0. CONTINUE. ENDIF.

    " 1. Xóa sạch màu cũ
    CLEAR <row_color>.

    " 2. Chỉ tô ĐỎ dựa trên danh sách lỗi đã Validate
    LOOP AT gt_val_errors INTO DATA(ls_err) WHERE row_idx = sy-tabix.

      " Kiểm tra xem ô này đã có màu chưa
      READ TABLE <row_color> TRANSPORTING NO FIELDS
           WITH KEY fname = ls_err-fieldname.

      IF sy-subrc <> 0.
        CLEAR ls_scol.
        ls_scol-fname     = ls_err-fieldname.
        ls_scol-color-col = 6. " Màu ĐỎ (Red)
        ls_scol-color-int = 1. " Đậm
        ls_scol-color-inv = 0.
        INSERT ls_scol INTO TABLE <row_color>.
      ENDIF.
    ENDLOOP.

  ENDLOOP.
ENDFORM.

FORM show_validation_log.
  IF gt_val_errors IS INITIAL. RETURN. ENDIF.

  DATA: lt_disp TYPE STANDARD TABLE OF ty_val_error.
  lt_disp = gt_val_errors.

  DATA: lo_alv TYPE REF TO cl_salv_table.

  TRY.
      cl_salv_table=>factory(
        IMPORTING r_salv_table = lo_alv
        CHANGING  t_table      = lt_disp ).

      lo_alv->get_functions( )->set_all( abap_true ).

      " Thiết lập tên cột
      DATA(lo_cols) = lo_alv->get_columns( ).
      lo_cols->set_optimize( abap_true ).

      " Catch exception khi get_column ---
      lo_cols->get_column( 'ROW_IDX' )->set_short_text( 'Row' ).
      lo_cols->get_column( 'FIELDNAME' )->set_short_text(  'Field'  ).
      lo_cols->get_column( 'MSG' )->set_short_text(  'Message' ).

      lo_alv->set_screen_popup(
        start_column = 10 end_column  = 100
        start_line   = 5  end_line    = 20 ).

      lo_alv->display( ).

      " Bắt thêm CX_SALV_NOT_FOUND và CX_SALV_EXISTING
    CATCH cx_salv_msg cx_salv_not_found cx_salv_existing INTO DATA(lx_salv).
      MESSAGE lx_salv->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.


"===== ZFA25SAP23_DB =====

" Tạo itab động dựa trên tên bảng
FORM ensure_dyn_itab USING iv_tab TYPE tabname
                     CHANGING cr_tab TYPE REF TO data.

  " Nếu đã có thì thôi
  IF cr_tab IS NOT INITIAL.
    CLEAR sy-subrc.
    RETURN.
  ENDIF.

  DATA lo_any    TYPE REF TO cl_abap_typedescr.
  DATA lo_struct TYPE REF TO cl_abap_structdescr.
  DATA lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Chuẩn hóa tên bảng (đề phòng nhập thường)
  DATA(lv_tab) = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  TRY.
      lo_any = cl_abap_typedescr=>describe_by_name( lv_tab ).
    CATCH cx_root.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_struct ?= lo_any.
    CATCH cx_sy_move_cast_error.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).
      CREATE DATA cr_tab TYPE HANDLE lo_tab.
      CLEAR sy-subrc.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

"===== Load dữ liệu từ DB vào itab =====
FORM load_data USING    iv_tab TYPE tabname
                        iv_max TYPE i
               CHANGING cr_tab TYPE REF TO data
                        ev_rows TYPE i
                        ev_err  TYPE string.

  CLEAR: ev_rows, ev_err.

  " Chuẩn hóa tên bảng
  DATA(lv_tabname) = iv_tab.
  TRANSLATE lv_tabname TO UPPER CASE.

  " Validate DDIC
  TRY.
      DATA(lo_descr) = cl_abap_typedescr=>describe_by_name( lv_tabname ).
      IF lo_descr IS INITIAL.
        ev_err = TEXT-118. " Table &1 does not exist...
        REPLACE '&1' IN ev_err WITH lv_tabname.
        RETURN.
      ENDIF.
    CATCH cx_sy_create_data_error.
      ev_err = TEXT-119. " Error creating type...
      REPLACE '&1' IN ev_err WITH lv_tabname.
      RETURN.
  ENDTRY.

  " Tạo itab động theo DDIC nếu chưa có
  PERFORM ensure_dyn_itab USING lv_tabname CHANGING cr_tab.

  FIELD-SYMBOLS: <lt_load> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_load>.
  IF <lt_load> IS NOT ASSIGNED.
    ev_err = TEXT-120. " Cannot assign dynamic itab
    RETURN.
  ENDIF.

  " Refresh dữ liệu
  REFRESH <lt_load>.

  TRY.
      "--- Kiểm tra quyền truy cập theo authorization group ---
      DATA lv_authgrp TYPE tddat-cclass.
      CLEAR lv_authgrp.

      SELECT SINGLE cclass
        FROM tddat
        INTO @lv_authgrp
       WHERE tabname = @lv_tabname.

      IF sy-subrc = 0 AND lv_authgrp IS NOT INITIAL.
        AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
             ID 'DICBERCLS' FIELD lv_authgrp
             ID 'ACTVT'     FIELD '03'.
        IF sy-subrc <> 0.
          ev_err = TEXT-121. " No authorization...
          REPLACE '&1' IN ev_err WITH lv_tabname.
          REPLACE '&2' IN ev_err WITH lv_authgrp.
          RETURN.
        ENDIF.
      ENDIF.


      "=== Load dữ liệu chính (Dựa hoàn toàn vào SQL ORDER BY) ===
      " SQL đảm bảo thứ tự cha-con đúng (1-1, 1-2...)
      IF iv_max > 0.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          UP TO @iv_max ROWS
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ENDIF.
      ev_rows = sy-dbcnt.

      "=== Bổ sung 6 field audit nếu bảng gốc không có ===
      DATA: lo_tab_audit  TYPE REF TO cl_abap_tabledescr,
            lo_line_audit TYPE REF TO cl_abap_structdescr,
            lt_comp       TYPE abap_component_tab.

      lo_tab_audit ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
      lo_line_audit ?= lo_tab_audit->get_table_line_type( ).
      lt_comp = lo_line_audit->get_components( ).

      " Lấy danh sách field hiện có trong DDIC
      DATA: lt_dd03l    TYPE TABLE OF dd03l,
            lt_existing TYPE TABLE OF fieldname,
            lv_field    TYPE fieldname.

      SELECT fieldname
        FROM dd03l
        INTO TABLE @lt_dd03l
        WHERE tabname = @lv_tabname
          AND as4local = 'A'.

      LOOP AT lt_dd03l ASSIGNING FIELD-SYMBOL(<fld>).
        APPEND <fld>-fieldname TO lt_existing.
      ENDLOOP.

      DATA lt_audit_fields TYPE TABLE OF string WITH EMPTY KEY.
      APPEND 'ERDAT' TO lt_audit_fields.
      APPEND 'ERTIM' TO lt_audit_fields.
      APPEND 'ERNAM' TO lt_audit_fields.
      APPEND 'AEDAT' TO lt_audit_fields.
      APPEND 'AETIM' TO lt_audit_fields.
      APPEND 'AENAM' TO lt_audit_fields.

      LOOP AT lt_audit_fields INTO lv_field.
        READ TABLE lt_existing WITH KEY table_line = lv_field TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CASE lv_field.
            WHEN 'ERDAT'.
              PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
            WHEN 'ERTIM'.
              PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
            WHEN 'ERNAM'.
              PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AEDAT'.
              PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AETIM'.
              PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AENAM'.
              PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
              APPEND lv_field TO gt_added_audit_fields.
          ENDCASE.
        ENDIF.
      ENDLOOP.

      "=== Rebuild lại itab theo cấu trúc mới (AN TOÀN KIỂU) ===
      DATA lo_new_struct TYPE REF TO cl_abap_structdescr.
      DATA lo_new_tab    TYPE REF TO cl_abap_tabledescr.

      lo_new_struct = cl_abap_structdescr=>create( lt_comp ).
      lo_new_tab    = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

      DATA lr_new TYPE REF TO data.
      CREATE DATA lr_new TYPE HANDLE lo_new_tab.

      FIELD-SYMBOLS: <lt_new>  TYPE STANDARD TABLE,
                     <row_old> TYPE any,
                     <row_new> TYPE any.
      ASSIGN lr_new->* TO <lt_new>.

      LOOP AT <lt_load> ASSIGNING <row_old>.
        APPEND INITIAL LINE TO <lt_new> ASSIGNING <row_new>.
        MOVE-CORRESPONDING <row_old> TO <row_new>.
      ENDLOOP.

      " đổi tham chiếu sang bảng mới
      cr_tab = lr_new.
      UNASSIGN <lt_load>.
      ASSIGN cr_tab->* TO <lt_load>.



    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động ===
  IF <lt_load> IS ASSIGNED AND <lt_load> IS NOT INITIAL.
    PERFORM merge_audit_log USING lv_tabname CHANGING <lt_load>.
  ENDIF.

  "=== Snapshot gốc để so sánh khi SAVE ===
  FIELD-SYMBOLS: <lt_orig>  TYPE STANDARD TABLE,
                 <ls_src_o> TYPE any,
                 <ls_dst_o> TYPE any.

  IF gr_data_original IS NOT INITIAL.
    FREE gr_data_original.
  ENDIF.
  CREATE DATA gr_data_original LIKE <lt_load>.

  ASSIGN gr_data_original->* TO <lt_orig>.
  REFRESH <lt_orig>.

  LOOP AT <lt_load> ASSIGNING <ls_src_o>.
    APPEND INITIAL LINE TO <lt_orig> ASSIGNING <ls_dst_o>.
    MOVE-CORRESPONDING <ls_src_o> TO <ls_dst_o>.
  ENDLOOP.

  "=== Nếu không có dữ liệu, thêm dòng trống để ALV không lỗi ===
  IF <lt_load> IS ASSIGNED AND <lt_load> IS INITIAL.
    APPEND INITIAL LINE TO <lt_load>.
    DELETE <lt_load> INDEX 1.
  ENDIF.

ENDFORM.


FORM save_data USING iv_tab TYPE tabname
               CHANGING cr_tab TYPE REF TO data
                        ev_mod TYPE i
                        ev_err TYPE string.

  ev_mod = 0.
  CLEAR ev_err.

  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_alv>.
  IF <lt_alv> IS NOT ASSIGNED OR <lt_alv> IS INITIAL.
*    ev_err = 'Không có dữ liệu để lưu.'.
    ev_err = TEXT-086.

    RETURN.
  ENDIF.

  "=== Fill audit fields tự động (ERDAT/ERTIM/ERNAM/AEDAT/AETIM/AENAM)
  FIELD-SYMBOLS: <ls_row> TYPE any,
                 <newrec> TYPE any,
                 <erdat>  TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                 <aedat>  TYPE any, <aetim> TYPE any, <aenam> TYPE any.

  LOOP AT <lt_alv> ASSIGNING <ls_row>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_row> TO <newrec>.
    ASSIGN COMPONENT 'ERDAT'  OF STRUCTURE <ls_row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM'  OF STRUCTURE <ls_row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM'  OF STRUCTURE <ls_row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT'  OF STRUCTURE <ls_row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM'  OF STRUCTURE <ls_row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM'  OF STRUCTURE <ls_row> TO <aenam>.

    " Dòng mới -> chỉ set Created* nếu có cột và còn trống
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.
    ENDIF.
    " Mọi trường hợp lưu -> set Changed*
    IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.
  ENDLOOP.

  "=== Build itab phẳng theo DDIC rồi upsert
  DATA lr_db_struct TYPE REF TO cl_abap_structdescr.
  DATA lr_db_table  TYPE REF TO cl_abap_tabledescr.
  DATA lr_flat      TYPE REF TO data.
  FIELD-SYMBOLS: <lt_flat> TYPE STANDARD TABLE,
                 <ls_flat> TYPE any,
                 <ls_alv>  TYPE any.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  lr_db_table = cl_abap_tabledescr=>create( p_line_type = lr_db_struct ).
  CREATE DATA lr_flat TYPE HANDLE lr_db_table.
  ASSIGN lr_flat->* TO <lt_flat>.

  LOOP AT <lt_alv> ASSIGNING <ls_alv>.
    APPEND INITIAL LINE TO <lt_flat> ASSIGNING <ls_flat>.
    MOVE-CORRESPONDING <ls_alv> TO <ls_flat>.

    FIELD-SYMBOLS <mandt> TYPE any.
    ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_flat> TO <mandt>.
    IF sy-subrc = 0 AND <mandt> IS ASSIGNED.
      <mandt> = sy-mandt.
    ENDIF.
  ENDLOOP.

  TRY.
      MODIFY (iv_tab) FROM TABLE <lt_flat>.
      ev_mod = sy-dbcnt.
    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== (tuỳ chọn) Ghi log audit chi tiết theo dòng
* IF ev_mod > 0.
*   LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv_row>).
*     PERFORM log_audit_action USING iv_tab 'U' <ls_alv_row>.
*   ENDLOOP.
* ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM log_audit_action - Ghi log thêm/sửa vào ZEDIT_AUDIT_LOG
*---------------------------------------------------------------------*
FORM log_audit_action USING iv_tabname TYPE tabname
                            iv_action  TYPE c
                            is_row     TYPE any.

  DATA: ls_log    TYPE zedit_audit_log,
        ls_old    TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        lv_ts_utc TYPE timestampl,
        lv_date   TYPE sydatum,
        lv_time   TYPE syuzeit.

  " Khóa log (chuẩn hóa theo key DDIC)
  PERFORM build_key_audit USING is_row CHANGING lv_key.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Lấy timestamp UTC hiện tại + convert sang giờ hiển thị
  GET TIME STAMP FIELD lv_ts_utc.
  PERFORM get_view_tzone CHANGING lv_tzone.
  CONVERT TIME STAMP lv_ts_utc TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.

  CLEAR ls_log.
  ls_log-mandt     = sy-mandt.
  ls_log-tabname   = lv_tab_up.
  ls_log-keyval    = lv_key.
  ls_log-action    = iv_action.

  " Upsert
  SELECT SINGLE * INTO @ls_old
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
      AND keyval  = @lv_key.

  IF sy-subrc <> 0.
    " ---- CHƯA CÓ LOG: chèn mới ----
    " Luôn set Created* cho lần đầu tiên
    ls_log-erdat       = lv_date.
    ls_log-ertim       = lv_time.
    ls_log-ernam       = sy-uname.
    ls_log-crt_ts_utc  = lv_ts_utc.



    INSERT zedit_audit_log FROM ls_log.

  ELSE.
    " ---- ĐÃ CÓ LOG: cập nhật Changed* khi action = 'U' ----
    IF iv_action = 'U'.
      UPDATE zedit_audit_log
         SET aedat      = @lv_date,
             aetim      = @lv_time,
             aenam      = @sy-uname,
             chg_ts_utc = @lv_ts_utc
       WHERE tabname    = @lv_tab_up
         AND keyval     = @lv_key.
    ENDIF.
  ENDIF.

  COMMIT WORK AND WAIT. "persist ngay để lần load sau/merge đọc được

ENDFORM.


FORM add_field_if_missing USING iv_name TYPE fieldname
                                 iv_type TYPE c
                                 iv_len  TYPE i
                         CHANGING ct_comp TYPE abap_component_tab.

  DATA ls_comp TYPE abap_componentdescr.
  DATA lv_type4 TYPE c LENGTH 4.

  lv_type4 = iv_type.  " Gán 4 ký tự đầu vào biến cố định

  " Kiểm tra field đã tồn tại chưa
  READ TABLE ct_comp WITH KEY name = iv_name TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    RETURN.
  ENDIF.

  CLEAR ls_comp.
  ls_comp-name = iv_name.

  CASE lv_type4.
    WHEN 'DATS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
    WHEN 'TIMS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
    WHEN 'CHAR'.
      ls_comp-type ?= cl_abap_elemdescr=>get_c( iv_len ).
    WHEN OTHERS.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( lv_type4 ).
  ENDCASE.

  APPEND ls_comp TO ct_comp.

ENDFORM.

*---------------------------------------------------------------------*
* FORM merge_audit_log - Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động
*---------------------------------------------------------------------*
FORM merge_audit_log USING    iv_tabname TYPE tabname
                     CHANGING ct_data    TYPE STANDARD TABLE.

  DATA: lt_audit  TYPE STANDARD TABLE OF zedit_audit_log,
        ls_audit  TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        d1        TYPE sydatum,
        t1        TYPE syuzeit,
        d2        TYPE sydatum,
        t2        TYPE syuzeit.

  FIELD-SYMBOLS: <row>   TYPE any,
                 <erdat> TYPE any,
                 <ertim> TYPE any,
                 <ernam> TYPE any,
                 <aedat> TYPE any,
                 <aetim> TYPE any,
                 <aenam> TYPE any.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Đọc log mới nhất
  SELECT *
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
    INTO TABLE @lt_audit
    BYPASSING BUFFER.

  PERFORM get_view_tzone CHANGING lv_tzone.

  LOOP AT ct_data ASSIGNING <row>.

    CLEAR lv_key.
    PERFORM build_key_audit USING <row> CHANGING lv_key.
    IF lv_key IS INITIAL.
      CONTINUE.
    ENDIF.

    " --- Tìm log theo key ---
    CLEAR ls_audit.
    READ TABLE lt_audit INTO ls_audit
         WITH KEY tabname = lv_tab_up keyval = lv_key.
    IF sy-subrc <> 0.
      " Không có log → dùng dữ liệu từ DB (hoặc fallback nếu trống)
      PERFORM fallback_audit_fields CHANGING <row>.
      CONTINUE.
    ENDIF.

    " --- Kiểm tra log có hợp lệ không? ---
    " Nếu cả crt_ts_utc và chg_ts_utc đều = 0 → log lỗi → bỏ qua
    IF ls_audit-crt_ts_utc IS INITIAL AND ls_audit-chg_ts_utc IS INITIAL.
      PERFORM fallback_audit_fields CHANGING <row>.
      CONTINUE.
    ENDIF.

    " --- Chuyển đổi timestamp ---
    CLEAR: d1, t1, d2, t2.
    IF ls_audit-crt_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-crt_ts_utc TIME ZONE lv_tzone INTO DATE d1 TIME t1.
    ENDIF.
    IF ls_audit-chg_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-chg_ts_utc TIME ZONE lv_tzone INTO DATE d2 TIME t2.
    ENDIF.

    " --- Gán field ---
    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM' OF STRUCTURE <row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM' OF STRUCTURE <row> TO <aenam>.

    " Created*
    IF <erdat> IS ASSIGNED.
      <erdat> = COND #( WHEN d1 IS NOT INITIAL THEN d1 ELSE ls_audit-erdat ).
    ENDIF.
    IF <ertim> IS ASSIGNED.
      <ertim> = COND #( WHEN t1 IS NOT INITIAL THEN t1 ELSE ls_audit-ertim ).
    ENDIF.
    IF <ernam> IS ASSIGNED.
      <ernam> = COND string( WHEN ls_audit-ernam IS NOT INITIAL THEN ls_audit-ernam ELSE sy-uname ).
    ENDIF.

    " Changed*
    IF <aedat> IS ASSIGNED.
      <aedat> = COND #( WHEN d2 IS NOT INITIAL THEN d2 ELSE <aedat> ).
    ENDIF.
    IF <aetim> IS ASSIGNED.
      <aetim> = COND #( WHEN t2 IS NOT INITIAL THEN t2 ELSE <aetim> ).
    ENDIF.
    IF <aenam> IS ASSIGNED.
      <aenam> = COND string( WHEN ls_audit-aenam IS NOT INITIAL THEN ls_audit-aenam ELSE <aenam> ).
    ENDIF.

  ENDLOOP.

ENDFORM.

FORM build_key_audit USING    is_row TYPE any
                     CHANGING ev_key TYPE string.

  DATA lv_val TYPE string.
  CLEAR ev_key.

  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kname>).
    ASSIGN COMPONENT <kname> OF STRUCTURE is_row TO FIELD-SYMBOL(<f>).
    IF sy-subrc = 0 AND <f> IS ASSIGNED.
      lv_val = <f>.
      CONDENSE lv_val NO-GAPS.
      IF ev_key IS INITIAL.
        ev_key = lv_val.
      ELSE.
        CONCATENATE ev_key lv_val INTO ev_key SEPARATED BY '|'.
      ENDIF.
    ENDIF.
  ENDLOOP.

  TRANSLATE ev_key TO UPPER CASE.
ENDFORM.

FORM get_view_tzone CHANGING ev_tzone TYPE ttzz-tzone.
  CLEAR ev_tzone.
  IF sy-zonlo IS NOT INITIAL.
    ev_tzone = sy-zonlo.
    RETURN.
  ENDIF.

  " hệ thống (nếu có cài đặt)
  DATA(lv_sys_tz) = VALUE ttzz-tzone( ).
  CALL FUNCTION 'GET_SYSTEM_TIMEZONE'
    IMPORTING
      timezone = lv_sys_tz
    EXCEPTIONS
      OTHERS   = 1.
  IF sy-subrc = 0 AND lv_sys_tz IS NOT INITIAL.
    ev_tzone = lv_sys_tz.
  ELSE.
    ev_tzone = 'UTC'.
  ENDIF.
ENDFORM.

FORM ts_utc_to_local USING    iv_ts_utc TYPE timestampl
                              iv_tzone  TYPE ttzz-tzone
                     CHANGING ev_date   TYPE sydatum
                              ev_time   TYPE syuzeit.
  CLEAR: ev_date, ev_time.
  IF iv_ts_utc IS INITIAL.
    RETURN.
  ENDIF.
  CONVERT TIME STAMP iv_ts_utc TIME ZONE iv_tzone
         INTO DATE ev_date TIME ev_time.
ENDFORM.

FORM dedup_fieldcat .

  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.

  "===== Khai báo cấu trúc tạm lưu field đã gặp =====
  TYPES: BEGIN OF ty_seen,
           fieldname TYPE lvc_fname,
           idx       TYPE i,    " vị trí trong gt_fieldcat (để xóa)
           score     TYPE i,    " điểm ưu tiên
         END OF ty_seen.

  DATA: lt_seen TYPE STANDARD TABLE OF ty_seen WITH DEFAULT KEY,
        ls_seen TYPE ty_seen.

  DATA: lt_del TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_idx TYPE i,
        lv_scr TYPE i.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    lv_idx = sy-tabix.

    IF <fc>-fieldname IS INITIAL.
      CONTINUE.
    ENDIF.

    "===== Tính điểm ưu tiên cho field hiện tại =====
    CLEAR lv_scr.
    IF <fc>-coltext   IS NOT INITIAL. lv_scr = lv_scr + 4. ENDIF.
    IF <fc>-scrtext_l IS NOT INITIAL. lv_scr = lv_scr + 2. ENDIF.
    IF <fc>-scrtext_m IS NOT INITIAL. lv_scr = lv_scr + 1. ENDIF.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      lv_scr = lv_scr - 1.
    ENDIF.

    "===== Kiểm tra xem field này đã có chưa =====
    READ TABLE lt_seen INTO ls_seen WITH KEY fieldname = <fc>-fieldname.
    IF sy-subrc <> 0.
      " Lần đầu gặp field này
      CLEAR ls_seen.
      ls_seen-fieldname = <fc>-fieldname.
      ls_seen-idx       = lv_idx.
      ls_seen-score     = lv_scr.
      APPEND ls_seen TO lt_seen.
    ELSE.
      " Đã gặp rồi → chọn giữ bản tốt hơn
      IF lv_scr > ls_seen-score.
        " Bản mới tốt hơn → xóa bản cũ
        APPEND ls_seen-idx TO lt_del.
        ls_seen-idx   = lv_idx.
        ls_seen-score = lv_scr.
        MODIFY lt_seen FROM ls_seen TRANSPORTING idx score WHERE fieldname = ls_seen-fieldname.
      ELSE.
        " Bản mới kém hơn → xóa bản hiện tại
        APPEND lv_idx TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  "===== Xóa an toàn theo thứ tự giảm dần =====
  SORT lt_del DESCENDING.
  LOOP AT lt_del INTO lv_idx.
    IF lv_idx GT 0 AND lv_idx LE lines( gt_fieldcat ).
      DELETE gt_fieldcat INDEX lv_idx.
    ENDIF.
  ENDLOOP.

ENDFORM.


FORM normalize_itab_type CHANGING cr_tab TYPE REF TO data.
  DATA lo_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_line TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL. RETURN. ENDIF.
  ASSIGN cr_tab->* TO <lt_old>.
  IF <lt_old> IS INITIAL. RETURN. ENDIF.

  lo_tab  ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).

  DATA(lo_newline) = cl_abap_structdescr=>create( lt_comp ).
  DATA(lo_newtab)  = cl_abap_tabledescr=>create( lo_newline ).

  DATA lr_new TYPE REF TO data.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.

FORM delete_audit_log USING iv_tabname TYPE tabname
                            is_row     TYPE any
                   CHANGING ev_err     TYPE string.

  DATA: lv_key    TYPE string,
        lv_tab_up TYPE tabname.

  CLEAR ev_err.

  " Build keyval từ row bị delete
  PERFORM build_key_audit USING is_row CHANGING lv_key.
  IF lv_key IS INITIAL.
    ev_err = TEXT-122.
    RETURN.
  ENDIF.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Xóa log tương ứng
  DELETE FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
      AND keyval  = @lv_key.


  IF sy-subrc = 0.
    COMMIT WORK AND WAIT.
  ELSEIF sy-subrc = 4.

    CLEAR ev_err.
  ELSE.

    ev_err = TEXT-123.
    REPLACE '&1' IN ev_err WITH lv_key.
  ENDIF.

ENDFORM.

FORM fallback_audit_fields CHANGING cs_row TYPE any.

  FIELD-SYMBOLS: <erdat>  TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                 <aedat>  TYPE any, <aetim> TYPE any, <aenam> TYPE any,
                 <newrec> TYPE any.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE cs_row TO <newrec>.
  ASSIGN COMPONENT 'ERDAT'  OF STRUCTURE cs_row TO <erdat>.
  ASSIGN COMPONENT 'ERTIM'  OF STRUCTURE cs_row TO <ertim>.
  ASSIGN COMPONENT 'ERNAM'  OF STRUCTURE cs_row TO <ernam>.
  ASSIGN COMPONENT 'AEDAT'  OF STRUCTURE cs_row TO <aedat>.
  ASSIGN COMPONENT 'AETIM'  OF STRUCTURE cs_row TO <aetim>.
  ASSIGN COMPONENT 'AENAM'  OF STRUCTURE cs_row TO <aenam>.

  DATA: lv_tzone TYPE ttzz-tzone,
        lv_ts    TYPE timestampl,
        lv_date  TYPE sydatum,
        lv_time  TYPE syuzeit.

  PERFORM get_view_tzone CHANGING lv_tzone.
  GET TIME STAMP FIELD lv_ts.
  PERFORM ts_utc_to_local USING lv_ts lv_tzone CHANGING lv_date lv_time.

  " Nếu là NEWREC → fill Created*
  IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
    IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = lv_date. ENDIF.
    IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = lv_time. ENDIF.
    IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.
  ENDIF.

  " Luôn fill Created* nếu trống (vì vừa load từ DB)
"IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = lv_date. ENDIF.
 " IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = lv_time. ENDIF.
  "IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.

ENDFORM.


"===== ZFA25SAP23_MAIN =====

START-OF-SELECTION.

  DATA: lv_rows_main TYPE i,
        lv_err_main  TYPE string,
        lt_meta      TYPE ddfields. " metadata chi tiết

  " 1. Lấy metadata đầy đủ từ DDIC
  PERFORM get_metadata USING p_tab CHANGING lt_meta.

  " 2. Tạo itab động cho bảng p_tab
  PERFORM create_dynamic_itab USING p_tab CHANGING gr_data.

  " 3. Load dữ liệu từ DB
  PERFORM load_data USING p_tab p_maxrow
    CHANGING gr_data lv_rows_main lv_err_main.

  " Nếu có lỗi thật sự (SQL lỗi, bảng không tồn tại, v.v.)
  IF lv_err_main IS NOT INITIAL.
    MESSAGE lv_err_main TYPE 'E'.
    RETURN.
  ENDIF.

  " Nếu load thành công nhưng không có bản ghi → chỉ báo nhẹ, KHÔNG chặn chương trình
  IF lv_rows_main = 0.
*  MESSAGE 'Không có dữ liệu trong bảng, hiển thị khung trống.' TYPE 'S' DISPLAY LIKE 'I'.
    lv_msg = TEXT-124.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'I'.

  ENDIF.

  " 4. Merge audit log ngay sau khi load
  FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <lt_data>.
  PERFORM ensure_keys USING p_tab.
  IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
    PERFORM merge_audit_log USING p_tab CHANGING <lt_data>.
  ENDIF.

  " 5. Tạo fieldcatalog cho ALV
  PERFORM build_fieldcat_all.

  " 6. Đồng bộ fieldcatalog với itab động
  PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.

  " 7. Đưa ERDAT về ngay trước nhóm Created*/Changed*
  PERFORM reorder_audit_cols CHANGING gt_fieldcat.
PERFORM sort_current_view_by_ddic_key.

  " 8. Gọi screen hiển thị ALV
  CALL SCREEN 100.


  