*&---------------------------------------------------------------------*
*& Report ZFA25SAP23
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zfa25sap23.

INCLUDE zfa25sap23_top.     "Khai báo biến toàn cục, TYPE, constant
INCLUDE zfa25sap23_sel.     "Selection screen
INCLUDE zfa25sap23_auth.    "Check whitelist + AUTHORITY-CHECK
INCLUDE zfa25sap23_ddic.    "Metadata + RTTC/RTTS + fieldcatalog
INCLUDE zfa25sap23_alv.     "ALV show + event
INCLUDE zfa25sap23_io.      "Upload/Download CSV, clipboard
INCLUDE zfa25sap23_audit.   "Audit log + rollback
INCLUDE zfa25sap23_db.      "Load/Save DB
INCLUDE zfa25sap23_main.    "START-OF-SELECTION + flow chính
INCLUDE zfa25sap23_f01.     "FORM rollBack"
*&---------------------------------------------------------------------*

"===== INCLUDE ZFA25SAP23_TOP =====
" Global declarations dùng chung cho DB/ALV/MAIN

CONSTANTS gc_hard_rcpt TYPE ad_smtpadr VALUE 'thanhchse171611@fpt.edu.vn'. " mail nhận cố định

TYPE-POOLS: abap.
CLASS lcl_alv_handler DEFINITION DEFERRED.

DATA: gv_toolbar_mode TYPE c LENGTH 1 VALUE 'D'. " 'D' = display, 'E' = edit

"––– Dữ liệu động (itab) cho mọi bảng
DATA: gr_data TYPE REF TO data.
FIELD-SYMBOLS: <gt_data> TYPE STANDARD TABLE,
               <gs_wa>   TYPE any.
"––– Ghi log lỗi chi tiết để hiển thị + debug + tô màu
TYPES: BEGIN OF ty_error_log,
         row   TYPE i,
         col   TYPE i,
         field TYPE fieldname,
         value TYPE string,
         msg   TYPE string,
       END OF ty_error_log,
       ty_t_error_log TYPE STANDARD TABLE OF ty_error_log WITH DEFAULT KEY.

DATA: gt_error_log TYPE ty_t_error_log.
DATA gv_keys_tabname TYPE tabname.

"––– Cấu trúc style để highlight lỗi trong ALV
TYPES: BEGIN OF ty_cell_style,
         fieldname TYPE fieldname,
         style     TYPE lvc_s_styl,
       END OF ty_cell_style,
       ty_t_celltab TYPE STANDARD TABLE OF ty_cell_style WITH DEFAULT KEY.


"––– ALV objects & cấu hình
DATA: g_container TYPE REF TO cl_gui_custom_container,
      g_alv_grid  TYPE REF TO cl_gui_alv_grid,
      g_okcode    TYPE sy-ucomm,
      g_handler   TYPE REF TO lcl_alv_handler,
      gv_edit_md  TYPE abap_bool VALUE abap_false. " =SPACE: VIEW, 'X': EDIT

DATA: gt_fieldcat TYPE lvc_t_fcat,
      gs_fieldcat TYPE lvc_s_fcat,
      gs_layout   TYPE lvc_s_layo.
TYPES: ty_fieldnames TYPE STANDARD TABLE OF fieldname WITH EMPTY KEY.
DATA: gt_fieldnames TYPE ty_fieldnames.
CONSTANTS: gc_cc_alv TYPE scrfname VALUE 'CC_ALV'.

DATA: gv_add_mode TYPE abap_bool VALUE abap_false.

"Cache danh sách trường khoá
DATA gt_key_fields TYPE STANDARD TABLE OF dd03l-fieldname WITH DEFAULT KEY.

"Buffer audit
TYPES: BEGIN OF ty_audit,
         logid       TYPE char32,
         uname       TYPE syuname,
         udate       TYPE sydatum,
         utime       TYPE syuzeit,
         tabname     TYPE tabname,
         action      TYPE char10,
         before_json TYPE zde_json_txt,
         after_json  TYPE zde_json_txt,
       END OF ty_audit.
DATA gt_audit TYPE STANDARD TABLE OF ty_audit WITH DEFAULT KEY.

DATA gv_dirty TYPE abap_bool VALUE abap_false.
DATA gv_del_newrec_only TYPE abap_bool VALUE abap_false.
DATA: gv_dirty_nonnewrec TYPE abap_bool VALUE abap_false.

TYPES: ty_fname TYPE lvc_fname.
DATA: gt_f4_whitelist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line,
      gt_f4_blacklist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line.

"===== INCLUDE ZFA25SAP23_SEL =====

" Khối tham số
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-001.
  PARAMETERS:
    p_tab    TYPE tabname OBLIGATORY, "Bảng Z*
    p_maxrow TYPE i DEFAULT 200.
SELECTION-SCREEN END OF BLOCK b1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tab.
  PERFORM f4_tabname.

  " Validate cơ bản

AT SELECTION-SCREEN.
  " p_maxrow > 0
  IF p_maxrow IS INITIAL OR p_maxrow <= 0.
    MESSAGE e398(00) WITH 'p_maxrow phải > 0'.
  ENDIF.

  " p_tab là bảng Z* transparent và active trong DDIC
  SELECT SINGLE tabname
  FROM dd02l
  INTO @DATA(lv_tab)
  WHERE tabname = @p_tab
  AND tabclass = 'TRANSP'
  AND as4local = 'A'
  AND tabname LIKE 'Z%'.
  IF sy-subrc <> 0.
    MESSAGE e398(00) WITH |Bảng { p_tab } không hợp lệ (chỉ Z* active).|.
  ENDIF.

  "----------------- Subroutines -----------------

FORM f4_tabname.
  TYPES: BEGIN OF ty_tab, tabname TYPE dd02l-tabname, END OF ty_tab.
  DATA: lt_tabs TYPE STANDARD TABLE OF ty_tab,
        lt_ret  TYPE TABLE OF ddshretval.

  SELECT tabname
  FROM dd02l
  INTO TABLE lt_tabs
  WHERE tabname LIKE 'Z%'
  AND tabclass = 'TRANSP'
  AND as4local = 'A'
  ORDER BY tabname.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'TABNAME'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = 'P_TAB'
      value_org       = 'S'
    TABLES
      value_tab       = lt_tabs
      return_tab      = lt_ret
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
    READ TABLE lt_ret INDEX 1 INTO DATA(ls_ret).
    IF sy-subrc = 0.
      p_tab = ls_ret-fieldval.
    ENDIF.
  ENDIF.
ENDFORM.

*----------------------------------------------------------------------*
*  Include: ZFA25SAP23_AUTH
*----------------------------------------------------------------------*

FORM check_authorization .
  DATA: lv_can_create  TYPE abap_bool,
        lv_can_change  TYPE abap_bool,
        lv_can_delete  TYPE abap_bool,
        lv_can_display TYPE abap_bool.

  CLEAR: gv_edit_md, gv_toolbar_mode.

  "--- Kiểm tra quyền CREATE (01)
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '01'.
  IF sy-subrc = 0.
    lv_can_create = abap_true.
  ENDIF.

  "--- Kiểm tra quyền CHANGE (02)
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '02'.
  IF sy-subrc = 0.
    lv_can_change = abap_true.
  ENDIF.

  "--- Kiểm tra quyền DELETE (06)
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '06'.
  IF sy-subrc = 0.
    lv_can_delete = abap_true.
  ENDIF.

  "--- Kiểm tra quyền DISPLAY (03)
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '03'.
  IF sy-subrc = 0.
    lv_can_display = abap_true.
  ENDIF.

  "--- Xác định chế độ hiển thị tổng
  IF lv_can_change = abap_true OR lv_can_create = abap_true OR lv_can_delete = abap_true.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.   "Edit mode
  ELSE.
    gv_edit_md      = abap_false.
    gv_toolbar_mode = 'D'.   "Display mode
  ENDIF.

ENDFORM.


FORM has_actvt USING iv_act TYPE activ_auth CHANGING ev_ok TYPE abap_bool.
  ev_ok = abap_false.
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD iv_act.
  IF sy-subrc = 0.
    ev_ok = abap_true.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_DDIC
*&---------------------------------------------------------------------*
*& Xử lý metadata, tạo itab động và fieldcatalog
*&---------------------------------------------------------------------*

"=== Build fieldcatalog cho ALV ===
FORM build_fieldcat USING p_field p_text.
  CLEAR gs_fieldcat.
  gs_fieldcat-fieldname = p_field.
  gs_fieldcat-seltext = p_text. " Tiêu đề cột
    gs_fieldcat-scrtext_m = p_text.   " Tên trung bình
  gs_fieldcat-reptext   = p_text.   " Tên report
   gs_fieldcat-coltext   = p_text.
  APPEND gs_fieldcat TO gt_fieldcat.
ENDFORM.

FORM build_fieldcat_all .
  REFRESH: gt_fieldcat, gt_fieldnames.

  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name       = p_tab
    CHANGING
      ct_fieldcat            = gt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  " Ẩn field MANDT khỏi ALV nếu có
  LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fs_fcat>).
    IF <fs_fcat>-fieldname = 'MANDT'.
      <fs_fcat>-no_out = abap_true.
      <fs_fcat>-tech = abap_true.
    ENDIF.
  ENDLOOP.
  "=== Thêm 6 field audit ra cuối bảng ===
DATA lv_colpos TYPE i.

" Tính vị trí cột hiện có (để đẩy 6 field ra sau)
DESCRIBE TABLE gt_fieldcat LINES lv_colpos.

PERFORM build_fieldcat USING 'ERDAT' 'Created On'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs1>).
IF <fs1> IS ASSIGNED. <fs1>-col_pos = lv_colpos + 1. ENDIF.

PERFORM build_fieldcat USING 'ERTIM' 'Created Time'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs2>).
IF <fs2> IS ASSIGNED. <fs2>-col_pos = lv_colpos + 2. ENDIF.

PERFORM build_fieldcat USING 'ERNAM' 'Created By'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs3>).
IF <fs3> IS ASSIGNED. <fs3>-col_pos = lv_colpos + 3. ENDIF.

PERFORM build_fieldcat USING 'AEDAT' 'Changed On'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs4>).
IF <fs4> IS ASSIGNED. <fs4>-col_pos = lv_colpos + 4. ENDIF.

PERFORM build_fieldcat USING 'AETIM' 'Changed Time'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs5>).
IF <fs5> IS ASSIGNED. <fs5>-col_pos = lv_colpos + 5. ENDIF.

PERFORM build_fieldcat USING 'AENAM' 'Changed By'.
READ TABLE gt_fieldcat INDEX lines( gt_fieldcat ) ASSIGNING FIELD-SYMBOL(<fs6>).
IF <fs6> IS ASSIGNED. <fs6>-col_pos = lv_colpos + 6. ENDIF.

    IF sy-subrc <> 0 OR gt_fieldcat IS INITIAL.
    MESSAGE |Không tạo được fieldcatalog cho bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== Thêm field kỹ thuật CELLTAB cho ALV (ẩn đi)
  CLEAR gs_fieldcat.
  gs_fieldcat-fieldname = 'CELLTAB'.
  gs_fieldcat-col_pos = 999.
  gs_fieldcat-no_out = abap_true.
  gs_fieldcat-tech = abap_true.
  gs_fieldcat-inttype = 'L'.
  APPEND gs_fieldcat TO gt_fieldcat.
"=== Thêm field kỹ thuật ROW_COLOR cho ALV (ẩn đi, để tô màu dòng)
CLEAR gs_fieldcat.
gs_fieldcat-fieldname = 'ROW_COLOR'.
gs_fieldcat-col_pos = 1000.
gs_fieldcat-no_out   = abap_true.
gs_fieldcat-tech     = abap_true.
APPEND gs_fieldcat TO gt_fieldcat.

  "=== Build gt_fieldnames từ COLTEXT của fieldcat (caption ALV)
  CLEAR gt_fieldnames.
  LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fcat>).
    " Bỏ qua field kỹ thuật
    IF <fcat>-tech = abap_true OR <fcat>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    DATA(lv_name) = ``.
    " Lấy coltext gán cho ALV
    IF <fcat>-coltext IS NOT INITIAL.
      lv_name = <fcat>-coltext.
    ELSE.
      lv_name = <fcat>-fieldname.
    ENDIF.

    " Chuẩn hóa
    lv_name = to_upper( condense( lv_name ) ).
    CONDENSE lv_name NO-GAPS.

    APPEND lv_name TO gt_fieldnames.
  ENDLOOP.

  "=== Bật F4 cho mọi cột không kỹ thuật (chuẩn nếu DDIC có, dynamic nếu không)
  PERFORM enable_f4_in_fieldcat.


ENDFORM.



"=== Tạo itab động từ bảng p_tab ===
FORM create_dynamic_itab USING p_tabname TYPE tabname
CHANGING p_itab TYPE REF TO data.

  DATA: lo_descr TYPE REF TO cl_abap_structdescr,
        lo_table TYPE REF TO cl_abap_tabledescr.

  TRY.
      " Lấy mô tả cấu trúc của bảng p_tabname
      lo_descr ?= cl_abap_typedescr=>describe_by_name( p_tabname ).
      lo_table = cl_abap_tabledescr=>create( lo_descr ).
"=== Thêm 6 field audit tự động, tránh trùng tên ===
DATA: lt_components TYPE abap_component_tab,
      ls_component  TYPE abap_componentdescr,
      lt_names      TYPE STANDARD TABLE OF string.

DATA(lo_struct) = CAST cl_abap_structdescr( lo_table->get_table_line_type( ) ).
lt_components = lo_struct->get_components( ).

" Lấy danh sách field hiện có
LOOP AT lt_components INTO ls_component.
  APPEND ls_component-name TO lt_names.
ENDLOOP.

DEFINE add_field_if_missing.
  READ TABLE lt_names WITH KEY table_line = &1 TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_component.
    ls_component-name = &1.
    ls_component-type ?= cl_abap_elemdescr=>describe_by_name( &2 ).
    APPEND ls_component TO lt_components.
  ENDIF.
END-OF-DEFINITION.

add_field_if_missing 'ERDAT' 'DATS'.  " Created On
add_field_if_missing 'ERTIM' 'TIMS'.  " Created Time
add_field_if_missing 'ERNAM' 'UNAME'. " Created By
add_field_if_missing 'AEDAT' 'DATS'.  " Changed On
add_field_if_missing 'AETIM' 'TIMS'.  " Changed Time
add_field_if_missing 'AENAM' 'UNAME'. " Changed By

" Tạo lại mô tả cấu trúc có 6 field mới
DATA(lo_new_struct) = cl_abap_structdescr=>create( lt_components ).
DATA(lo_new_table)  = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

CREATE DATA p_itab TYPE HANDLE lo_new_table.

*      CREATE DATA p_itab TYPE HANDLE lo_table.

        CATCH cx_sy_create_data_error INTO DATA(lx_create).
      MESSAGE |Không tạo được itab động cho { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

ENDFORM.



*---------------------------------------------------------------------*
* Đồng bộ fieldcatalog với line type của itab động (gr_data)
*---------------------------------------------------------------------*
FORM sync_fcat_with_itab CHANGING ct_fcat TYPE lvc_t_fcat.

  DATA: lo_tab  TYPE REF TO cl_abap_tabledescr,
        lo_line TYPE REF TO cl_abap_structdescr,
        lt_comp TYPE abap_component_tab.

  IF gr_data IS INITIAL.
    RETURN.
  ENDIF.

  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( gr_data ).
  lo_line ?= CAST cl_abap_structdescr( lo_tab->get_table_line_type( ) ).
  lt_comp = lo_line->get_components( ).

  LOOP AT ct_fcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
    READ TABLE lt_comp WITH KEY name = <fs_fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE ct_fcat.
    ENDIF.
  ENDLOOP.

  " Sau khi sync có thể có cột bị xóa → bật lại F4 cho chắc
  PERFORM enable_f4_in_fieldcat.


ENDFORM.



FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
CHANGING er_data TYPE REF TO data.

  DATA: lt_dfies      TYPE TABLE OF dfies,
        lt_components TYPE cl_abap_structdescr=>component_table,
        ls_component  LIKE LINE OF lt_components.

  " Lấy metadata từ DDIC
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tabname
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " Lọc các trường không phải style (tên field thường là CELLTAB)
  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'. " Thay 'CELLTAB' nếu tên field style khác
    ls_component-name = ls_dfies-fieldname.
    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
    APPEND ls_component TO lt_components.
  ENDLOOP.

  " Tạo cấu trúc động
  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
  lr_struct_type = cl_abap_structdescr=>create( lt_components ).

  " Tạo internal table động
  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
  lr_table_type = cl_abap_tabledescr=>create(
  p_line_type = lr_struct_type
  p_table_kind = cl_abap_tabledescr=>tablekind_std ).
  CREATE DATA er_data TYPE HANDLE lr_table_type.

ENDFORM.
*FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
*CHANGING er_data TYPE REF TO data.
*
*  DATA: lt_dfies      TYPE TABLE OF dfies,
*        lt_components TYPE cl_abap_structdescr=>component_table,
*        ls_component  LIKE LINE OF lt_components.
*
*  " Lấy metadata từ DDIC
*  CALL FUNCTION 'DDIF_FIELDINFO_GET'
*    EXPORTING
*      tabname   = iv_tabname
*    TABLES
*      dfies_tab = lt_dfies
*    EXCEPTIONS
*      not_found = 1
*      OTHERS    = 2.
*  IF sy-subrc <> 0.
*    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  " Bổ sung các field thực từ DDIC
*  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'. " Bỏ qua CELLTAB nếu có
*    ls_component-name = ls_dfies-fieldname.
*    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
*    APPEND ls_component TO lt_components.
*  ENDLOOP.
*PERFORM add_audit_fields CHANGING lt_components.
*  " Bổ sung các field kỹ thuật
*  CLEAR ls_component.
*  ls_component-name = 'ROW_COLOR'.
*  ls_component-type ?= cl_abap_tabledescr=>describe_by_name( 'LVC_T_SCOL' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'CELLTAB'.
*  ls_component-type ?= cl_abap_tabledescr=>describe_by_name( 'LVC_T_STYL' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'IS_ERROR'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'CHAR1' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'IS_MESSAGE'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'STRING' ).
*  APPEND ls_component TO lt_components.
*
*  " Tạo cấu trúc động
*  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
*  lr_struct_type = cl_abap_structdescr=>create( lt_components ).
*
*  " Tạo internal table động
*  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
*  lr_table_type = cl_abap_tabledescr=>create(
*                    p_line_type  = lr_struct_type
*                    p_table_kind = cl_abap_tabledescr=>tablekind_std ).
*
*  CREATE DATA er_data TYPE HANDLE lr_table_type.
*
*ENDFORM.

*---------------------------------------------------------------------*
* Thêm 6 field audit (Created/Changed) vào cấu trúc động
*---------------------------------------------------------------------*
FORM add_audit_fields CHANGING ct_components TYPE cl_abap_structdescr=>component_table.
  DATA ls_component LIKE LINE OF ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERTIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERNAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AEDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AETIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AENAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.
ENDFORM.


*---------------------------------------------------------------------*
* Lấy metadata chi tiết từ DDIC (so với fieldcatalog ALV)
*---------------------------------------------------------------------*
FORM get_metadata USING p_tabname TYPE tabname
CHANGING ct_meta TYPE ddfields.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tabname
      langu          = sy-langu
      all_types      = 'X'
    TABLES
      dfies_tab      = ct_meta
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR ct_meta IS INITIAL.
    MESSAGE |Không lấy được metadata cho bảng { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

ENDFORM.

FORM enable_f4_in_fieldcat .
  DATA: lt_meta TYPE TABLE OF dfies,
        ls_meta TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING tabname = p_tab
    TABLES   dfies_tab = lt_meta
    EXCEPTIONS OTHERS = 1.

  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Mặc định
    <fc>-f4availabl = abap_false.

    " Key?
    DATA(lv_is_key) = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    CLEAR ls_meta.
    READ TABLE lt_meta INTO ls_meta WITH KEY fieldname = <fc>-fieldname.

    " --- Ưu tiên SH/FK ---
    IF sy-subrc = 0 AND ( ls_meta-f4availabl = 'X' OR ls_meta-checktable IS NOT INITIAL ).
      <fc>-f4availabl = abap_true.
    ELSE.
      " --- Loại trừ các kiểu không nên bật F4 ---
      DATA(lv_is_disallowed) = abap_false.
      IF ls_meta-datatype = 'DATS' OR ls_meta-datatype = 'TIMS'.
        lv_is_disallowed = abap_true.
      ENDIF.
      " QUAN/CURR (số lượng/tiền tệ) hoặc có ref field
      IF ls_meta-datatype = 'QUAN' OR ls_meta-datatype = 'CURR'
         OR ls_meta-reffield  IS NOT INITIAL OR ls_meta-reftable IS NOT INITIAL.
        lv_is_disallowed = abap_true.
      ENDIF.

      " --- Cho phép "fallback-only" ---
      IF lv_is_key = abap_false AND lv_is_disallowed = abap_false.
        " Kiểu text hoặc số "tự do": CHAR/STRG/NUMC/DEC/INT/FLTP/packed…
        IF ls_meta-inttype = 'C'  OR ls_meta-inttype = 'N' OR   " CHAR/NUMC
           ls_meta-inttype = 'P'  OR                            " DEC/packed
           ls_meta-inttype = 'I'  OR                            " INT
           ls_meta-inttype = 'F'.                               " FLTP
          <fc>-f4availabl = abap_true.  " bật để kích hoạt onf4 → fallback từ ALV
        ENDIF.
      ENDIF.
    ENDIF.

    " --- Whitelist/Blacklist (tuỳ chọn) ---
    READ TABLE gt_f4_whitelist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_true. ENDIF.

    READ TABLE gt_f4_blacklist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_false. ENDIF.

    " Giữ logic edit sẵn có
    IF <fc>-edit IS INITIAL.
      <fc>-edit = abap_true.
    ENDIF.
  ENDLOOP.
ENDFORM.


FORM register_f4_all .
  DATA: lt_f4   TYPE lvc_t_f4,
        ls_f4   TYPE lvc_s_f4,
        lt_seen TYPE HASHED TABLE OF lvc_fname WITH UNIQUE KEY table_line,
        lv_name TYPE lvc_fname.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  CLEAR: lt_f4, lt_seen.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    IF <fc>-f4availabl = abap_true.
      lv_name = <fc>-fieldname.
      IF lv_name IS INITIAL. CONTINUE. ENDIF.

      READ TABLE lt_seen WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. CONTINUE. ENDIF.
      INSERT lv_name INTO TABLE lt_seen.

      CLEAR ls_f4.
      ls_f4-fieldname = lv_name.
      ls_f4-register = abap_true.
      ls_f4-getbefore = abap_true.
      ls_f4-chngeafter = abap_false.

      INSERT ls_f4 INTO TABLE lt_f4.
    ENDIF.
  ENDLOOP.

  TRY.
      g_alv_grid->register_f4_for_fields( it_f4 = lt_f4 ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

CLASS lcl_alv_handler DEFINITION.
  PUBLIC SECTION.
    METHODS handle_toolbar
      FOR EVENT toolbar OF cl_gui_alv_grid
      IMPORTING e_object e_interactive.

    METHODS handle_user_command
      FOR EVENT user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm.

    METHODS handle_onf4
      FOR EVENT onf4 OF cl_gui_alv_grid
      IMPORTING e_fieldname es_row_no er_event_data e_display.

    METHODS handle_data_changed
      FOR EVENT data_changed OF cl_gui_alv_grid
      IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.
ENDCLASS.

CLASS lcl_alv_handler IMPLEMENTATION.

  METHOD handle_toolbar.
    DATA: lt_toolbar TYPE STANDARD TABLE OF stb_button,
          lt_excl    TYPE TABLE OF syucomm,
          ls_btn     TYPE stb_button.
    FIELD-SYMBOLS: <fs_btn> TYPE stb_button.
    DATA lv_code TYPE syucomm.
    DATA lv_found TYPE abap_bool.
    DATA: lv_can_create  TYPE abap_bool,
          lv_can_change  TYPE abap_bool,
          lv_can_delete  TYPE abap_bool,
          lv_can_display TYPE abap_bool.

    PERFORM has_actvt USING '01' CHANGING lv_can_create.  " Create
    PERFORM has_actvt USING '02' CHANGING lv_can_change.  " Change
    PERFORM has_actvt USING '06' CHANGING lv_can_delete.  " Delete
    PERFORM has_actvt USING '03' CHANGING lv_can_display. " Display

    e_interactive = space.

    " Loại bỏ các nút chuẩn không dùng
    REFRESH lt_excl.
    APPEND 'INSR' TO lt_excl.
    APPEND 'DELE' TO lt_excl.
    APPEND 'COPY' TO lt_excl.
    APPEND 'PASTE' TO lt_excl.
    APPEND 'SCUT' TO lt_excl.
    APPEND 'SALL' TO lt_excl.
    APPEND 'PICK' TO lt_excl.

    lt_toolbar = e_object->mt_toolbar[].
    LOOP AT lt_toolbar ASSIGNING <fs_btn>.
      CLEAR lv_found.
      LOOP AT lt_excl INTO lv_code.
        IF lv_code = <fs_btn>-function.
          lv_found = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_found = abap_true.
        DELETE lt_toolbar INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

    " EVTG: Edit/View toggle
CLEAR ls_btn.
ls_btn-function = 'EVTG'.
ls_btn-icon = COND #( WHEN gv_edit_md = abap_true THEN icon_display ELSE icon_change ).
ls_btn-text = COND #( WHEN gv_edit_md = abap_true THEN 'View' ELSE 'Edit' ).
ls_btn-quickinfo = COND #( WHEN gv_edit_md = abap_true THEN 'Switch to view mode'
                           ELSE 'Switch to edit mode' ).
ls_btn-disabled = COND #( WHEN lv_can_change = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" SAVE
CLEAR ls_btn.
ls_btn-function = 'SAVE'.
ls_btn-icon = icon_system_save.
ls_btn-text = 'Save'.
ls_btn-quickinfo = 'Save changes'.
ls_btn-disabled = COND #( WHEN lv_can_change = abap_true AND gv_edit_md = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" ADD
CLEAR ls_btn.
ls_btn-function = 'ADD'.
ls_btn-icon = icon_create.
ls_btn-text = 'Add'.
ls_btn-quickinfo = 'Add new entry'.
ls_btn-disabled = COND #( WHEN lv_can_create = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" DELETE
CLEAR ls_btn.
ls_btn-function = 'DELE'.
ls_btn-icon = icon_delete.
ls_btn-text = 'Delete'.
ls_btn-quickinfo = 'Delete selected entry'.
ls_btn-disabled = COND #( WHEN lv_can_delete = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" UPLOAD
CLEAR ls_btn.
ls_btn-function = 'UPLD'.
ls_btn-icon = icon_import.
ls_btn-text = 'Upload Data'.
ls_btn-quickinfo = 'Upload from file'.
ls_btn-disabled = COND #( WHEN lv_can_change = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" EXPORT
CLEAR ls_btn.
ls_btn-function = 'XLSX'.
ls_btn-icon = icon_export.
ls_btn-text = 'Export Data'.
ls_btn-quickinfo = 'Export to Excel'.
ls_btn-disabled = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" TEMPLATE
CLEAR ls_btn.
ls_btn-function = 'TMPL'.
ls_btn-icon = icon_export.
ls_btn-text = 'Export Template'.
ls_btn-quickinfo = 'Download template'.
ls_btn-disabled = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.

" HISTORY
CLEAR ls_btn.
ls_btn-function = 'HIST'.
ls_btn-icon = icon_history.
ls_btn-text = 'History'.
ls_btn-quickinfo = 'View version history & rollback'.
ls_btn-disabled = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
APPEND ls_btn TO lt_toolbar.


    e_object->mt_toolbar[] = lt_toolbar.
  ENDMETHOD.

METHOD handle_user_command.
  DATA: ls_stbl               TYPE lvc_s_stbl,
        lv_has_change         TYPE abap_bool,
        lv_answer             TYPE c,
        lv_new_incomplete     TYPE abap_bool,
        lv_other_changes      TYPE abap_bool,
        lv_ans_conf           TYPE c,
        lv_question           TYPE c LENGTH 70,
        lv_msg                TYPE c LENGTH 200,
        lv_err                TYPE c LENGTH 200,
        lv_skip_unsaved_check TYPE abap_bool VALUE abap_false,
        lv_ok                 TYPE abap_bool.

  CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  " Đẩy dữ liệu trên màn hình về itab trước khi xử lý
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->check_changed_data( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF e_ucomm = 'DELE' OR e_ucomm = 'ADD'.
    lv_skip_unsaved_check = abap_true.
  ENDIF.

  "=== Kiểm tra thay đổi chưa lưu chi tiết ===
  DATA: lv_new_incomplete_cnt TYPE i,
        lv_new_complete_cnt   TYPE i,
        lv_edit_existing_cnt  TYPE i,
        lv_ans                TYPE c,
        lv_text               TYPE c LENGTH 200.

  PERFORM analyze_change_state_detailed
    CHANGING lv_has_change lv_new_incomplete_cnt lv_new_complete_cnt lv_edit_existing_cnt.

  IF e_ucomm <> 'SAVE'
     AND lv_has_change = abap_true
     AND lv_skip_unsaved_check <> abap_true.

    " --- NEWREC thiếu khóa ---
    IF     lv_new_incomplete_cnt > 0
       AND lv_new_complete_cnt   = 0
       AND lv_edit_existing_cnt  = 0.

      lv_text = |Có | && lv_new_incomplete_cnt &&
                | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và tiếp tục?|.
      CLEAR lv_ans.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = 'Dòng mới thiếu khóa'
          text_question         = lv_text
          text_button_1         = 'Bỏ & tiếp tục'
          text_button_2         = 'Quay lại'
          default_button        = '2'
          display_cancel_button = space
        IMPORTING
          answer                = lv_ans.
      IF lv_ans = '1'.
        PERFORM purge_incomplete_newrecs.
        gv_add_mode = abap_false.
        PERFORM apply_editability_and_push.
      ELSE.
        PERFORM focus_key_on_newrec.
        RETURN.
      ENDIF.

    " --- NEWREC đủ khóa nhưng chưa lưu ---
    ELSEIF lv_new_complete_cnt   > 0
       AND lv_edit_existing_cnt  = 0
       AND lv_new_incomplete_cnt = 0.

      lv_text = |Có | && lv_new_complete_cnt &&
                | dòng mới CHƯA LƯU. Lưu trước khi tiếp tục?|.
      CLEAR lv_ans.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = 'Dòng mới chưa lưu'
          text_question         = lv_text
          text_button_1         = 'Lưu'
          text_button_2         = 'Không lưu'
          default_button        = '1'
          display_cancel_button = 'X'
        IMPORTING
          answer                = lv_ans.

      CASE lv_ans.
        WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
        WHEN 'A'. RETURN.
        WHEN '2'. " Không lưu -> bỏ qua
      ENDCASE.

    " --- Sửa dòng DB cũ ---
    ELSEIF lv_edit_existing_cnt  > 0
       AND lv_new_incomplete_cnt = 0
       AND lv_new_complete_cnt   = 0.

      lv_text = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi tiếp tục?'.
      CLEAR lv_ans.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = 'Thay đổi chưa lưu'
          text_question         = lv_text
          text_button_1         = 'Lưu'
          text_button_2         = 'Không lưu'
          default_button        = '1'
          display_cancel_button = 'X'
        IMPORTING
          answer                = lv_ans.

      CASE lv_ans.
        WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
        WHEN 'A'. RETURN.
        WHEN '2'. PERFORM discard_unsaved_changes.
      ENDCASE.

    " --- Hỗn hợp (vừa NEWREC, vừa sửa dòng cũ) ---
    ELSE.
      lv_text = |Có thay đổi chưa lưu: | &&
                lv_new_incomplete_cnt && ' NEWREC thiếu khóa, ' &&
                lv_new_complete_cnt   && ' NEWREC đủ khóa, ' &&
                lv_edit_existing_cnt  && ' thay đổi dòng cũ. Lưu trước khi tiếp tục?'.
      CLEAR lv_ans.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = 'Thay đổi chưa lưu'
          text_question         = lv_text
          text_button_1         = 'Lưu'
          text_button_2         = 'Không lưu'
          default_button        = '1'
          display_cancel_button = 'X'
        IMPORTING
          answer                = lv_ans.
      CASE lv_ans.
        WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
        WHEN 'A'. RETURN.
        WHEN '2'. PERFORM discard_unsaved_changes.
      ENDCASE.
    ENDIF.
  ENDIF.

  "=== Xử lý các nút ===
  CASE e_ucomm.

    WHEN 'EVTG'.
      PERFORM has_actvt USING '02' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.
      IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
        gv_edit_md      = abap_false.
        gv_add_mode     = abap_false.
        gv_toolbar_mode = 'D'.
        TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
      ELSE.
        gv_edit_md      = abap_true.
        gv_add_mode     = abap_false.
        gv_toolbar_mode = 'E'.
        TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
      ENDIF.
      PERFORM apply_editability_and_push.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
      TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.



    WHEN 'ADD'.
      PERFORM has_actvt USING '01' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any, <newrec> TYPE any.
      ASSIGN gr_data->* TO <lt>.
      IF <lt> IS ASSIGNED.
        APPEND INITIAL LINE TO <lt> ASSIGNING <ls>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
        IF sy-subrc = 0. <newrec> = 'X'. ENDIF.
    "=== Gán thông tin người tạo khi thêm mới ===
    FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any.
    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls> TO <ernam>.
    IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
    IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
    IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.
PERFORM log_audit_action USING p_tab 'C' <ls>.
        gv_add_mode     = abap_true.
        gv_edit_md      = abap_true.
        gv_toolbar_mode = 'E'.

        PERFORM apply_editability_and_push.
        TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.

        " Focus vào KEY đầu tiên
        PERFORM ensure_keys USING p_tab.
        READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
        IF sy-subrc = 0 AND g_alv_grid IS BOUND.
          DATA ls_row TYPE lvc_s_row.
          DATA ls_col TYPE lvc_s_col.
          ls_row-index     = lines( <lt> ).
          ls_col-fieldname = lv_first_key.
          TRY.
              g_alv_grid->set_current_cell_via_id(
                EXPORTING is_row_id    = ls_row
                          is_column_id = ls_col ).
              g_alv_grid->set_scroll_info_via_id(
                EXPORTING is_row_info = ls_row
                          is_col_info = ls_col ).
            CATCH cx_root.
          ENDTRY.
        ENDIF.
      ENDIF.
   WHEN 'SAVE'.
     PERFORM has_actvt USING '02' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Change (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.
      PERFORM on_save.
  "=== Cập nhật thông tin người chỉnh sửa trước khi lưu ===
  FIELD-SYMBOLS: <ls_row> TYPE any,
                 <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any,
                 <newrec_row> TYPE any.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls_row>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_row> TO <newrec_row>.
      " Chỉ cập nhật Changed info cho dòng không phải NEWREC
      IF sy-subrc = 0 AND <newrec_row> = 'X'.
        CONTINUE.
      ENDIF.

      ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_row> TO <aedat>.
      ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_row> TO <aetim>.
      ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_row> TO <aenam>.

      IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
      IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
      IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.
      PERFORM log_audit_action USING p_tab 'U' <ls_row>.
    ENDLOOP.
  ENDIF.
    WHEN 'DELE'.
      PERFORM has_actvt USING '06' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Delete (ACTVT=06).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      DATA: lt_sel_idx TYPE lvc_t_row,
            ls_cur_row TYPE lvc_s_row,
            ls_cur_col TYPE lvc_s_col,
            lv_cnt     TYPE i.
      CLEAR lt_sel_idx.

      IF g_alv_grid IS BOUND.
        TRY. g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ). CATCH cx_root. ENDTRY.
      ENDIF.
      IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
        TRY.
            g_alv_grid->get_current_cell(
              IMPORTING es_row_id = ls_cur_row
                        es_col_id = ls_cur_col ).
          CATCH cx_root.
        ENDTRY.
        IF ls_cur_row-index > 0.
          APPEND VALUE lvc_s_row( index = ls_cur_row-index ) TO lt_sel_idx.
        ENDIF.
      ENDIF.

      lv_cnt = lines( lt_sel_idx ).
      IF lv_cnt = 0.
        MESSAGE 'Vui lòng chọn dòng (hoặc đặt con trỏ) để xóa.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      CLEAR gv_del_newrec_only.
      CLEAR: lv_new_incomplete, lv_other_changes.
      PERFORM is_newrec_target_for_delete CHANGING gv_del_newrec_only.
      PERFORM analyze_change_state       CHANGING lv_new_incomplete lv_other_changes.

      DATA lv_need_confirm TYPE abap_bool VALUE abap_false.
      CLEAR lv_question.

      IF gv_del_newrec_only = abap_true.
        lv_need_confirm = abap_false.
      ELSE.
        lv_need_confirm = abap_true.
        lv_question     = |Bạn có chắc muốn xóa { lv_cnt } dòng đã chọn?|.
      ENDIF.

      IF lv_need_confirm = abap_true.
        CLEAR lv_ans_conf.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Xác nhận xóa'
            text_question         = lv_question(70)
            text_button_1         = 'Xóa'
            text_button_2         = 'Không'
            default_button        = '2'
            display_cancel_button = space
          IMPORTING
            answer                = lv_ans_conf.
        IF lv_ans_conf <> '1'.
          RETURN.
        ENDIF.
      ENDIF.

      IF gv_del_newrec_only = abap_true AND lv_other_changes = abap_true.
        PERFORM discard_unsaved_changes.
        gv_dirty = abap_false.
      ENDIF.

      CLEAR: lv_msg, lv_err.
      PERFORM delete_selected USING p_tab CHANGING lv_msg lv_err.
      IF lv_err IS INITIAL.
        MESSAGE |{ COND string( WHEN lv_msg IS INITIAL THEN 'Đã xóa và ghi audit.' ELSE lv_msg ) }| TYPE 'S'.
      ELSE.
        MESSAGE |{ lv_err }| TYPE 'S' DISPLAY LIKE 'E'.
      ENDIF.

      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.


    WHEN 'UPLD'.
      PERFORM has_actvt USING '02' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Upload (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.
      PERFORM upload_data_strict_match.
   WHEN 'XLSX' OR 'TMPL' OR 'HIST'.
      PERFORM has_actvt USING '03' CHANGING lv_ok.
      IF lv_ok IS INITIAL.
        MESSAGE 'Bạn không có quyền Display (ACTVT=03).' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      CASE e_ucomm.
        WHEN 'XLSX'. PERFORM download_excel_xlsx USING gr_data.
        WHEN 'TMPL'. PERFORM download_template_xlsx.
        WHEN 'HIST'. PERFORM show_audit_history.
      ENDCASE.

  ENDCASE.

  cl_gui_cfw=>flush( ).
ENDMETHOD.



  METHOD handle_onf4.
    er_event_data->m_event_handled = abap_true.
    DATA: lt_ret   TYPE STANDARD TABLE OF ddshretval,
          ls_ret   TYPE ddshretval,
          lv_value TYPE string,
          lv_done  TYPE abap_bool.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.
    " 1) DDIC search help (nếu có)
    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname    = p_tab
        fieldname  = e_fieldname
        display    = 'F'
      TABLES
        return_tab = lt_ret
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc = 0.
      " ĐÃ gọi được SH chuẩn → không fallback nữa
      IF lt_ret IS NOT INITIAL.
        READ TABLE lt_ret INDEX 1 INTO ls_ret.
        IF sy-subrc = 0.
          lv_value = ls_ret-fieldval.
          lv_done  = abap_true.
        ENDIF.
      ELSE.
        " Người dùng Cancel/không chọn → kết thúc, KHÔNG mở popup fallback
        er_event_data->m_event_handled = 'X'.
        RETURN.
      ENDIF.
    ENDIF.

    " 2) Fallback dynamic từ dữ liệu hiện có
    IF lv_done IS INITIAL.
      DATA lv_current TYPE string.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, đổi internal -> external để dùng làm tiền tố filter
            DATA(lo_d1) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d1->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_current ).
                CATCH cx_abap_datfm.
                  lv_current = <cell>. " fallback
              ENDTRY.
            ELSE.
              lv_current = <cell>.
            ENDIF.
            CONDENSE lv_current.
          ENDIF.
        ENDIF.
      ENDIF.

      TYPES: BEGIN OF ty_val, fieldval TYPE char80, END OF ty_val.
      DATA: lt_vals TYPE STANDARD TABLE OF ty_val WITH DEFAULT KEY,
            ls_val  TYPE ty_val,
            lv_s    TYPE string.

      IF <outtab> IS ASSIGNED.
        LOOP AT <outtab> ASSIGNING <row>.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, hiển thị external trong popup
            DATA(lo_d2) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d2->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_s ).
                CATCH cx_abap_datfm.
                  lv_s = <cell>.
              ENDTRY.
            ELSE.
              lv_s = <cell>.
            ENDIF.

            CONDENSE lv_s.
            IF lv_s IS NOT INITIAL AND ( lv_current IS INITIAL OR lv_s CP lv_current && '*' ).
              ls_val-fieldval = lv_s.
              COLLECT ls_val INTO lt_vals.  " distinct
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.


      IF lt_vals IS NOT INITIAL.
        DATA: lt_field_tab TYPE TABLE OF dfies,
              ls_field_tab TYPE dfies,
              lv_coltext   TYPE string.

        " Lấy caption từ fieldcatalog
        lv_coltext = e_fieldname.
        LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>) WHERE fieldname = e_fieldname.
          IF <fc>-coltext IS NOT INITIAL.
            lv_coltext = <fc>-coltext.
          ELSEIF <fc>-scrtext_m IS NOT INITIAL.
            lv_coltext = <fc>-scrtext_m.
          ENDIF.
          EXIT.
        ENDLOOP.

        CLEAR ls_field_tab.
        ls_field_tab-fieldname = 'FIELDVAL'.
        ls_field_tab-datatype  = 'CHAR'.
        ls_field_tab-inttype   = 'C'.
        ls_field_tab-intlen    = 80.
        ls_field_tab-leng      = 80.
        ls_field_tab-outputlen = 80.
        ls_field_tab-decimals  = 0.
        ls_field_tab-reffield  = ''.
        ls_field_tab-reftable  = ''.
        ls_field_tab-reptext   = lv_coltext.
        ls_field_tab-scrtext_l = lv_coltext.
        ls_field_tab-scrtext_m = lv_coltext.
        ls_field_tab-scrtext_s = lv_coltext.
        APPEND ls_field_tab TO lt_field_tab.

        CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
          EXPORTING
            retfield   = 'FIELDVAL'
            value_org  = 'S'
            display    = 'F'
          TABLES
            value_tab  = lt_vals
            field_tab  = lt_field_tab
            return_tab = lt_ret
          EXCEPTIONS
            OTHERS     = 1.

        IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
          READ TABLE lt_ret INDEX 1 INTO ls_ret.
          IF sy-subrc = 0.
            lv_value = ls_ret-fieldval.
            lv_done = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    " 3) Gán lại vào ô hiện tại và refresh
    IF lv_done = abap_true.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            DATA(lo_desc) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).

            IF lo_desc->type_kind = cl_abap_typedescr=>typekind_date.
              DATA lv_date_int TYPE d.
              TRY.
                  cl_abap_datfm=>conv_date_ext_to_int(
                    EXPORTING im_datext = lv_value
                    IMPORTING ex_datint = lv_date_int ).
                  <cell> = lv_date_int.
                CATCH cx_abap_datfm .
                  TRY. <cell> = lv_value. CATCH cx_root. ENDTRY.
              ENDTRY.
            ELSE.
              <cell> = lv_value.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      TRY.
          g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        CATCH cx_root.
      ENDTRY.
      cl_gui_cfw=>flush( ).
      er_event_data->m_event_handled = 'X'.
    ENDIF.
  ENDMETHOD.


  METHOD handle_data_changed.
    DATA: lt_mod TYPE lvc_t_modi,
          ls_mod TYPE lvc_s_modi.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.

    ASSIGN gr_data->* TO <outtab>.
    IF <outtab> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    lt_mod = er_data_changed->mt_mod_cells.

    LOOP AT lt_mod INTO ls_mod.

      "--- 1) KEY: chỉ cho phép khi đang Add và dòng NEWREC = 'X'
      READ TABLE gt_key_fields WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. " là KEY
        DATA(lv_block_key) = abap_true.
        IF gv_add_mode = abap_true AND ls_mod-row_id > 0.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0 AND <cell> = 'X'.
              lv_block_key = abap_false.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_block_key = abap_true.
          " trả lại giá trị cũ
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0.
              er_data_changed->modify_cell(
                EXPORTING i_row_id    = ls_mod-row_id
                          i_fieldname = ls_mod-fieldname
                          i_value     = <cell> ).
              er_data_changed->add_protocol_entry(
                i_msgid = '00' i_msgno = '398' i_msgty = 'E'
                i_fieldname = ls_mod-fieldname
                i_row_id   = ls_mod-row_id
                i_msgv1    = |Field { ls_mod-fieldname } is not editable (key)| ).
            ENDIF.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      "--- 2) Non-key: chỉ cho phép khi đang Edit
      IF gv_edit_md <> abap_true.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).
            er_data_changed->add_protocol_entry(
              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
              i_fieldname = ls_mod-fieldname
              i_row_id   = ls_mod-row_id
              i_msgv1    = |Field { ls_mod-fieldname } is read-only in View mode| ).
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      "--- 3) Đánh dấu dirty CHỈ khi không phải dòng NEWREC
      DATA(lv_is_newrec) = abap_false.
      IF ls_mod-row_id > 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> = 'X'.
            lv_is_newrec = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.

      IF lv_is_newrec = abap_false.
        " thay đổi trên dòng cũ -> coi là dirty để còn hỏi lưu
        gv_dirty = abap_true.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.


ENDCLASS.


*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
  SET PF-STATUS 'MAIN100'.
  SET TITLEBAR 'T100'.
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PBO_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE pbo_0100 OUTPUT.
  PERFORM check_authorization.
  FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <fs_table>.

  IF <fs_table> IS NOT ASSIGNED OR <fs_table> IS INITIAL.
    MESSAGE 'Không có dữ liệu để hiển thị' TYPE 'I'.
    LEAVE TO SCREEN 0.
    RETURN.
  ENDIF.

  TRY.
      "=== Chuẩn bị Fieldcatalog ===
      IF gt_fieldcat IS INITIAL.
        PERFORM build_fieldcat_all.
      ENDIF.
      PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.
      PERFORM enable_f4_in_fieldcat. " Bật cờ F4 cho tất cả cột

      "=== Tạo container & grid nếu lần đầu ===
      IF g_container IS INITIAL OR g_alv_grid IS INITIAL.
        CREATE OBJECT g_container EXPORTING container_name = gc_cc_alv.
        CREATE OBJECT g_alv_grid EXPORTING i_parent = g_container.
        g_alv_grid->set_toolbar_interactive( ).

        " Gắn các handler
        IF g_handler IS INITIAL.
          CREATE OBJECT g_handler.
          SET HANDLER g_handler->handle_toolbar FOR g_alv_grid.
          SET HANDLER g_handler->handle_user_command FOR g_alv_grid.
          SET HANDLER g_handler->handle_onf4 FOR g_alv_grid.
          SET HANDLER g_handler->handle_data_changed FOR g_alv_grid.
        ENDIF.

        " Layout
        gs_layout = VALUE #( edit = abap_true zebra = abap_true
        cwidth_opt = abap_true stylefname = 'CELLTAB' ).

        PERFORM ensure_celltab_component CHANGING gr_data.
        ASSIGN gr_data->* TO <fs_table>.

        g_alv_grid->set_table_for_first_display(
        EXPORTING is_layout = gs_layout
        CHANGING it_outtab = <fs_table>
        it_fieldcatalog = gt_fieldcat ).

      ELSE.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
      ENDIF.
      PERFORM apply_editability_and_push.
      PERFORM register_f4_all.
      TRY.
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_enter ).
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_modified ).
        CATCH cx_root.
      ENDTRY.

      "=== Bật/tắt input cho grid ===
      g_alv_grid->set_ready_for_input(
      COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).

    CATCH cx_root.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PAI_0100 INPUT
*&---------------------------------------------------------------------*

MODULE pai_0100 INPUT.
  g_okcode = sy-ucomm.
  CLEAR sy-ucomm.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  TRY.
      CASE g_okcode.

              WHEN 'BACK' OR 'CANC' OR 'EXIT'.

        " Đẩy giá trị đang nhập về itab trước khi so sánh
        IF g_alv_grid IS BOUND.
          TRY.
              g_alv_grid->check_changed_data( ).
            CATCH cx_root.
          ENDTRY.
        ENDIF.

        " Phân tích thay đổi chi tiết
        DATA: lv_has_change_exit         TYPE abap_bool,
              lv_new_incomplete_cnt_exit TYPE i,
              lv_new_complete_cnt_exit   TYPE i,
              lv_edit_existing_cnt_exit  TYPE i,
              lv_ans_exit                TYPE c,
              lv_text_exit               TYPE c LENGTH 200.

        CLEAR: lv_has_change_exit, lv_new_incomplete_cnt_exit,
               lv_new_complete_cnt_exit, lv_edit_existing_cnt_exit.

        PERFORM analyze_change_state_detailed
          CHANGING lv_has_change_exit
                   lv_new_incomplete_cnt_exit
                   lv_new_complete_cnt_exit
                   lv_edit_existing_cnt_exit.

        " Không có thay đổi -> thoát luôn
        IF lv_has_change_exit = abap_false.
          LEAVE TO SCREEN 0.
          RETURN.
        ENDIF.

        " --- CASE 1: CHỈ NEWREC THIẾU KHÓA ---
        IF     lv_new_incomplete_cnt_exit > 0
           AND lv_new_complete_cnt_exit   = 0
           AND lv_edit_existing_cnt_exit  = 0.

          lv_text_exit = |Có | && lv_new_incomplete_cnt_exit &&
                         | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và thoát?|.
          CLEAR lv_ans_exit.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Dòng mới thiếu khóa'
              text_question         = lv_text_exit
              text_button_1         = 'Bỏ & Thoát'
              text_button_2         = 'Quay lại'
              default_button        = '2'
              display_cancel_button = space
            IMPORTING
              answer                = lv_ans_exit.

          IF lv_ans_exit = '1'.
            PERFORM purge_incomplete_newrecs.
            LEAVE TO SCREEN 0.
          ELSE.
            PERFORM focus_key_on_newrec.
            RETURN.
          ENDIF.

        " --- CASE 2: CHỈ NEWREC ĐỦ KHÓA (chưa lưu) ---
        ELSEIF lv_new_complete_cnt_exit   > 0
           AND lv_edit_existing_cnt_exit  = 0
           AND lv_new_incomplete_cnt_exit = 0.

          lv_text_exit = |Có | && lv_new_complete_cnt_exit &&
                         | dòng mới CHƯA LƯU. Lưu trước khi thoát?|.
          CLEAR lv_ans_exit.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Dòng mới chưa lưu'
              text_question         = lv_text_exit
              text_button_1         = 'Lưu'
              text_button_2         = 'Không lưu'
              default_button        = '1'
              display_cancel_button = 'X'
            IMPORTING
              answer                = lv_ans_exit.

          CASE lv_ans_exit.
            WHEN '1'. " Lưu rồi thoát nếu OK
              PERFORM on_save.
              IF gv_dirty = abap_true.
                RETURN. " Lưu lỗi -> ở lại màn hình
              ENDIF.
              LEAVE TO SCREEN 0.
            WHEN '2'. " Không lưu -> bỏ thay đổi (NEWREC) rồi thoát
              PERFORM discard_unsaved_changes.
              LEAVE TO SCREEN 0.
            WHEN 'A'. " Cancel
              RETURN.
          ENDCASE.

        " --- CASE 3: CHỈ sửa dòng DB cũ ---
        ELSEIF lv_edit_existing_cnt_exit  > 0
           AND lv_new_incomplete_cnt_exit = 0
           AND lv_new_complete_cnt_exit   = 0.

          lv_text_exit = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi thoát?'.
          CLEAR lv_ans_exit.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Thay đổi chưa lưu'
              text_question         = lv_text_exit
              text_button_1         = 'Lưu'
              text_button_2         = 'Không lưu'
              default_button        = '1'
              display_cancel_button = 'X'
            IMPORTING
              answer                = lv_ans_exit.

          CASE lv_ans_exit.
            WHEN '1'.
              PERFORM on_save.
              IF gv_dirty = abap_true. RETURN. ENDIF.
              LEAVE TO SCREEN 0.
            WHEN '2'.
              PERFORM discard_unsaved_changes.
              LEAVE TO SCREEN 0.
            WHEN 'A'.
              RETURN.
          ENDCASE.

        " --- CASE 4: HỖN HỢP ---
        ELSE.
          lv_text_exit = |Có thay đổi chưa lưu: | &&
                         lv_new_incomplete_cnt_exit && ' NEWREC thiếu khóa, ' &&
                         lv_new_complete_cnt_exit   && ' NEWREC đủ khóa, ' &&
                         lv_edit_existing_cnt_exit  && ' thay đổi dòng cũ. Lưu trước khi thoát?'.
          CLEAR lv_ans_exit.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Thay đổi chưa lưu'
              text_question         = lv_text_exit
              text_button_1         = 'Lưu'
              text_button_2         = 'Không lưu'
              default_button        = '1'
              display_cancel_button = 'X'
            IMPORTING
              answer                = lv_ans_exit.

          CASE lv_ans_exit.
            WHEN '1'.
              PERFORM on_save.
              IF gv_dirty = abap_true. RETURN. ENDIF.
              LEAVE TO SCREEN 0.
            WHEN '2'.
              PERFORM discard_unsaved_changes.
              LEAVE TO SCREEN 0.
            WHEN 'A'.
              RETURN.
          ENDCASE.
        ENDIF.


        WHEN 'SAVE'.
          PERFORM on_save.

          " Reset trạng thái sau khi lưu thành công
          gv_dirty      = abap_false.
          gv_add_mode   = abap_false.
          gv_edit_md    = abap_false.
          gv_toolbar_mode = 'D'.

          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Xóa NEWREC ở tất cả dòng nếu có
          FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE, <ls> TYPE any, <newrec> TYPE any.
          ASSIGN gr_data->* TO <lt>.
          IF <lt> IS ASSIGNED.
            LOOP AT <lt> ASSIGNING <ls>.
              ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
              IF sy-subrc = 0.
                CLEAR <newrec>.
              ENDIF.
            ENDLOOP.
          ENDIF.

          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

        WHEN OTHERS.
          " Không làm gì thêm; chỉ refresh để đảm bảo không thoát chương trình cho lệnh lạ
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

      ENDCASE.

    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.



FORM apply_editability_and_push.
  " 0) Đảm bảo danh sách KEY
  PERFORM ensure_keys USING p_tab.

  " 1) Fieldcatalog (cấp cột)
  "    - KEY: chỉ mở cột khi đang Add (để có thể nhập ở dòng NEWREC)
  "    - Non-key: mở khi Edit
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    DATA(lv_is_key) = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    IF lv_is_key = abap_true.
      <fc>-edit       = COND #( WHEN gv_add_mode = abap_true THEN 'X' ELSE space ).
      <fc>-f4availabl = COND #( WHEN gv_add_mode = abap_true THEN 'X' ELSE space ).
    ELSE.
      <fc>-edit = COND #( WHEN gv_edit_md = abap_true THEN 'X' ELSE space ).
    ENDIF.
  ENDLOOP.

  " 2) Style theo dòng (cấp ô)
  "    - KEY enabled chỉ khi Add + dòng NEWREC='X'
  "    - Còn lại disable (ô xám, không caret). Có thể cộng thêm F4 icon nếu thích.
  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <celltab> TYPE lvc_t_styl,
                 <newrec>  TYPE any.
  DATA: ls_styl   TYPE lvc_s_styl,
        lv_key    TYPE dd03l-fieldname,
        lv_is_new TYPE abap_bool.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls> TO <celltab>.
      IF sy-subrc <> 0. CONTINUE. ENDIF.
      CLEAR <celltab>.

      " Dòng mới?
      lv_is_new = abap_false.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'. lv_is_new = abap_true. ENDIF.

      " Áp cho tất cả KEY
      LOOP AT gt_key_fields INTO lv_key.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_key.

        IF gv_add_mode = abap_true AND lv_is_new = abap_true.
          ls_styl-style = cl_gui_alv_grid=>mc_style_enabled.     " cho nhập KEY ở dòng NEW
        ELSE.
          " Xám, không caret; muốn hiện icon F4 khi khoá thì cộng thêm mc_style_f4
          ls_styl-style = cl_gui_alv_grid=>mc_style_disabled.
        ENDIF.

        INSERT ls_styl INTO TABLE <celltab>.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

  " 3) Đẩy xuống frontend & refresh (sau khi set fcat + style)
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_frontend_fieldcatalog( it_fieldcatalog = gt_fieldcat ).
      CATCH cx_root.
    ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
  ENDIF.
ENDFORM.

*=====================================================================*
* INCLUDE ZFA25SAP23_IO - Đọc / Upload dữ liệu Excel (.XLSX, .XLS)
*=====================================================================*

TYPES: BEGIN OF alsmex_tabline,
         row   TYPE i,
         col   TYPE i,
         value TYPE string,
       END OF alsmex_tabline.
TYPES: ty_t_alsmex_tab TYPE STANDARD TABLE OF alsmex_tabline WITH DEFAULT KEY.

*---------------------------------------------------------------------*
* FORM read_xlsx_clfdt - Đọc file .XLSX bằng class CL_FDT_XL_SPREADSHEET
*---------------------------------------------------------------------*
FORM read_xlsx_clfdt USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.

  DATA: lt_bin   TYPE solix_tab,
        lv_xstr  TYPE xstring,
        lv_file  TYPE string,
        lo_excel TYPE REF TO cl_fdt_xl_spreadsheet,
        lt_names TYPE if_fdt_doc_spreadsheet=>t_worksheet_names,
        lv_sheet TYPE string,
        lr_src   TYPE REF TO data,
        lt_cells TYPE STANDARD TABLE OF alsmex_tabline,
        ls_cell  TYPE alsmex_tabline.

  FIELD-SYMBOLS: <lt_src> TYPE STANDARD TABLE,
                 <ls_src> TYPE any,
                 <lv_any> TYPE any,
                 <lt_ret> TYPE STANDARD TABLE.

  lv_file = iv_file.

  "--- Upload file Excel (.xlsx) dạng nhị phân ---
  cl_gui_frontend_services=>gui_upload(
  EXPORTING filename = lv_file filetype = 'BIN'
  CHANGING data_tab = lt_bin ).

  IF sy-subrc <> 0.
    MESSAGE 'Không đọc được file .xlsx từ frontend' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_xstr = cl_bcs_convert=>solix_to_xstring( lt_bin ).

  "--- Đọc nội dung file Excel ---
  CREATE OBJECT lo_excel
    EXPORTING
      xdocument     = lv_xstr
      document_name = 'UPLOAD_EXCEL'.

  lo_excel->if_fdt_doc_spreadsheet~get_worksheet_names(
  IMPORTING worksheet_names = lt_names ).
  READ TABLE lt_names INDEX 1 INTO lv_sheet.

  IF sy-subrc <> 0 OR lv_sheet IS INITIAL.
    MESSAGE 'Không xác định được worksheet đầu tiên' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_src = lo_excel->if_fdt_doc_spreadsheet~get_itab_from_worksheet( lv_sheet ).
  ASSIGN lr_src->* TO <lt_src>.
  IF <lt_src> IS NOT ASSIGNED.
    MESSAGE 'Không đọc được dữ liệu từ worksheet' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Lấy mô tả cấu trúc bảng ---
  DATA lo_tabdesc TYPE REF TO cl_abap_tabledescr.
  DATA lo_linedesc TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  lo_tabdesc ?= cl_abap_typedescr=>describe_by_data( <lt_src> ).
  lo_linedesc ?= CAST cl_abap_structdescr( lo_tabdesc->get_table_line_type( ) ).
  lt_comp = lo_linedesc->get_components( ).

  "--- Chuyển dữ liệu từ Excel → ALSMEX_TABLINE ---
  DATA lv_row TYPE i VALUE 0.
  LOOP AT <lt_src> ASSIGNING <ls_src>.
    lv_row = lv_row + 1.
    DATA(lv_col) = 0.
    LOOP AT lt_comp INTO DATA(ls_comp).
      ASSIGN COMPONENT ls_comp-name OF STRUCTURE <ls_src> TO <lv_any>.
      lv_col = lv_col + 1.

      CLEAR ls_cell.
      ls_cell-row = lv_row.
      ls_cell-col = lv_col.
      ls_cell-value = <lv_any>.
      APPEND ls_cell TO lt_cells.
    ENDLOOP.
  ENDLOOP.

  "--- Gán dữ liệu trả ra ---
  CREATE DATA cr_cells LIKE lt_cells.
  ASSIGN cr_cells->* TO <lt_ret>.
  IF <lt_ret> IS ASSIGNED.
    <lt_ret> = lt_cells.
  ENDIF.

  "--- Trích header (dòng 1) ---
  DATA lt_header TYPE STANDARD TABLE OF string.
  LOOP AT lt_cells INTO ls_cell WHERE row = 1.
    APPEND ls_cell-value TO lt_header.
  ENDLOOP.

  IF lt_header IS INITIAL.
    MESSAGE 'Không xác định được tiêu đề (header) trong Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  ct_header = lt_header.

  DESCRIBE TABLE lt_cells LINES DATA(lv_cnt).
  " Bỏ WRITE để không mở list
  " WRITE: / 'Số dòng đọc từ Excel:', lv_cnt.

  IF lv_cnt = 0.
    MESSAGE 'Không đọc được dữ liệu từ Excel (lt_cells = 0 dòng)' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
ENDFORM.


*---------------------------------------------------------------------*
* FORM read_xls_fm - Đọc file .XLS bằng FM cũ ALSM_EXCEL_TO_INTERNAL_TABLE
*---------------------------------------------------------------------*
FORM read_xls_fm USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.
  " SAP GUI đời mới không còn OLE, nên gọi lại form read_xlsx_clfdt
  PERFORM read_xlsx_clfdt USING iv_file CHANGING cr_cells ct_header.
ENDFORM.


*---------------------------------------------------------------------*
* FORM upload_data_strict_match - Upload Excel → ALV data
*---------------------------------------------------------------------*
FORM upload_data_strict_match.

  TYPES: BEGIN OF alsmex_tabline,
           row   TYPE i,
           col   TYPE i,
           value TYPE string,
         END OF alsmex_tabline.

  DATA: lv_filename TYPE rlgrap-filename,
        lt_file     TYPE filetable,
        ls_file     TYPE file_table,
        ls_fc       TYPE lvc_s_fcat,
        lv_rc       TYPE i,
        lr_cells    TYPE REF TO data,
        lt_str      TYPE STANDARD TABLE OF alsmex_tabline,
        lt_header   TYPE STANDARD TABLE OF string,
        lv_msg      TYPE string.

  "=== 1) Hộp thoại chọn file Excel ===
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title      = 'Chọn file Excel để upload'
      default_extension = 'XLSX'
      file_filter       = 'Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls|All files (*.*)|*.*'
      multiselection    = abap_false
    CHANGING
      file_table        = lt_file
      rc                = lv_rc
    EXCEPTIONS
      OTHERS            = 1.

  IF lv_rc < 1 OR sy-subrc <> 0.
    MESSAGE 'Upload bị hủy hoặc lỗi khi chọn file' TYPE 'I'.
    RETURN.
  ENDIF.

  READ TABLE lt_file INTO ls_file INDEX 1.
  IF sy-subrc <> 0 OR ls_file-filename IS INITIAL.
    MESSAGE 'Không đọc được đường dẫn file' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_filename = ls_file-filename.

  "=== 2) Đọc dữ liệu Excel ===
  IF lv_filename CP '*.xlsx' OR lv_filename CP '*.XLSX'.
    PERFORM read_xlsx_clfdt USING lv_filename CHANGING lr_cells lt_header.
  ELSEIF lv_filename CP '*.xls' OR lv_filename CP '*.XLS'.
    PERFORM read_xls_fm USING lv_filename CHANGING lr_cells lt_header.
  ELSE.
    MESSAGE 'Định dạng file không được hỗ trợ (chỉ .xls / .xlsx)' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lr_cells IS INITIAL.
    MESSAGE 'Không đọc được dữ liệu từ file Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  FIELD-SYMBOLS: <lt_str>      TYPE ty_t_alsmex_tab,
                 <ls_line_hdr> TYPE alsmex_tabline.

  ASSIGN lr_cells->* TO <lt_str>.
  IF <lt_str> IS INITIAL.
    MESSAGE 'File Excel rỗng hoặc lỗi định dạng' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 3b) Kiểm tra header Excel khớp DDIC ===
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        ls_ddic_field  TYPE dfies,
        lt_missing     TYPE STANDARD TABLE OF string,
        lt_extra       TYPE STANDARD TABLE OF string.

  "--- Lấy metadata từ DDIC ---
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tab
    TABLES
      dfies_tab      = lt_ddic_fields
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR lt_ddic_fields IS INITIAL.
    MESSAGE |Không lấy được metadata của bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Bỏ các field kỹ thuật không cần upload ---
  DELETE lt_ddic_fields WHERE fieldname = 'MANDT' OR keyflag = 'X'.

  "--- Chuẩn hóa tên header Excel ---
  LOOP AT lt_header INTO DATA(lv_header_norm).
    lv_header_norm = to_upper( condense( lv_header_norm ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_header_norm WITH ''.
    CONDENSE lv_header_norm NO-GAPS.
    MODIFY lt_header FROM lv_header_norm INDEX sy-tabix.
  ENDLOOP.

  "--- Chuẩn hóa tên field DDIC ---
  DATA lt_ddic_names TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
  LOOP AT lt_ddic_fields INTO ls_ddic_field.
    DATA(lv_ddic_norm) = to_upper( condense( ls_ddic_field-fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_ddic_norm WITH ''.
    CONDENSE lv_ddic_norm NO-GAPS.
    APPEND lv_ddic_norm TO lt_ddic_names.
  ENDLOOP.

  "--- So sánh 2 danh sách ---
  LOOP AT lt_ddic_names INTO DATA(lv_fieldname).
    READ TABLE lt_header WITH KEY table_line = lv_fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Thiếu cột trong Excel: { lv_fieldname }| TO lt_missing.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_header INTO DATA(lv_hdrname).
    READ TABLE lt_ddic_names WITH KEY table_line = lv_hdrname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Cột thừa trong Excel: { lv_hdrname }| TO lt_extra.
    ENDIF.
  ENDLOOP.

  "--- Báo lỗi nếu có thiếu/thừa ---
  IF lt_missing IS NOT INITIAL.
    LOOP AT lt_missing INTO DATA(lv_miss).
      MESSAGE lv_miss TYPE 'S' DISPLAY LIKE 'E'.
    ENDLOOP.
    MESSAGE |Header Excel bị thiếu cột so với bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lt_extra IS NOT INITIAL.
    LOOP AT lt_extra INTO DATA(lv_ext).
      MESSAGE lv_ext TYPE 'S' DISPLAY LIKE 'W'.
    ENDLOOP.
    MESSAGE |Excel có thêm cột không nằm trong bảng { p_tab }| TYPE 'S'.
  ENDIF.

  "--- Nếu mọi thứ ổn ---
  MESSAGE |Header Excel hợp lệ, khớp với bảng { p_tab }| TYPE 'S'.

  "=== 6) Gán dữ liệu vào GR_DATA ===
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any,
                 <val>     TYPE any.

  ASSIGN gr_data->* TO <lt_data>.
  IF sy-subrc <> 0 OR <lt_data> IS NOT ASSIGNED.
    MESSAGE 'Lỗi gán GR_DATA' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_data>.

  " Cache metadata của bảng để tránh gọi lại mỗi cell
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic_fields
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT <lt_str> INTO DATA(ls_cell) WHERE row > 1.
    READ TABLE lt_header INDEX ls_cell-col INTO DATA(lv_hdr_fieldname).
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    " Chuẩn hóa tên field
    lv_fieldname = to_upper( condense( lv_hdr_fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_hdr_fieldname WITH ''.
    CONDENSE lv_hdr_fieldname NO-GAPS.

    READ TABLE gt_fieldnames INTO DATA(lv_real_field) WITH KEY table_line = lv_hdr_fieldname.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    READ TABLE <lt_data> INDEX ( ls_cell-row - 1 ) ASSIGNING <ls_data>.
    IF sy-subrc <> 0.
      APPEND INITIAL LINE TO <lt_data> ASSIGNING <ls_data>.
    ENDIF.



    ASSIGN COMPONENT lv_real_field OF STRUCTURE <ls_data> TO <val>.
    IF <val> IS ASSIGNED.

      "-----------------------------------------------------------
      " 🔹 [1] Lấy metadata field từ DDIC
      "-----------------------------------------------------------
      READ TABLE lt_ddic_fields INTO DATA(ls_ddic) WITH KEY fieldname = lv_real_field.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      DATA(lv_val_excel) = ls_cell-value.
      DATA(lv_type) = ls_ddic-inttype.
      DATA(lv_valid) = abap_true.

      "-----------------------------------------------------------
      " 🔹 [2] Kiểm tra kiểu dữ liệu cơ bản (DATE, TIME, NUMERIC…)
      "-----------------------------------------------------------
      lv_valid = abap_true.
      CASE lv_type.
        WHEN 'D'. " Date
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_date) = CONV d( lv_val_excel ).

                CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
                  EXPORTING
                    date                      = lv_date
                  EXCEPTIONS
                    plausibility_check_failed = 1
                    OTHERS                    = 2.

                IF sy-subrc <> 0.
                  lv_valid = abap_false. " Ngày không hợp lệ (ví dụ 30/02/2025)
                ENDIF.

              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.


        WHEN 'T'. " Time
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_time) = CONV t( lv_val_excel ).
                DATA(lv_dummy_date) = CONV d( '19700101' ).
                CONVERT DATE lv_dummy_date TIME lv_time INTO TIME STAMP DATA(lv_timestamp_t) TIME ZONE 'UTC'.
              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.

*        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
*          TRY.
*              DATA(lv_num) = lv_val_excel.
*            CATCH cx_sy_conversion_no_number.
*              lv_valid = abap_false.
*          ENDTRY.
        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
          TRY.
              lv_val_excel = lv_val_excel + 0.
            CATCH cx_sy_conversion_no_number cx_sy_conversion_error.
              lv_valid = abap_false.
          ENDTRY.
*        WHEN 'N'. " NUMC
        WHEN 'N'. " NUMC
          lv_val_excel = condense( to_upper( lv_val_excel ) ).
          IF lv_val_excel IS NOT INITIAL AND NOT lv_val_excel CO '0123456789'.
            lv_valid = abap_false.
          ENDIF.

        WHEN OTHERS.
          lv_valid = abap_true.
      ENDCASE.

      " Nếu dữ liệu không hợp lệ theo kiểu DDIC → đánh dấu lỗi
      IF lv_valid = abap_false.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag>).
        IF <lv_err_flag> IS ASSIGNED.
          <lv_err_flag> = 'X'.
        ENDIF.
        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_msg>).
        IF <lv_err_msg> IS ASSIGNED.
          CONCATENATE 'Sai định dạng dữ liệu tại cột' lv_real_field 'giá trị:' lv_val_excel INTO <lv_err_msg> SEPARATED BY space.
        ENDIF.
        CONTINUE.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [3] Kiểm tra giá trị hợp lệ theo DOMAIN (nếu có)
      "-----------------------------------------------------------
      IF ls_ddic-domname IS NOT INITIAL.
        DATA(lt_dom_values) = VALUE dd07v_tab( ).
        CALL FUNCTION 'DD_DOMVALUES_GET'
          EXPORTING
            domname        = ls_ddic-domname
            text           = 'X'
          TABLES
            dd07v_tab      = lt_dom_values
          EXCEPTIONS
            wrong_textflag = 1
            OTHERS         = 2.

        IF sy-subrc = 0 AND lt_dom_values IS NOT INITIAL.
          DATA(lv_value_found) = abap_false.
          LOOP AT lt_dom_values INTO DATA(ls_dom).
            IF to_upper( ls_dom-domvalue_l ) = to_upper( lv_val_excel ).
              lv_value_found = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_value_found = abap_false.
            ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag2>).
            IF <lv_err_flag2> IS ASSIGNED.
              <lv_err_flag2> = 'X'.
            ENDIF.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [4] Gán giá trị vào field nếu hợp lệ
      "-----------------------------------------------------------
      TRY.
          <val> = lv_val_excel.
        CATCH cx_sy_conversion_error.
          ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag3>).
          IF <lv_err_flag3> IS ASSIGNED.
            <lv_err_flag3> = 'X'.
          ENDIF.
          CONTINUE.
      ENDTRY.
    ENDIF.
  ENDLOOP.

  "-----------------------------------------------------------
  " 🔹 [5] Kiểm tra trùng khóa chính trong Excel
  "-----------------------------------------------------------
  DATA(lt_keys) = VALUE string_table( ).
  LOOP AT lt_ddic_fields INTO DATA(ls_keyfld) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_keyfld-fieldname TO lt_keys.
  ENDLOOP.

  IF lt_keys IS NOT INITIAL.
    DATA(lt_seen_keys) = VALUE string_table( ).
    DATA(lv_key_string) = VALUE string( ).

    LOOP AT <lt_data> ASSIGNING <ls_data>.
      CLEAR lv_key_string.
      LOOP AT lt_keys INTO DATA(lv_keyfld).
        ASSIGN COMPONENT lv_keyfld OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_keyval>).
        IF <lv_keyval> IS ASSIGNED.
          lv_key_string = lv_key_string && to_upper( condense( <lv_keyval> ) ) && '|'.
        ENDIF.
      ENDLOOP.

      IF lv_key_string IS INITIAL.
        CONTINUE.
      ENDIF.

      READ TABLE lt_seen_keys WITH KEY table_line = lv_key_string TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        ASSIGN COMPONENT 'IS_DUPLICATE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_dupflag>).
        IF <lv_dupflag> IS ASSIGNED.
          <lv_dupflag> = 'X'.
        ENDIF.
        CONTINUE.
      ELSE.
        APPEND lv_key_string TO lt_seen_keys.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "-----------------------------------------------------------
  " 🔹 [7] Kiểm tra các trường bắt buộc (Key fields)
  "-----------------------------------------------------------
  DATA: lt_errors   TYPE STANDARD TABLE OF char255,
        lv_err_text TYPE char255.
  DATA(lt_required_fields) = VALUE string_table( ).

  LOOP AT lt_ddic_fields INTO DATA(ls_req) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_req-fieldname TO lt_required_fields.
  ENDLOOP.

  IF lt_required_fields IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      DATA(lv_missing_fields) = VALUE string( ).
      LOOP AT lt_required_fields INTO DATA(lv_req_field).
        ASSIGN COMPONENT lv_req_field OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_req_val>).
        IF <lv_req_val> IS ASSIGNED AND <lv_req_val> IS INITIAL.
          lv_missing_fields = lv_missing_fields && lv_req_field && ', '.
        ENDIF.
      ENDLOOP.

      IF lv_missing_fields IS NOT INITIAL.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag_req>).
        IF <lv_err_flag_req> IS ASSIGNED.
          <lv_err_flag_req> = 'X'.
        ENDIF.

        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_msg_flag>).
        IF <lv_msg_flag> IS ASSIGNED.
          CONCATENATE 'Thiếu dữ liệu bắt buộc: ' lv_missing_fields INTO <lv_msg_flag>.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "-----------------------------------------------------------
  " 🔹 [8] Hiển thị tất cả lỗi trong popup (nếu có)
  "-----------------------------------------------------------
  IF lt_errors IS NOT INITIAL.
    DATA(lv_err_count) = lines( lt_errors ).
    MESSAGE |Phát hiện { lv_err_count } lỗi trong dữ liệu upload.| TYPE 'I'.
    CALL FUNCTION 'POPUP_WITH_TABLE_DISPLAY_T'
      EXPORTING
        endpos_col   = 120
        endpos_row   = 25
        startpos_col = 5
        startpos_row = 2
        titletext    = |Danh sách lỗi dữ liệu (Tổng: { lv_err_count })|
      TABLES
        valuetab     = lt_errors
      EXCEPTIONS
        break_off    = 1
        OTHERS       = 2.
    IF sy-subrc = 1.
      MESSAGE 'Người dùng đã đóng popup lỗi' TYPE 'S'.
    ELSEIF sy-subrc = 2.
      MESSAGE 'Lỗi khi hiển thị popup lỗi' TYPE 'E'.
    ENDIF.
  ENDIF.

  "=== 7) Set flag NEWREC nếu có ===
  LOOP AT <lt_data> ASSIGNING <ls_data>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0.
      <newrec> = 'X'.
    ENDIF.
  ENDLOOP.

  DESCRIBE TABLE <lt_data> LINES DATA(lv_count).
  IF lv_count = 0.
    MESSAGE 'Không có dữ liệu hợp lệ sau upload!' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  DATA(lv_err) = VALUE string( ).
  PERFORM upload_save_data USING p_tab CHANGING <lt_data> lv_err lv_msg.

  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
  ELSE.
    MESSAGE lv_msg TYPE 'S'.
  ENDIF.

  PERFORM set_color.

  "-----------------------------------------------------------
  " 🔹 [11] Refresh lại ALV sau upload
  "-----------------------------------------------------------
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root INTO DATA(lx_err).
        MESSAGE lx_err->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDIF.

ENDFORM.


FORM download_template_xlsx.

  FIELD-SYMBOLS: <lt_template> TYPE STANDARD TABLE.

  "=== 1) Gọi hộp thoại để người dùng chọn đường dẫn ===
  DATA: lv_filename TYPE string,
        lv_path     TYPE string,
        lv_fullpath TYPE string,
        lv_action   TYPE i.

  cl_gui_frontend_services=>file_save_dialog(
  EXPORTING
  default_extension = 'xlsx'
  default_file_name = |TEMPLATE_{ p_tab }.xlsx|
  file_filter = 'Excel Files (*.xlsx) | *.xlsx'
  CHANGING
  filename = lv_filename
  path = lv_path
  fullpath = lv_fullpath
  user_action = lv_action
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Download template bị hủy' TYPE 'I'.
    RETURN.
  ENDIF.

  "=== 2) Tạo dòng mẫu dựa trên fieldcatalog (header thôi) ===
  DATA: lr_template TYPE REF TO data,
        lv_xstring  TYPE xstring,
        lt_cols     TYPE if_fdt_doc_spreadsheet=>t_column.

  PERFORM create_dynamic_itab USING p_tab
  CHANGING lr_template.

  ASSIGN lr_template->* TO <lt_template>.
  IF <lt_template> IS ASSIGNED.
    CLEAR <lt_template>.
    APPEND INITIAL LINE TO <lt_template>. "chỉ tạo 1 dòng trống
  ELSE.
    MESSAGE 'Không tạo được template từ bảng dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 3) Export nội dung ra file Excel ===
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols
      itab = lr_template
      iv_call_type = 2
      iv_sheet_name = 'TEMPLATE'
      RECEIVING
      xdocument = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "=== 4) Ghi file ra frontend ===
  DATA lt_bin TYPE solix_tab.
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).

  cl_gui_frontend_services=>gui_download(
  EXPORTING
  filename = lv_fullpath
  filetype = 'BIN'
  bin_filesize = xstrlen( lv_xstring )
  CHANGING
  data_tab = lt_bin
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Tải template thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file template' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.

*FORM upload_save_data USING p_tab TYPE tabname
*CHANGING pt_data TYPE STANDARD TABLE
*                  pv_err TYPE string
*                  pv_msg TYPE string.
*
*  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
*                 <ls_row>  TYPE any,
*                 <ls_wa>   TYPE any.
*
*  DATA: lv_tabname TYPE tabname,
*        lv_count   TYPE i,
*        lr_wa      TYPE REF TO data.
*
*  lv_tabname = p_tab.
*
*  ASSIGN pt_data TO <lt_data>.
*  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
*    pv_err = 'Không có dữ liệu hợp lệ để ghi vào DB.'.
*    RETURN.
*  ENDIF.
*
*  "--- tạo work area có kiểu tĩnh tương ứng
*  DATA lo_descr TYPE REF TO cl_abap_typedescr.
*  DATA lo_struct TYPE REF TO cl_abap_structdescr.
*
*  lo_descr = cl_abap_typedescr=>describe_by_name( lv_tabname ).
*  lo_struct ?= lo_descr.
*
*  CREATE DATA lr_wa TYPE HANDLE lo_struct.
*  ASSIGN lr_wa->* TO <ls_wa>.
*
*  TRY.
*      LOOP AT <lt_data> ASSIGNING <ls_row>.
*        MOVE-CORRESPONDING <ls_row> TO <ls_wa>.
*        INSERT (lv_tabname) FROM <ls_wa>.
*        COMMIT WORK AND WAIT.
*      ENDLOOP.
*
*      IF sy-subrc = 0.
*        COMMIT WORK AND WAIT.
*        DESCRIBE TABLE <lt_data> LINES lv_count.
*        pv_msg = |Đã lưu thành công { lv_count } dòng dữ liệu vào { lv_tabname }.|.
*
*        "=== Reload lại dữ liệu từ DB ===
*        FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
*        ASSIGN gr_data->* TO <lt_alv>.
*
*        IF <lt_alv> IS ASSIGNED.
*          DATA lr_temp TYPE REF TO data.
*          FIELD-SYMBOLS: <lt_temp> TYPE STANDARD TABLE,
*                         <ls_temp> TYPE any,
*                         <ls_alv>  TYPE any.
*
*          "Tạo table tạm có cùng cấu trúc DB
*          CREATE DATA lr_temp TYPE TABLE OF (lv_tabname).
*          ASSIGN lr_temp->* TO <lt_temp>.
*
*          "Đọc lại toàn bộ dữ liệu từ DB
*          SELECT * FROM (lv_tabname) INTO TABLE <lt_temp>.
*
*          "Xóa dữ liệu ALV cũ
*          REFRESH <lt_alv>.
*
*          "Chép dữ liệu DB vào ALV (dùng MOVE-CORRESPONDING để tránh dump)
*          LOOP AT <lt_temp> ASSIGNING <ls_temp>.
*            APPEND INITIAL LINE TO <lt_alv> ASSIGNING <ls_alv>.
*            MOVE-CORRESPONDING <ls_temp> TO <ls_alv>.
*          ENDLOOP.
*        ENDIF.
*
*        "=== Refresh lại ALV grid để hiển thị ngay dữ liệu ===
*        IF g_alv_grid IS BOUND.
*          g_alv_grid->refresh_table_display(
*            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' )
*          ).
*        ENDIF.
*
*      ELSE.
*        pv_err = |Không thể ghi dữ liệu vào bảng { lv_tabname }.|.
*      ENDIF.
*
*    CATCH cx_sy_dynamic_osql_error INTO DATA(lx_sql).
*      pv_err = lx_sql->get_text( ).
*  ENDTRY.
*
*ENDFORM.
FORM upload_save_data USING p_tab TYPE tabname
CHANGING pt_data TYPE STANDARD TABLE
                  pv_err TYPE string
                  pv_msg TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any,
                 <ls_wa>   TYPE any,
                 <val_new> TYPE any,
                 <val_old> TYPE any.

  DATA: lv_tabname TYPE tabname,
        lv_count   TYPE i,
        lr_wa      TYPE REF TO data.

  lv_tabname = p_tab.

  ASSIGN pt_data TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    pv_err = 'Không có dữ liệu hợp lệ để ghi vào DB.'.
    RETURN.
  ENDIF.

  "--- tạo work area có kiểu tĩnh tương ứng
  DATA lo_descr TYPE REF TO cl_abap_typedescr.
  DATA lo_struct TYPE REF TO cl_abap_structdescr.

  lo_descr = cl_abap_typedescr=>describe_by_name( lv_tabname ).
  lo_struct ?= lo_descr.

  CREATE DATA lr_wa TYPE HANDLE lo_struct.
  ASSIGN lr_wa->* TO <ls_wa>.

  "--- Lấy metadata của bảng để biết key fields
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        lt_key_fields  TYPE STANDARD TABLE OF string,
        ls_ddic_field  TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = lv_tabname
    TABLES
      dfies_tab = lt_ddic_fields
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_ddic_field-fieldname TO lt_key_fields.
  ENDLOOP.

  TRY.

      LOOP AT <lt_data> ASSIGNING <ls_row>.
        " Bỏ qua dòng bị lỗi validate
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_err_flag>).
        IF <lv_err_flag> IS ASSIGNED AND <lv_err_flag> = 'X'.
          CONTINUE. " Không ghi dòng này vào DB
        ENDIF.

        "--- 1) Kiểm tra dòng này có tồn tại trong DB không
        DATA(lv_where) = ``.
        LOOP AT lt_key_fields INTO DATA(lv_key).
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_kval>).
          IF <lv_kval> IS ASSIGNED.
            IF lv_where IS INITIAL.
              lv_where = |{ lv_key } = '{ <lv_kval> }'|.
            ELSE.
              lv_where = |{ lv_where } AND { lv_key } = '{ <lv_kval> }'|.
            ENDIF.
          ENDIF.
        ENDLOOP.

        DATA lr_db TYPE REF TO data.
        FIELD-SYMBOLS: <ls_db> TYPE any.

        CREATE DATA lr_db TYPE HANDLE lo_struct.
        ASSIGN lr_db->* TO <ls_db>.

        SELECT SINGLE * FROM (lv_tabname) INTO @<ls_db> WHERE (lv_where).

        IF sy-subrc = 0.
          LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE fieldname <> 'MANDT'.
            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_row> TO <val_new>.
            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_db> TO <val_old>.

            IF <val_new> IS ASSIGNED AND <val_new> IS NOT INITIAL.
              <val_old> = <val_new>. " ghi đè field có giá trị mới
            ENDIF.
          ENDLOOP.

          MOVE-CORRESPONDING <ls_db> TO <ls_wa>.
          MODIFY (lv_tabname) FROM <ls_wa>.

        ELSE.
          "=== 3) DÒNG MỚI → INSERT NHƯ BÌNH THƯỜNG ===
          MOVE-CORRESPONDING <ls_row> TO <ls_wa>.
          INSERT (lv_tabname) FROM <ls_wa>.
        ENDIF.

      ENDLOOP.

      COMMIT WORK AND WAIT.

      "--- 4) Thông báo kết quả
      DESCRIBE TABLE <lt_data> LINES lv_count.
      pv_msg = |Đã lưu thành công { lv_count } dòng dữ liệu vào { lv_tabname }.|.

      "--- 5) Reload lại dữ liệu từ DB vào ALV
      FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
      ASSIGN gr_data->* TO <lt_alv>.

      IF <lt_alv> IS ASSIGNED.
        DATA lr_temp TYPE REF TO data.
        FIELD-SYMBOLS: <lt_temp> TYPE STANDARD TABLE,
                       <ls_temp> TYPE any,
                       <ls_alv>  TYPE any.

        CREATE DATA lr_temp TYPE TABLE OF (lv_tabname).
        ASSIGN lr_temp->* TO <lt_temp>.

        SELECT * FROM (lv_tabname) INTO TABLE <lt_temp>.

        REFRESH <lt_alv>.
        LOOP AT <lt_temp> ASSIGNING <ls_temp>.
          APPEND INITIAL LINE TO <lt_alv> ASSIGNING <ls_alv>.
          MOVE-CORRESPONDING <ls_temp> TO <ls_alv>.
        ENDLOOP.
      ENDIF.

      "--- 6) Refresh lại ALV grid
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' )
        ).
      ENDIF.

    CATCH cx_sy_dynamic_osql_error INTO DATA(lx_sql).
      pv_err = lx_sql->get_text( ).
  ENDTRY.

ENDFORM.






*=====================================================================*
* FORM download_excel_xlsx – Export dữ liệu ra Excel gồm 2 sheet *
*=====================================================================*
FORM download_excel_xlsx USING ir_data TYPE REF TO data.

  TYPES: BEGIN OF ty_field_help,
           fieldname TYPE string,
           heading   TYPE string,
           tooltip   TYPE string,
         END OF ty_field_help.

  FIELD-SYMBOLS: <lt_original> TYPE STANDARD TABLE,
                 <ls_original> TYPE any,
                 <lt_no_style> TYPE STANDARD TABLE,
                 <ls_no_style> TYPE any,
                 <lt_help>     TYPE STANDARD TABLE,
                 <ls_help>     TYPE any.

  DATA: lr_data_no_style TYPE REF TO data,
        lv_filename      TYPE string,
        lv_path          TYPE string,
        lv_fullpath      TYPE string,
        lv_action        TYPE i,
        lv_xstring_data  TYPE xstring,
        lv_xstring_help  TYPE xstring,
        lt_bin           TYPE solix_tab,
        lt_cols_data     TYPE if_fdt_doc_spreadsheet=>t_column,
        lt_cols_help     TYPE if_fdt_doc_spreadsheet=>t_column,
        lt_help_raw      TYPE STANDARD TABLE OF ty_field_help,
        lr_help_raw      TYPE REF TO data,
        lt_meta          TYPE ddfields.

  "== 1) Gọi hộp thoại chọn nơi lưu file ==
  cl_gui_frontend_services=>file_save_dialog(
  EXPORTING
  default_extension = 'xlsx'
  default_file_name = |DATA_{ p_tab }_{ sy-datum }_{ sy-uzeit }.xlsx|
  file_filter = 'Excel Files (*.xlsx)|*.xlsx'
  CHANGING
  filename = lv_filename
  path = lv_path
  fullpath = lv_fullpath
  user_action = lv_action
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Export bị hủy' TYPE 'S'.
    RETURN.
  ENDIF.

  "== 2) Chuẩn bị dữ liệu gốc (DATA sheet) ==
  ASSIGN ir_data->* TO <lt_original>.
  IF <lt_original> IS NOT ASSIGNED.
    MESSAGE 'Dữ liệu không hợp lệ' TYPE 'S'.
    RETURN.
  ENDIF.

  PERFORM create_dynamic_itab_no_style USING p_tab CHANGING lr_data_no_style.
  ASSIGN lr_data_no_style->* TO <lt_no_style>.

  LOOP AT <lt_original> ASSIGNING <ls_original>.
    APPEND INITIAL LINE TO <lt_no_style> ASSIGNING <ls_no_style>.
    MOVE-CORRESPONDING <ls_original> TO <ls_no_style>.
  ENDLOOP.

  "== 3) Lấy metadata từ DDIC để tạo sheet mô tả ==
  PERFORM get_metadata USING p_tab CHANGING lt_meta.

  LOOP AT lt_meta INTO DATA(ls_ddic).
    APPEND VALUE ty_field_help(
    fieldname = ls_ddic-fieldname
    heading = ls_ddic-scrtext_l
    tooltip = ls_ddic-scrtext_m ) TO lt_help_raw.
  ENDLOOP.

  CREATE DATA lr_help_raw LIKE lt_help_raw.
  ASSIGN lr_help_raw->* TO <lt_help>.
  <lt_help> = lt_help_raw.

  "== 4) Tạo sheet DATA ==
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols_data
      itab = lr_data_no_style
      iv_call_type = 2
      iv_sheet_name = 'DATA'
      RECEIVING
      xdocument = lv_xstring_data ).
    CATCH cx_root INTO DATA(lx_data).
      MESSAGE lx_data->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "== 5) Tạo sheet Input help ==
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols_help
      itab = lr_help_raw
      iv_call_type = 2
      iv_sheet_name = 'Input help'
      RECEIVING
      xdocument = lv_xstring_help ).
    CATCH cx_root INTO DATA(lx_help).
      MESSAGE lx_help->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "== 6) Gộp tạm 2 xstring (không chuẩn multi-sheet nhưng chấp nhận được)==
  CONCATENATE lv_xstring_data lv_xstring_help INTO lv_xstring_data IN BYTE MODE.

  "== 7) Ghi file ra frontend ==
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring_data ).

  cl_gui_frontend_services=>gui_download(
  EXPORTING
  filename = lv_fullpath
  filetype = 'BIN'
  bin_filesize = xstrlen( lv_xstring_data )
  CHANGING
  data_tab = lt_bin
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Xuất dữ liệu thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM set_color – Tô màu dòng trong ALV sau khi upload
*---------------------------------------------------------------------*
FORM set_color.

  FIELD-SYMBOLS: <lt_data>   TYPE STANDARD TABLE,
                 <ls_data>   TYPE any,
                 <celltab>   TYPE lvc_t_styl,
                 <row_color> TYPE lvc_t_scol,
                 <color>     TYPE lvc_s_scol,
                 <is_error>  TYPE any.

  " Gán tới dữ liệu hiện tại của ALV
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    RETURN.
  ENDIF.

  " Lặp qua từng dòng dữ liệu
  LOOP AT <lt_data> ASSIGNING <ls_data>.

    " Nếu ALV có field màu (CELLTAB) hoặc COLOR, ta đảm bảo nó tồn tại
    ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls_data> TO <row_color>.
    IF sy-subrc <> 0.
      ASSIGN COMPONENT 'COLOR' OF STRUCTURE <ls_data> TO <row_color>.
    ENDIF.

    " Nếu không có, bỏ qua
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    CLEAR <row_color>.

    " Kiểm tra cờ lỗi IS_ERROR
    ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO <is_error>.
    IF sy-subrc = 0 AND <is_error> = 'X'.
      " 🔴 Dòng lỗi → tô đỏ (C600)
      CLEAR <color>.
      <color>-fname = ''.
      <color>-color-col = 6. " Red
      <color>-color-int = 0.
      <color>-color-inv = 0.
      APPEND <color> TO <row_color>.
    ELSE.
      " 🟢 Dòng hợp lệ → tô xanh lá (C500)
      CLEAR <color>.
      <color>-fname = ''.
      <color>-color-col = 5. " Green
      <color>-color-int = 0.
      <color>-color-inv = 0.
      APPEND <color> TO <row_color>.
    ENDIF.

  ENDLOOP.

  " Refresh ALV để hiển thị màu ngay
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

ENDFORM.
*FORM set_color.
*
*  FIELD-SYMBOLS:
*    <lt_data>  TYPE STANDARD TABLE,
*    <ls_data>  TYPE any,
*    <celltab>  TYPE lvc_t_styl,
*    <is_error> TYPE any,
*    <val>      TYPE any.
*
*  DATA: ls_style TYPE lvc_s_styl,
*        lo_descr TYPE REF TO cl_abap_structdescr,
*        lt_comp  TYPE abap_component_tab,
*        lv_field TYPE fieldname.
*
*  " Gán dữ liệu ALV hiện tại
*  ASSIGN gr_data->* TO <lt_data>.
*  IF <lt_data> IS INITIAL.
*    RETURN.
*  ENDIF.
*
*  " Dùng class mô tả dòng dữ liệu
*DATA lo_table TYPE REF TO cl_abap_tabledescr.
*DATA lo_line  TYPE REF TO cl_abap_structdescr.
*
*lo_descr = cl_abap_typedescr=>describe_by_data( <lt_data> ).
*lo_table ?= CAST cl_abap_tabledescr( lo_descr ).
*lo_line  ?= CAST cl_abap_structdescr( lo_table->get_table_line_type( ) ).
*lt_comp  = lo_line->get_components( ).
*
*
*  LOOP AT <lt_data> ASSIGNING <ls_data>.
*
*    ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls_data> TO <celltab>.
*    IF sy-subrc <> 0.
*      CONTINUE.
*    ENDIF.
*
*    CLEAR <celltab>.
*
*    LOOP AT lt_comp INTO DATA(ls_comp).
*      lv_field = ls_comp-name.
*
*      " Bỏ qua field kỹ thuật
*      IF lv_field = 'CELLTAB' OR lv_field = 'ROW_COLOR' OR
*         lv_field = 'IS_ERROR' OR lv_field = 'IS_MESSAGE'.
*        CONTINUE.
*      ENDIF.
*
*      ASSIGN COMPONENT lv_field OF STRUCTURE <ls_data> TO <val>.
*      IF sy-subrc <> 0 OR val IS INITIAL.
*        CONTINUE.
*      ENDIF.
*
*      CLEAR ls_style.
*      ls_style-fieldname = lv_field.
*
*      ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO <is_error>.
*      IF sy-subrc = 0 AND <is_error> = 'X'.
*        ls_style-style = 5. " ô màu đỏ
*      ELSE.
*        ls_style-style = 6. " ô màu vàng/xanh nhạt
*      ENDIF.
*
*      APPEND ls_style TO <celltab>.
*    ENDLOOP.
*
*  ENDLOOP.
*
*  " Refresh lại ALV để cập nhật màu
*  IF g_alv_grid IS BOUND.
*    TRY.
*        g_alv_grid->refresh_table_display(
*          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' )
*        ).
*      CATCH cx_root.
*    ENDTRY.
*  ENDIF.
*
*ENDFORM.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_AUDIT (classic-syntax, no templates/inline)
*&---------------------------------------------------------------------*

* Cache key fields for current table
FORM ensure_keys USING iv_tab TYPE tabname.
  DATA lv_tab TYPE tabname.
  IF gv_keys_tabname <> iv_tab.
    CLEAR gt_key_fields.
    gv_keys_tabname = iv_tab.
  ENDIF.

  " Upper-case để khớp DDIC
  lv_tab = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  IF gt_key_fields IS INITIAL.
    SELECT fieldname
      FROM dd03l
      INTO TABLE @gt_key_fields
      WHERE tabname  = @lv_tab
        AND as4local = 'A'
        AND keyflag  = 'X'
        AND fieldname <> 'MANDT'.
  ENDIF.

  " Fallback từ fieldcatalog nếu DD03L không trả về
  IF gt_key_fields IS INITIAL AND gt_fieldcat IS NOT INITIAL.
    FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
    LOOP AT gt_fieldcat ASSIGNING <fc>.
      IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
        CONTINUE.
      ENDIF.
      IF <fc>-key = 'X' AND to_upper( <fc>-fieldname ) <> 'MANDT'.
        APPEND <fc>-fieldname TO gt_key_fields.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM ensure_celltab_component CHANGING cr_tab TYPE REF TO data.
  TYPE-POOLS abap.

  DATA: lo_tab      TYPE REF TO cl_abap_tabledescr,
        lo_line     TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lv_has_cell TYPE abap_bool,
        lv_has_new  TYPE abap_bool,
        lo_cell_any TYPE REF TO cl_abap_typedescr,
        lo_cell_dat TYPE REF TO cl_abap_datadescr,
        lo_bool_dat TYPE REF TO cl_abap_datadescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_new      TYPE REF TO data,
        lr_row      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).




  CLEAR: lv_has_cell, lv_has_new.
  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'CELLTAB'. lv_has_cell = abap_true. ENDIF.
    IF ls_comp-name = 'NEWREC'.  lv_has_new  = abap_true. ENDIF.
  ENDLOOP.

  IF lv_has_cell = abap_true AND lv_has_new = abap_true.
    RETURN. " đã có đủ hai cột kỹ thuật
  ENDIF.

  " Thêm CELLTAB: LVC_T_STYL
  IF lv_has_cell = abap_false.
    lo_cell_any = cl_abap_typedescr=>describe_by_name( 'LVC_T_STYL' ).
    lo_cell_dat ?= lo_cell_any.
    CLEAR ls_comp.
    ls_comp-name = 'CELLTAB'.
    ls_comp-type = lo_cell_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Thêm NEWREC: C(1)
  IF lv_has_new = abap_false.
    lo_bool_dat = cl_abap_elemdescr=>get_c( 1 ).
    CLEAR ls_comp.
    ls_comp-name = 'NEWREC'.
    ls_comp-type = lo_bool_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Tạo lại line type + table type mới
  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  IF <lt_old> IS ASSIGNED AND <lt_new> IS ASSIGNED.
    LOOP AT <lt_old> ASSIGNING <ls_old>.
      CREATE DATA lr_row TYPE HANDLE lo_newline.
      ASSIGN lr_row->* TO <ls_new>.
      MOVE-CORRESPONDING <ls_old> TO <ls_new>.
      APPEND <ls_new> TO <lt_new>.
    ENDLOOP.
    cr_tab = lr_new. " ref mới có CELLTAB + NEWREC
  ENDIF.
ENDFORM.

*=== Helper: escape dấu nháy đơn cho literal SQL
FORM _escape_single_quote USING    iv_in  TYPE string
                          CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH ''''''.
ENDFORM.

* Build dynamic WHERE from key fields (type-aware, with escaping)
FORM make_where_from_key USING    is_str  TYPE any
                                  it_keys TYPE STANDARD TABLE
                         CHANGING ev_where TYPE string
                                  ev_err   TYPE string.
  CLEAR: ev_where, ev_err.
  DATA lv_cond TYPE string.
  FIELD-SYMBOLS: <val>   TYPE any, <fname> TYPE dd03l-fieldname.

  DATA all_empty TYPE abap_bool VALUE abap_true.

  DATA lo_td TYPE REF TO cl_abap_typedescr.

  LOOP AT it_keys ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE is_str TO <val>.
    IF sy-subrc = 0 AND <val> IS ASSIGNED AND <val> IS NOT INITIAL.
      all_empty = abap_false.

      " Xác định kiểu để format
      lo_td ?= cl_abap_typedescr=>describe_by_data( <val> ).
      DATA(lv_tk) = lo_td->type_kind.

      DATA(lv_piece) = ``.
      IF lv_tk = 'I' OR lv_tk = 'P' OR lv_tk = 'F' OR lv_tk = 'N'.
        " numeric literal (không dùng quote)
        lv_piece = |{ <fname> } = { <val> }|.
      ELSE.
        " char/date/time/... -> escape quote và bọc quote
        DATA(lv_s) = |{ <val> }|.
        PERFORM _escape_single_quote USING lv_s CHANGING lv_s.
        lv_piece = |{ <fname> } = '{ lv_s }'|.
      ENDIF.

      IF lv_cond IS INITIAL.
        lv_cond = lv_piece.
      ELSE.
        CONCATENATE lv_cond lv_piece INTO lv_cond SEPARATED BY ' AND '.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF all_empty = abap_true.
    ev_err = 'Tất cả trường khóa đều rỗng.'.
    RETURN.
  ENDIF.

  IF lv_cond IS INITIAL.
    ev_err = 'Không tạo được điều kiện khóa.'.
  ELSE.
    ev_where = lv_cond.
  ENDIF.
ENDFORM.

* Serialize any structure to JSON (fallback XML) into ZDE_JSON_TXT
FORM to_json USING is_any TYPE any
             CHANGING cv_json TYPE zde_json_txt.
  DATA lv_str TYPE string.
  CLEAR lv_str.
  " Đồng bộ pretty_mode-none để khớp json_to_itab
  TRY.
      lv_str = /ui2/cl_json=>serialize(
                 data        = is_any
                 pretty_name = /ui2/cl_json=>pretty_mode-none ).
    CATCH cx_root.
      TRY.
          CALL TRANSFORMATION id
            SOURCE data = is_any
            RESULT XML lv_str.
        CATCH cx_root.
          lv_str = '<<serialize failed>>'.
      ENDTRY.
  ENDTRY.
  cv_json = lv_str.
ENDFORM.

* Check key when adding: key must be filled & not exist in DB
FORM check_key_on_add USING    iv_tab  TYPE tabname
                      CHANGING ev_err  TYPE string.

  DATA: lv_first_key   TYPE dd03l-fieldname,
        lv_where       TYPE string,
        lv_msg         TYPE string,
        lv_label       TYPE string,
        lv_exist_dummy TYPE string.

  FIELD-SYMBOLS: <lt>    TYPE STANDARD TABLE,
                 <ls>    TYPE any,
                 <comp>  TYPE any,
                 <fname> TYPE dd03l-fieldname.

  CLEAR ev_err.

  " Chỉ kiểm tra khi đang ở chế độ Add
  IF gv_add_mode IS INITIAL.
    RETURN.
  ENDIF.

  " Lấy dòng NEW (giả định dòng cuối)
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS INITIAL.
    ev_err = 'Không có dữ liệu để kiểm tra.'.
    RETURN.
  ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX lines( <lt> ).
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED.
    ev_err = 'Không xác định được dòng mới.'.
    RETURN.
  ENDIF.

  " Lấy key fields
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC.'.
    RETURN.
  ENDIF.

  " ============ 1) Nếu tất cả khóa rỗng ============
  DATA(lv_all_empty) = abap_true.
  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc = 0 AND <comp> IS NOT INITIAL.
      lv_all_empty = abap_false.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_all_empty = abap_true.
    READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
    IF lv_first_key IS INITIAL.
      ev_err = 'Dòng mới đang trống. Vui lòng nhập khóa.'.
    ELSE.
      ev_err = |Dòng mới đang trống. Vui lòng nhập trường khóa đầu tiên: { lv_first_key }|.
    ENDIF.

    " Focus caret vào ô KEY đầu tiên
    TRY.
        DATA: ls_row TYPE lvc_s_row,
              ls_col TYPE lvc_s_col.
        ls_row-index     = lines( <lt> ).
        ls_col-fieldname = COND #( WHEN lv_first_key IS INITIAL
                                   THEN gt_key_fields[ 1 ]
                                   ELSE lv_first_key ).
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = ls_row
                      is_column_id = ls_col ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = ls_row
                      is_col_info = ls_col ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.

    RETURN. " Dừng save
  ENDIF.

  " ============ 2) Kiểm tra từng field khóa ============
  DATA: lt_dfies TYPE STANDARD TABLE OF dfies,
        ls_dfies TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tab
      all_types = 'X'
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc <> 0 OR <comp> IS INITIAL.

      CLEAR lv_label.
      READ TABLE lt_dfies INTO ls_dfies WITH KEY fieldname = <fname>.
      IF sy-subrc = 0.
        lv_label = COND #( WHEN ls_dfies-scrtext_m IS NOT INITIAL THEN ls_dfies-scrtext_m
                           WHEN ls_dfies-scrtext_l IS NOT INITIAL THEN ls_dfies-scrtext_l
                           ELSE ls_dfies-scrtext_s ).
      ENDIF.

      ev_err = COND #( WHEN lv_label IS INITIAL
                       THEN |Trường khóa { <fname> } đang rỗng|
                       ELSE |Trường khóa { <fname> } ({ lv_label }) đang rỗng| ).

      TRY.
          DATA: l_row TYPE lvc_s_row,
                l_col TYPE lvc_s_col.
          l_row-index     = lines( <lt> ).
          l_col-fieldname = <fname>.
          IF g_alv_grid IS BOUND.
            g_alv_grid->set_current_cell_via_id(
              EXPORTING is_row_id    = l_row
                        is_column_id = l_col ).
            g_alv_grid->set_scroll_info_via_id(
              EXPORTING is_row_info = l_row
                        is_col_info = l_col ).
          ENDIF.
        CATCH cx_root.
      ENDTRY.

      RETURN.
    ENDIF.
  ENDLOOP.

  " ============ 3) Kiểm tra trùng khóa trong DB ============
  PERFORM make_where_from_key USING <ls> gt_key_fields
                       CHANGING lv_where lv_msg.
  IF lv_where IS INITIAL.
    ev_err = COND #( WHEN lv_msg IS INITIAL THEN 'Không tạo được điều kiện khóa.' ELSE lv_msg ).
    RETURN.
  ENDIF.

  READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
  IF lv_first_key IS INITIAL.
    ev_err = 'Không xác định được trường khóa để kiểm tra trùng.'.
    RETURN.
  ENDIF.

  TRY.

      SELECT SINGLE (lv_first_key)
        FROM (iv_tab)
        WHERE (lv_where)
        INTO @lv_exist_dummy.
    CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syn).
      ev_err = |Lỗi cú pháp WHERE "{ lv_where }": { lx_syn->get_text( ) }|.
      RETURN.
  ENDTRY.

  IF sy-subrc = 0.
    ev_err = |Khóa đã tồn tại trong { iv_tab }. Vui lòng nhập khóa khác.|.

    TRY.
        DATA: l_row2 TYPE lvc_s_row,
              l_col2 TYPE lvc_s_col.
        l_row2-index     = lines( <lt> ).
        l_col2-fieldname = lv_first_key.
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = l_row2
                      is_column_id = l_col2 ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = l_row2
                      is_col_info = l_col2 ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.
  ENDIF.

ENDFORM.



FORM on_save.
  DATA: lv_mod     TYPE i,
        lv_err     TYPE string,
        lv_ck      TYPE string,
        lv_msg     TYPE c LENGTH 120,
        lv_skipped TYPE i VALUE 0. "⚙️ Đếm số dòng bị bỏ qua

  DATA lr_to_save TYPE REF TO data.
  DATA lo_line TYPE REF TO cl_abap_structdescr.
  DATA lo_tab  TYPE REF TO cl_abap_tabledescr.
  FIELD-SYMBOLS: <lt_to_save> TYPE STANDARD TABLE, <ls_to_save> TYPE any.

  " 1) Check keys cho ADD
  CLEAR lv_ck.
  PERFORM check_key_on_add USING p_tab CHANGING lv_ck.
  IF lv_ck IS NOT INITIAL.
    MESSAGE lv_ck TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Build audit (INSERT/UPDATE)
  REFRESH gt_audit.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE, <ls_data> TYPE any.
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS ASSIGNED.
    PERFORM ensure_keys USING p_tab.
    IF gt_key_fields IS INITIAL.
      MESSAGE 'Bảng không có khóa trong DDIC.' TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    DATA: lv_where        TYPE string,
          lv_we           TYPE string,
          lv_newrec_count TYPE i VALUE 0.

    DATA lr_db_struct TYPE REF TO cl_abap_structdescr.
    lr_db_struct ?= cl_abap_typedescr=>describe_by_name( p_tab ).
    DATA lr_now_db TYPE REF TO data.
    DATA lr_old_db TYPE REF TO data.
    CREATE DATA lr_now_db TYPE HANDLE lr_db_struct.
    CREATE DATA lr_old_db TYPE HANDLE lr_db_struct.
    FIELD-SYMBOLS: <ls_db_now> TYPE any,
                   <ls_db_old> TYPE any,
                   <fs_mandt>  TYPE any.
    ASSIGN lr_now_db->* TO <ls_db_now>.
    ASSIGN lr_old_db->* TO <ls_db_old>.

    LOOP AT <lt_data> ASSIGNING <ls_data>.

      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<newrec>).
      DATA(lv_is_new) = xsdbool( sy-subrc = 0 AND <newrec> = 'X' ).

      "=== NEWREC: nếu tất cả KEY trống -> BỎ QUA, không RETURN
      IF lv_is_new = abap_true.
        DATA(all_empty) = abap_true.
        FIELD-SYMBOLS: <comp>  TYPE any, <fname> TYPE dd03l-fieldname.
        LOOP AT gt_key_fields ASSIGNING <fname>.
          ASSIGN COMPONENT <fname> OF STRUCTURE <ls_data> TO <comp>.
          IF sy-subrc = 0 AND <comp> IS NOT INITIAL.
            all_empty = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF all_empty = abap_true.
          MESSAGE |Dòng mới đang trống. Bỏ qua dòng này khi lưu.| TYPE 'S' DISPLAY LIKE 'W'.
          lv_skipped += 1.
          CONTINUE. "⚙️ Không RETURN nữa, chỉ bỏ qua dòng trống
        ENDIF.

        " Chặn nhiều hơn 1 dòng NEWREC='X'
        lv_newrec_count = lv_newrec_count + 1.
        IF lv_newrec_count > 1.
          MESSAGE |Lỗi: Tìm thấy { lv_newrec_count } dòng NEWREC='X'. Chỉ được phép 1 dòng mới!| TYPE 'S' DISPLAY LIKE 'E'.
          lv_skipped += 1.
          CONTINUE.
        ENDIF.
      ENDIF.

      "=== Xây WHERE theo KEY
      CLEAR: lv_where, lv_we.
      PERFORM make_where_from_key USING <ls_data> gt_key_fields CHANGING lv_where lv_we.
      IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
        MESSAGE |Bỏ qua dòng do lỗi key fields: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
        lv_skipped += 1.
        CONTINUE. "⚙️ Không RETURN nữa, chỉ bỏ qua dòng lỗi
      ENDIF.

      "=== Lazy init danh sách cần lưu
      IF lo_line IS INITIAL.
        lo_line ?= cl_abap_typedescr=>describe_by_data( <ls_data> ).
        lo_tab  = cl_abap_tabledescr=>create( p_line_type = lo_line ).
        CREATE DATA lr_to_save TYPE HANDLE lo_tab.
        ASSIGN lr_to_save->* TO <lt_to_save>.
      ENDIF.

      "=== Đọc bản ghi cũ (pre-image) từ DB
      DATA lr_old TYPE REF TO data.
      CREATE DATA lr_old LIKE <ls_data>.
      FIELD-SYMBOLS: <ls_old> TYPE any.
      ASSIGN lr_old->* TO <ls_old>.
      CLEAR <ls_old>.

      TRY.
          SELECT SINGLE * FROM (p_tab)
            WHERE (lv_where)
            INTO CORRESPONDING FIELDS OF @<ls_old>.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lxsql).
          MESSAGE lxsql->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
          CLEAR <ls_old>.
          sy-subrc = 4.
      ENDTRY.

      "=== Phân loại audit + đưa vào danh sách lưu
      IF lv_is_new = abap_true AND sy-subrc <> 0.
        " INSERT
        DATA ls_a_i TYPE ty_audit.
        CLEAR ls_a_i.
        ls_a_i-tabname = p_tab.
        ls_a_i-action  = 'INSERT'.
        ls_a_i-uname   = sy-uname.
        ls_a_i-udate   = sy-datum.
        ls_a_i-utime   = sy-uzeit.
        PERFORM to_json USING <ls_data> CHANGING ls_a_i-after_json.
        CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_i-logid.
        APPEND ls_a_i TO gt_audit.

        IF <lt_to_save> IS ASSIGNED.
          APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
          MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
        ENDIF.
      ELSE.
        " UPDATE (khi khác DB)
        CLEAR: <ls_db_now>, <ls_db_old>.
        MOVE-CORRESPONDING <ls_data> TO <ls_db_now>.
        MOVE-CORRESPONDING <ls_old>  TO <ls_db_old>.
        ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_db_now> TO <fs_mandt>.
        IF sy-subrc = 0 AND <fs_mandt> IS ASSIGNED.
          <fs_mandt> = sy-mandt.
        ENDIF.

        IF <ls_db_old> <> <ls_db_now> OR ( lv_is_new = abap_true AND sy-subrc = 0 ).
          DATA ls_a_u TYPE ty_audit.
          CLEAR ls_a_u.
          ls_a_u-tabname = p_tab.
          ls_a_u-action  = 'UPDATE'.
          ls_a_u-uname   = sy-uname.
          ls_a_u-udate   = sy-datum.
          ls_a_u-utime   = sy-uzeit.
          PERFORM to_json USING <ls_old>  CHANGING ls_a_u-before_json.
          PERFORM to_json USING <ls_data> CHANGING ls_a_u-after_json.
          CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_u-logid.
          APPEND ls_a_u TO gt_audit.

          IF <lt_to_save> IS ASSIGNED.
            APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
            MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
          ENDIF.
        ENDIF.
      ENDIF.

      " Xóa cờ NEWREC sau khi qua kiểm tra
      IF lv_is_new = abap_true.
        CLEAR <newrec>.
      ENDIF.

    ENDLOOP.
  ENDIF.

  " 3) Lưu xuống DB
  IF <lt_to_save> IS NOT ASSIGNED OR <lt_to_save> IS INITIAL.
    IF lv_skipped > 0.
      MESSAGE |Không có dòng hợp lệ để lưu. { lv_skipped } dòng bị bỏ qua.| TYPE 'S' DISPLAY LIKE 'W'.
    ELSE.
      MESSAGE 'Không có dữ liệu để lưu.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
    CLEAR: gv_add_mode, gv_edit_md, gv_toolbar_mode.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    IF g_alv_grid IS BOUND.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    ENDIF.
    RETURN.
  ENDIF.

  PERFORM save_data USING p_tab
                    CHANGING lr_to_save
                             lv_mod
                             lv_err.
  IF lv_err IS NOT INITIAL.
    ROLLBACK WORK.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 4) Ghi audit log
  TYPES: BEGIN OF ty_audit_db,
           mandt       TYPE mandt,
           logid       TYPE char32,
           uname       TYPE syuname,
           udate       TYPE sydatum,
           utime       TYPE syuzeit,
           tabname     TYPE tabname,
           action      TYPE char10,
           before_json TYPE zde_json_txt,
           after_json  TYPE zde_json_txt,
         END OF ty_audit_db.

  DATA wa_log TYPE ty_audit_db.
  DATA lv_audit_tab TYPE tabname VALUE 'ZAUDIT_LOG'.

  LOOP AT gt_audit ASSIGNING FIELD-SYMBOL(<a>).
    CLEAR wa_log.
    wa_log-mandt       = sy-mandt.
    wa_log-logid       = <a>-logid.
    wa_log-uname       = <a>-uname.
    wa_log-udate       = <a>-udate.
    wa_log-utime       = <a>-utime.
    wa_log-tabname     = <a>-tabname.
    wa_log-action      = <a>-action.
    wa_log-before_json = <a>-before_json.
    wa_log-after_json  = <a>-after_json.
    INSERT (lv_audit_tab) FROM @wa_log.
  ENDLOOP.

  " 5) Commit & reload & refresh ALV
*  COMMIT WORK AND WAIT.
*
*  DATA(lv_rows)  = 0.
*  DATA(lv_err2)  = VALUE string( ).
*  PERFORM load_data USING p_tab 0 CHANGING gr_data lv_rows lv_err2.
*  IF lv_err2 IS NOT INITIAL.
*    MESSAGE lv_err2 TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  gv_dirty = abap_false.
*  gv_add_mode     = abap_false.
*  gv_edit_md      = abap_false.
*  gv_toolbar_mode = 'D'.
*
*  TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
*  IF g_alv_grid IS BOUND.
*    g_alv_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
*  ENDIF.

  COMMIT WORK AND WAIT.

  FIELD-SYMBOLS: <lt_cur> TYPE STANDARD TABLE, <ls_cur> TYPE any,
                 <lt_db>  TYPE STANDARD TABLE, <ls_db> TYPE any.

  ASSIGN gr_data->* TO <lt_cur>.
  IF <lt_cur> IS ASSIGNED.

    " Đọc lại data thật từ DB
    DATA lo_struct TYPE REF TO cl_abap_structdescr.
    lo_struct ?= cl_abap_typedescr=>describe_by_name( p_tab ).
    DATA(lo_dbtab) = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

    DATA lr_db TYPE REF TO data.
    CREATE DATA lr_db TYPE HANDLE lo_dbtab.
    ASSIGN lr_db->* TO <lt_db>.
    TRY.
        SELECT * FROM (p_tab) INTO TABLE <lt_db>.
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_sql).
        MESSAGE lx_sql->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
    " Merge lại: update phần data thật từ DB, giữ nguyên 6 field audit
    LOOP AT <lt_cur> ASSIGNING <ls_cur>.
      FIELD-SYMBOLS: <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any,
                     <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any.
      ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_cur> TO <aedat>.
      ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_cur> TO <aetim>.
      ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_cur> TO <aenam>.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_cur> TO <erdat>.
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_cur> TO <ertim>.
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_cur> TO <ernam>.
      " Update dữ liệu thật từ DB theo key
      DATA lv_dummy TYPE string.
      lv_where = VALUE string( ).
      PERFORM make_where_from_key USING <ls_cur> gt_key_fields
                                  CHANGING lv_where lv_dummy.
DATA(lv_match) = abap_false.

LOOP AT <lt_db> ASSIGNING <ls_db>.
  DATA(lv_cond_ok) = abap_true.

  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kname>).
    FIELD-SYMBOLS: <v1> TYPE any, <v2> TYPE any.
    ASSIGN COMPONENT <kname> OF STRUCTURE <ls_cur> TO <v1>.
    ASSIGN COMPONENT <kname> OF STRUCTURE <ls_db> TO <v2>.
    IF <v1> <> <v2>.
      lv_cond_ok = abap_false.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_cond_ok = abap_true.
    MOVE-CORRESPONDING <ls_db> TO <ls_cur>.
    lv_match = abap_true.
    EXIT.
  ENDIF.
ENDLOOP.

ENDLOOP.
    ENDIF.
    "=== Refresh ALV giữ nguyên 6 field audit ===
    IF g_alv_grid IS BOUND.
      g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    ENDIF.

    DATA(lv_ins)      = REDUCE i( INIT cnt = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT cnt = cnt + 1 ).
    DATA(lv_upd)      = REDUCE i( INIT cnt = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT cnt = cnt + 1 ).
    DATA(lv_cnt_save) = lines( <lt_to_save> ).

    MESSAGE |Đã lưu { lv_cnt_save } dòng (INSERT={ lv_ins }, UPDATE={ lv_upd }) – có audit. { lv_skipped } dòng bị bỏ qua.| TYPE 'S'.
    gv_dirty = abap_false.

ENDFORM.


FORM delete_selected USING iv_tab TYPE tabname
                     CHANGING ev_msg TYPE c
                              ev_err TYPE c.

  CLEAR: ev_msg, ev_err.

  " Giữ lại trạng thái Edit/Add trước khi xóa để khôi phục cuối form (cú pháp cổ điển)
  DATA lv_keep_edit TYPE abap_bool.
  IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
    lv_keep_edit = abap_true.
  ELSE.
    lv_keep_edit = abap_false.
  ENDIF.

  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS INITIAL.
    ev_err = 'Không có dữ liệu để xóa.'.
    RETURN.
  ENDIF.

  " Lấy danh sách chọn
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_sel_idx TYPE lvc_s_row.
  REFRESH lt_sel_idx.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " Nếu chưa chọn thì lấy dòng hiện tại
  IF lt_sel_idx IS INITIAL.
    DATA ls_rowid TYPE lvc_s_row.
    DATA ls_colid TYPE lvc_s_col.
    IF g_alv_grid IS BOUND.
      TRY.
          g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
        CATCH cx_root.
      ENDTRY.
    ENDIF.
    IF ls_rowid-index IS INITIAL.
      ev_err = 'Vui lòng chọn hoặc đặt con trỏ vào dòng cần xóa.'.
      RETURN.
    ENDIF.
    CLEAR ls_sel_idx.
    ls_sel_idx-index = ls_rowid-index.
    APPEND ls_sel_idx TO lt_sel_idx.
  ENDIF.

  " Đảo ngược index để delete không lệch
  DATA: lt_idx TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_i   TYPE i.
  REFRESH lt_idx.
  LOOP AT lt_sel_idx INTO ls_sel_idx.
    lv_i = ls_sel_idx-index.
    APPEND lv_i TO lt_idx.
  ENDLOOP.
  SORT lt_idx DESCENDING.

  " Đảm bảo danh sách khóa
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC — không thể xóa.'.
    RETURN.
  ENDIF.

  " Chuẩn bị audit buffer
  REFRESH gt_audit.

  " Biến làm việc
  DATA: lv_where          TYPE string,
        lv_we             TYPE string,
        lv_exists         TYPE abap_bool,
        lv_deleted        TYPE i,
        lv_newrec_deleted TYPE i.
  CLEAR: lv_deleted, lv_newrec_deleted.

  LOOP AT lt_idx INTO lv_i.
    READ TABLE <lt> ASSIGNING <ls> INDEX lv_i.
    IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    " 1) Dòng NEWREC -> chỉ xóa khỏi ALV
    FIELD-SYMBOLS <newrec> TYPE any.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> IS ASSIGNED AND <newrec> = 'X'.
      DELETE <lt> INDEX lv_i.
      lv_newrec_deleted = lv_newrec_deleted + 1.
      CONTINUE.
    ENDIF.

    " 2) Dòng DB cũ -> kiểm tra đủ khóa
    DATA any_empty TYPE abap_bool.
    any_empty = abap_false.

    FIELD-SYMBOLS: <comp>  TYPE any,
                   <fname> TYPE dd03l-fieldname.
    LOOP AT gt_key_fields ASSIGNING <fname>.
      ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
      IF sy-subrc = 0 AND <comp> IS INITIAL.
        any_empty = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF any_empty = abap_true.
      " Khóa không đủ → chỉ xóa khỏi lưới cho sạch
      DELETE <lt> INDEX lv_i.
      ev_msg = 'Dòng có khóa không đầy đủ đã được xóa khỏi lưới.'.
      CONTINUE.
    ENDIF.

    " Build điều kiện WHERE từ khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      ev_err = 'Không xây được điều kiện khóa để xóa.'.
      EXIT.
    ENDIF.

    " Có còn tồn tại trong DB không?
    CLEAR lv_exists.
    TRY.
        SELECT SINGLE @abap_true FROM (iv_tab) WHERE (lv_where) INTO @lv_exists.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del1).
          ev_err = lx_del1->get_text( ).
          EXIT.
      ENDTRY.

      IF sy-subrc <> 0.
        " Không còn trong DB -> xóa khỏi ALV cho sạch
        DELETE <lt> INDEX lv_i.
        CONTINUE.
      ENDIF.

      " Lưu bản cũ để audit
      DATA lr_old TYPE REF TO data.
      CREATE DATA lr_old LIKE <ls>.
      FIELD-SYMBOLS <ls_old> TYPE any.
      ASSIGN lr_old->* TO <ls_old>.
      CLEAR <ls_old>.

      TRY.
          SELECT SINGLE * FROM (iv_tab) WHERE (lv_where)
            INTO CORRESPONDING FIELDS OF @<ls_old>.
          CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del2).
            ev_err = lx_del2->get_text( ).
            EXIT.
        ENDTRY.
        IF ev_err IS NOT INITIAL.
          EXIT.
        ENDIF.
        IF sy-subrc <> 0.
          <ls_old> = <ls>.
        ENDIF.

        " Xóa DB
        TRY.
            DELETE FROM (iv_tab) WHERE (lv_where).
          CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del3).
            ev_err = lx_del3->get_text( ).
            EXIT.
        ENDTRY.
        IF sy-subrc <> 0.
          ev_err = 'Xóa DB thất bại cho 1 dòng; dừng lại.'.
          EXIT.
        ENDIF.

        " Xóa khỏi ALV & ghi audit
        DELETE <lt> INDEX lv_i.

        DATA ls_a TYPE ty_audit.
        CLEAR ls_a.
        ls_a-tabname = iv_tab.
        ls_a-action  = 'DELETE'.
        ls_a-uname   = sy-uname.
        ls_a-udate   = sy-datum.
        ls_a-utime   = sy-uzeit.
        PERFORM to_json USING <ls_old> CHANGING ls_a-before_json.
        CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a-logid.
        APPEND ls_a TO gt_audit.

        lv_deleted = lv_deleted + 1.
      ENDLOOP.

      " === Sau xóa: quét lại xem còn dòng NEWREC='X' nào không ===
      DATA(lv_still_has_newrec) = abap_false.
      LOOP AT <lt> ASSIGNING <ls>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          lv_still_has_newrec = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF ev_err IS NOT INITIAL.
        ROLLBACK WORK.
        RETURN.
      ENDIF.

      " Ghi audit vào bảng log
      IF gt_audit IS NOT INITIAL.
        TYPES: BEGIN OF ty_audit_db,
                 mandt       TYPE mandt,
                 logid       TYPE char32,
                 uname       TYPE syuname,
                 udate       TYPE sydatum,
                 utime       TYPE syuzeit,
                 tabname     TYPE tabname,
                 action      TYPE char10,
                 before_json TYPE zde_json_txt,
                 after_json  TYPE zde_json_txt,
               END OF ty_audit_db.
        DATA wa_log      TYPE ty_audit_db.
        DATA lv_audit_tab TYPE tabname.
        lv_audit_tab = 'ZAUDIT_LOG'.

        FIELD-SYMBOLS <a> TYPE ty_audit.
        LOOP AT gt_audit ASSIGNING <a>.
          CLEAR wa_log.
          wa_log-mandt       = sy-mandt.
          wa_log-logid       = <a>-logid.
          wa_log-uname       = <a>-uname.
          wa_log-udate       = <a>-udate.
          wa_log-utime       = <a>-utime.
          wa_log-tabname     = <a>-tabname.
          wa_log-action      = <a>-action.
          wa_log-before_json = <a>-before_json.
          INSERT (lv_audit_tab) FROM wa_log.
        ENDLOOP.
      ENDIF.

      " Chỉ COMMIT khi có xóa DB hoặc có ghi audit
      IF lv_deleted > 0 OR gt_audit IS NOT INITIAL.
        COMMIT WORK AND WAIT.
      ENDIF.

      " Nếu chỉ xóa NEWREC nhưng trước đó có sửa dòng cũ → reload để về trạng thái sạch
      DATA lv_had_dirty TYPE abap_bool.
      lv_had_dirty = gv_dirty.
      IF lv_deleted = 0 AND lv_newrec_deleted > 0 AND lv_had_dirty = abap_true.
        DATA lv_rows2 TYPE i.
        DATA lv_err2  TYPE string.
        PERFORM load_data USING iv_tab 0 CHANGING gr_data lv_rows2 lv_err2.
        IF lv_err2 IS INITIAL.
          gv_dirty = abap_false.
        ELSE.
          ev_err = |Reload dữ liệu sau khi xóa NEWREC thất bại: | && lv_err2.
        ENDIF.
      ENDIF.

      " Message tổng kết
      ev_msg = |Đã xóa | && lv_deleted && | dòng DB và | &&
               lv_newrec_deleted && | dòng NEWREC.|.

      " Khôi phục mode
      gv_dirty    = abap_false.
      gv_add_mode = COND #( WHEN lv_still_has_newrec = abap_true THEN abap_true ELSE abap_false ).
      IF lv_keep_edit = abap_true.
        gv_edit_md      = abap_true.
        gv_toolbar_mode = 'E'.
      ELSE.
        gv_edit_md      = abap_false.
        gv_toolbar_mode = 'D'.
      ENDIF.

      PERFORM apply_editability_and_push.

      " Nếu còn NEWREC thì focus vào key của dòng NEWREC cuối cùng
      IF lv_still_has_newrec = abap_true.
        PERFORM focus_key_on_newrec.
      ENDIF.

      IF g_alv_grid IS BOUND.
        IF gv_edit_md = abap_true.
          g_alv_grid->set_ready_for_input( 1 ).
        ELSE.
          g_alv_grid->set_ready_for_input( 0 ).
        ENDIF.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.

ENDFORM.


*-------------------------------------------------------------*
* Popup hiển thị log rollback
*-------------------------------------------------------------*
FORM show_audit_log_popup USING iv_tab TYPE tabname.
  DATA: lt_log      TYPE STANDARD TABLE OF zaudit_log,
        ls_log      TYPE zaudit_log,
        ls_selfield TYPE slis_selfield.

  SELECT *
  FROM zaudit_log
  INTO TABLE @lt_log
  WHERE tabname = @iv_tab
  ORDER BY udate DESCENDING, utime DESCENDING.

    IF lt_log IS INITIAL.
      MESSAGE 'Không có log nào để rollback' TYPE 'I'.
      RETURN.
    ENDIF.

    CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
      EXPORTING
        i_title               = |Chọn log rollback cho bảng { iv_tab }|
        i_zebra               = 'X'
        i_screen_start_column = 10
        i_screen_start_line   = 5
        i_screen_end_column   = 100
        i_screen_end_line     = 20
      IMPORTING
        es_selfield           = ls_selfield
      TABLES
        t_outtab              = lt_log
      EXCEPTIONS
        OTHERS                = 1.

    IF sy-subrc = 0 AND ls_selfield-tabindex > 0.
      READ TABLE lt_log INDEX ls_selfield-tabindex INTO ls_log.
      IF sy-subrc = 0.
        PERFORM rollback_from_log USING ls_log.
      ENDIF.
    ENDIF.
ENDFORM.

*-------------------------------------------------------------*
* Rollback từ 1 log
*-------------------------------------------------------------*
FORM rollback_from_log USING is_log TYPE zaudit_log.
  DATA: lr_before    TYPE REF TO data,
        lr_curr_data TYPE REF TO data,
        lv_err       TYPE string,
        lv_mod       TYPE i,
        lv_json      TYPE zde_json_txt,
        lv_curr_json TYPE zde_json_txt.

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <ls_curr> TYPE any.

  IF is_log-tabname IS INITIAL.
    MESSAGE 'Tên bảng không được để trống' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_json = is_log-before_json.
  IF lv_json IS INITIAL AND is_log-action <> 'INSERT'.
    MESSAGE 'JSON trước đó rỗng, không thể rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM json_to_itab USING is_log-tabname lv_json CHANGING lr_before.
  ASSIGN lr_before->* TO <lt>.
  IF <lt> IS NOT ASSIGNED.
    MESSAGE 'Không parse được JSON để rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_dyn_itab USING is_log-tabname CHANGING lr_curr_data.
  IF lr_curr_data IS NOT BOUND.
    MESSAGE 'Không tạo được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  ASSIGN lr_curr_data->* TO <lt_curr>.
  IF <lt_curr> IS NOT ASSIGNED.
    MESSAGE 'Không assign được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING is_log-tabname.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_curr>.
  DATA: lo_tabledesc TYPE REF TO cl_abap_tabledescr,
        lo_linedesc  TYPE REF TO cl_abap_structdescr.
  lo_tabledesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_before ).
  lo_linedesc  ?= lo_tabledesc->get_table_line_type( ).

  LOOP AT <lt> ASSIGNING <ls>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      MESSAGE |Không xây được điều kiện khóa: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    DATA lr_line TYPE REF TO data.
    CREATE DATA lr_line TYPE HANDLE lo_linedesc.
    ASSIGN lr_line->* TO <ls_curr>.
    IF <ls_curr> IS NOT ASSIGNED.
      MESSAGE 'Không tạo được cấu trúc dòng cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    TRY.
        SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_rb1).
          MESSAGE lx_rb1->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.
      IF sy-subrc = 0.
        APPEND <ls_curr> TO <lt_curr>.
      ENDIF.
    ENDLOOP.

    IF <lt_curr> IS NOT INITIAL.
      /ui2/cl_json=>serialize(
        EXPORTING data        = <lt_curr>
                  pretty_name = /ui2/cl_json=>pretty_mode-none
        RECEIVING r_json      = lv_curr_json ).
    ELSE.
      lv_curr_json = '[]'.
    ENDIF.

    PERFORM save_data USING is_log-tabname
                      CHANGING lr_before lv_mod lv_err.

    IF lv_err IS INITIAL.
      DATA: lv_newlogid TYPE char32,
            ls_new      TYPE zaudit_log.
      CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = lv_newlogid.

      CLEAR ls_new.
      ls_new-mandt       = sy-mandt.
      ls_new-logid       = lv_newlogid.
      ls_new-uname       = sy-uname.
      ls_new-udate       = sy-datum.
      ls_new-utime       = sy-uzeit.
      ls_new-tabname     = is_log-tabname.
      ls_new-action      = 'ROLLBACK'.
      ls_new-before_json = lv_curr_json.
      ls_new-after_json  = lv_json.

      INSERT zaudit_log FROM ls_new.
      COMMIT WORK AND WAIT.
      gv_dirty = abap_false.
      DATA lv_subj TYPE so_obj_des.
      DATA lv_mail_rc TYPE i.
      lv_subj = |[RB OK] { is_log-tabname } LOG { lv_newlogid(8) }|.
      PERFORM send_mail_min USING lv_subj 'thanhchse171611@fpt.edu.vn'.
      lv_mail_rc = sy-subrc.
    ELSE.
      ROLLBACK WORK.
      MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail tối giản (raw)
*---------------------------------------------------------------------*
FORM send_mail_min USING iv_subject TYPE so_obj_des
iv_to TYPE ad_smtpadr.
  DATA: lo_req      TYPE REF TO cl_bcs,
        lo_doc      TYPE REF TO cl_document_bcs,
        lo_rcpt     TYPE REF TO if_recipient_bcs,
        lt_text     TYPE bcsy_text,
        ls_line     LIKE LINE OF lt_text,
        lv_to_local TYPE ad_smtpadr.

  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

  CLEAR lt_text.
  ls_line-line = |Rollback thành công từ { sy-repid } (user { sy-uname }).|.
  APPEND ls_line TO lt_text.

  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'RAW'
                 i_text    = lt_text
                 i_subject = iv_subject ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " (A) TẮT thông báo trạng thái gửi (không nhận status mail/express)
      lo_req->set_status_attributes(
        i_requested_status = 'N'  " no MDN/status request
        i_status_mail      = 'N'    " no status mail back to sender
      ).

      " (B) GỬI CHO BẠN VÀO SBWP NHƯNG KHÔNG EXPRESS (=> KHÔNG POPUP)
      lo_req->add_recipient(
        i_recipient = cl_sapuser_bcs=>create( sy-uname )
        i_express   = abap_false ).

      " (C) GỬI RA EMAIL INTERNET – cũng KHÔNG express
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient = lo_rcpt
        i_express   = abap_false
        i_copy      = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Restore data từ JSON (dùng cho rollback)
*---------------------------------------------------------------------*
FORM restore_data USING iv_tabname TYPE tabname
                        iv_json    TYPE zde_json_txt
                  CHANGING ev_err  TYPE string
                           ev_mod  TYPE i.

  DATA: lr_data  TYPE REF TO data,
        lv_where TYPE string,
        lv_msg   TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any.

  CLEAR: ev_err, ev_mod.

  PERFORM json_to_itab USING iv_tabname iv_json CHANGING lr_data.
  ASSIGN lr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    ev_err = |Không parse được JSON để restore cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING iv_tabname.
  IF gt_key_fields IS INITIAL.
    ev_err = |Không tìm thấy key fields cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields
      CHANGING lv_where lv_msg.
    IF lv_where IS INITIAL.
      ev_err = |Không tạo được WHERE: { lv_msg }|.
      RETURN.
    ENDIF.

    TRY.
        DELETE FROM (iv_tabname) WHERE (lv_where).
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_r1).
        ev_err = lx_r1->get_text( ).
        RETURN.
    ENDTRY.

    INSERT (iv_tabname) FROM <ls_data>.
    IF sy-subrc = 0.
      ev_mod = ev_mod + 1.
    ELSE.
      ev_err = |Không insert được dòng trong { iv_tabname } với WHERE { lv_where }|.
      RETURN.
    ENDIF.
  ENDLOOP.
ENDFORM.

*-------------------------------------------------------------*
* JSON -> itab động (rollback) – đồng bộ pretty_mode = none
*-------------------------------------------------------------*
FORM json_to_itab USING iv_tab  TYPE tabname
                        iv_json TYPE zde_json_txt
                  CHANGING cr_data TYPE REF TO data.
  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_any    TYPE REF TO data,
        lr_row    TYPE REF TO data.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  TRY.
      lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
      lo_table  = cl_abap_tabledescr=>create( lo_struct ).
      CREATE DATA lr_any TYPE HANDLE lo_table.
      ASSIGN lr_any->* TO <lt_data>.

      /ui2/cl_json=>deserialize(
  EXPORTING json        = iv_json
            pretty_name = /ui2/cl_json=>pretty_mode-none
  CHANGING  data        = <lt_data> ).

      IF <lt_data> IS INITIAL.
        CREATE DATA lr_row TYPE HANDLE lo_struct.
        ASSIGN lr_row->* TO <ls_row>.
        /ui2/cl_json=>deserialize(
          EXPORTING json        = iv_json
                    pretty_name = /ui2/cl_json=>pretty_mode-none
          CHANGING  data        = <ls_row> ).
        APPEND <ls_row> TO <lt_data>.
      ENDIF.

      cr_data = lr_any.
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail sau khi rollback – (wrapper, có fallback) — FINAL (SO_OBJ_DES)
*---------------------------------------------------------------------*
FORM notify_rollback_smtp
  USING is_log       TYPE zaudit_log
        iv_mod       TYPE i
        iv_curr_json TYPE zde_json_txt
        iv_prev_json TYPE zde_json_txt
        iv_note      TYPE string.

  DATA: lv_to TYPE ad_smtpadr VALUE 'thanhchse171611@fpt.edu.vn'.

  " Gửi mail chi tiết + note batch trong 1 email
  PERFORM send_mail_rb_detail USING is_log-tabname
                                    is_log-logid
                                    iv_mod
                                    lv_to
                                    iv_curr_json
                                    iv_prev_json
                                    iv_note.

  IF sy-subrc <> 0.
    " Fallback: SUBJECT phải là SO_OBJ_DES (không phải string)
    DATA lv_subj_fallback TYPE so_obj_des.
    lv_subj_fallback = CONV so_obj_des(
                          |[ROLLBACK OK] { is_log-tabname } - LOG { is_log-logid(8) } - { iv_mod } row(s)| ).

    " SEND_MAIL_MIN đang khai báo IV_SUBJECT TYPE SO_OBJ_DES, IV_TO TYPE AD_SMTPADR
    PERFORM send_mail_min USING lv_subj_fallback lv_to.
  ENDIF.
ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail rollback chi tiết (html) – giữ nguyên luồng chính + note batch
*---------------------------------------------------------------------*
FORM send_mail_rb_detail
  USING iv_tab        TYPE tabname
        iv_logid      TYPE zaudit_log-logid
        iv_rows       TYPE i
        iv_to         TYPE ad_smtpadr
        iv_json_curr  TYPE zde_json_txt
        iv_json_after TYPE zde_json_txt
        iv_note       TYPE string.

  DATA: lo_req        TYPE REF TO cl_bcs,
        lo_doc        TYPE REF TO cl_document_bcs,
        lo_rcpt       TYPE REF TO if_recipient_bcs,
        lo_rcptso     TYPE REF TO if_recipient_bcs,
        lt_body       TYPE bcsy_text,
        lv_subj       TYPE so_obj_des,
        lv_html       TYPE string,
        lv_curr_html  TYPE string,
        lv_after_html TYPE string,
        lv_to_local   TYPE ad_smtpadr.

  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

  " Escape + cắt JSON (tránh vỡ HTML)
  PERFORM _html_escape     USING iv_json_curr  CHANGING lv_curr_html.
  PERFORM _html_escape     USING iv_json_after CHANGING lv_after_html.
  PERFORM _ellipsize_html  USING lv_curr_html  8000 CHANGING lv_curr_html.
  PERFORM _ellipsize_html  USING lv_after_html 8000 CHANGING lv_after_html.

  lv_subj = |[ROLLBACK OK] { iv_tab } - LOG { iv_logid(8) } - { iv_rows } row(s)|.

  " Header + meta
  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">Rollback thành công | &&
    |<span style="display:inline-block;padding:2px 8px;border-radius:999px;background:#e2f3e8;color:#065f46;font-size:12px">{ iv_rows } row(s)</span>| &&
    |</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Bảng</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tab }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Log ID</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_logid }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Người thực hiện</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Chương trình</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-repid }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Thời gian</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
    |</table></div>|.

  " ====== CHÈN NOTE (danh sách batch) nếu có ======
  IF iv_note IS NOT INITIAL.
    DATA(lv_note_html) = iv_note.
    PERFORM _html_escape     USING lv_note_html CHANGING lv_note_html.
    PERFORM _ellipsize_html  USING lv_note_html 4000 CHANGING lv_note_html.

    lv_html = lv_html &&
      |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
      |<h4 style="margin:0 0 8px 0;font-size:14px">Batch details</h4>| &&
      |<pre style="white-space:pre-wrap;font-family:Consolas,Menlo,monospace;font-size:12px;margin:0">| &&
      lv_note_html &&
      |</pre></div>|.
  ENDIF.

  " ====== PHẦN DIFF (nếu bạn muốn hiển thị biến động JSON) ======
  DATA lv_diff_html TYPE string.
  PERFORM build_html_diff USING    iv_tab
                                   iv_json_curr
                                   iv_json_after
                          CHANGING lv_diff_html.
  lv_html = lv_html && lv_diff_html && |</body></html>|.

  " Convert HTML string -> bcsy_text
  PERFORM _string_to_bcs_text USING lv_html CHANGING lt_body.

  " Gửi qua BCS
  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'HTM'
                 i_text    = lt_body
                 i_subject = lv_subj ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " (A) TẮT status notification
      lo_req->set_status_attributes(
        i_requested_status = 'N'
        i_status_mail      = 'N' ).

      " (B) SBWP của bạn – KHÔNG express
      lo_rcptso = cl_sapuser_bcs=>create( sy-uname ).
      lo_req->add_recipient(
        i_recipient = lo_rcptso
        i_express   = abap_false ).

      " (C) Email internet – KHÔNG express
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient = lo_rcpt
        i_express   = abap_false
        i_copy      = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.


*---------------------------------------------------------------------*
* Helper: string -> bcsy_text (manual SPLIT 255 ký tự/line)
*---------------------------------------------------------------------*
FORM _string_to_bcs_text USING iv_str TYPE string
CHANGING ct_text TYPE bcsy_text.
  DATA: lv_off  TYPE i VALUE 0,
        lv_len  TYPE i,
        lv_take TYPE i,
        ls      TYPE soli.
  CLEAR ct_text.
  lv_len = strlen( iv_str ).
  WHILE lv_off < lv_len.
    lv_take = lv_len - lv_off.
    IF lv_take > 255.
      lv_take = 255.
    ENDIF.
    CLEAR ls.
    ls-line = iv_str+lv_off(lv_take).
    APPEND ls TO ct_text.
    lv_off = lv_off + lv_take.
  ENDWHILE.
  IF ct_text IS INITIAL.
    CLEAR ls.
    APPEND ls TO ct_text.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: escape tối thiểu để nhúng json vào html safely
*---------------------------------------------------------------------*
FORM _html_escape USING iv_in TYPE string
CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '&' IN cv_out WITH '&amp;'.
  REPLACE ALL OCCURRENCES OF '<' IN cv_out WITH '&lt;'.
  REPLACE ALL OCCURRENCES OF '>' IN cv_out WITH '&gt;'.
  REPLACE ALL OCCURRENCES OF '"' IN cv_out WITH '&quot;'.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH '&#39;'.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: rút gọn string nếu vượt max_len (thêm "... (truncated)")
*---------------------------------------------------------------------*
FORM _ellipsize_html USING iv_in TYPE string
iv_max_len TYPE i
CHANGING cv_out TYPE string.
  DATA: lv_len  TYPE i, lv_max TYPE i, lv_take TYPE i.
  lv_max = iv_max_len.
  IF lv_max IS INITIAL OR lv_max < 1000.
    lv_max = 1000.
  ENDIF.
  lv_len = strlen( iv_in ).
  IF lv_len > lv_max.
    lv_take = lv_max - 15.
    IF lv_take < 0.
      lv_take = 0.
    ENDIF.
    cv_out = iv_in+0(lv_take).
    cv_out = cv_out && |... (truncated)|.
  ELSE.
    cv_out = iv_in.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
*  Build HTML diff (COMPACT TABLE): 1 record -> 1 bảng ngang
*   Header:  Mô tả | <Field 1> | <Field 2> | ...
*   Body:    Before | ...values...   (ô khác biệt tô đỏ nhạt)
*            After  | ...values...   (ô khác biệt tô xanh nhạt)
*---------------------------------------------------------------------*
FORM build_html_diff USING    iv_tab        TYPE tabname
                              iv_json_curr  TYPE zde_json_txt
                              iv_json_after TYPE zde_json_txt
                     CHANGING cv_html       TYPE string.

  DATA: lr_data_curr  TYPE REF TO data,
        lr_data_after TYPE REF TO data,
        lt_fieldinfo  TYPE TABLE OF dfies,
        ls_field      TYPE dfies,
        lv_tab_up     TYPE tabname.

  FIELD-SYMBOLS: <lt_curr>  TYPE STANDARD TABLE,
                 <lt_after> TYPE STANDARD TABLE,
                 <ls_curr>  TYPE any,
                 <ls_after> TYPE any,
                 <old>      TYPE any,
                 <new>      TYPE any.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Biến key (PHẢI là string để dùng CHANGING)
  DATA: lv_kc  TYPE string,
        lv_ka  TYPE string,
        lv_key TYPE string.

  " Tổng số field changed (cho legend cuối mail)
  DATA lv_changed_total TYPE i VALUE 0.

  " -- upper-case bảng
  lv_tab_up = iv_tab.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " 0) DDIC describe & field info
  lo_struct ?= cl_abap_typedescr=>describe_by_name( lv_tab_up ).
  IF lo_struct IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>Cannot describe DDIC structure.</i></div>'.
    RETURN.
  ENDIF.
  lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = lv_tab_up
      all_types = 'X'
    TABLES
      dfies_tab = lt_fieldinfo
    EXCEPTIONS
      OTHERS    = 1.
  IF lt_fieldinfo IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No DDIC field info for table.</i></div>'.
    RETURN.
  ENDIF.

  " 1) JSON -> itab động (có thể rỗng)
  PERFORM json_to_itab USING lv_tab_up iv_json_curr  CHANGING lr_data_curr.
  PERFORM json_to_itab USING lv_tab_up iv_json_after CHANGING lr_data_after.
  IF lr_data_curr IS BOUND.  ASSIGN lr_data_curr->*  TO <lt_curr>.  ENDIF.
  IF lr_data_after IS BOUND. ASSIGN lr_data_after->* TO <lt_after>. ENDIF.

  IF ( <lt_curr>  IS NOT ASSIGNED OR <lt_curr>  IS INITIAL )
 AND ( <lt_after> IS NOT ASSIGNED OR <lt_after> IS INITIAL ).
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No parsable data for diff (both before/after empty).</i></div>'.
    RETURN.
  ENDIF.

  " 2) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING lv_tab_up IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key fields in DDIC.</i></div>'.
    RETURN.
  ENDIF.

  " 3) Hợp nhất các KEY từ cả Before/After
  DATA: lt_all_keys TYPE SORTED TABLE OF string WITH UNIQUE KEY table_line.
  IF <lt_curr> IS ASSIGNED.
    LOOP AT <lt_curr> ASSIGNING <ls_curr>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF <lt_after> IS ASSIGNED.
    LOOP AT <lt_after> ASSIGNING <ls_after>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_after> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF lt_all_keys IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key found to pair rows.</i></div>'.
    RETURN.
  ENDIF.

  " 4) Render: mỗi KEY = 1 bảng ngang (1 header + 2 dòng Before/After)
  CLEAR cv_html.
  DATA: lv_block  TYPE string,
        lv_tbl    TYPE string,
        lv_head   TYPE string,
        lv_row_b  TYPE string,
        lv_row_a  TYPE string,
        lv_title  TYPE string,
        lv_desc   TYPE string,
        lv_desc_h TYPE string,
        lv_old    TYPE string,
        lv_new    TYPE string,
        lv_old_h  TYPE string,
        lv_new_h  TYPE string,
        lv_cnt    TYPE i VALUE 0.

  LOOP AT lt_all_keys INTO lv_key.
    ADD 1 TO lv_cnt.

    " — Tìm bản ghi theo KEY ở Before / After
    UNASSIGN: <ls_curr>, <ls_after>.
    IF <lt_curr> IS ASSIGNED.
      LOOP AT <lt_curr> ASSIGNING <ls_curr>.
        CLEAR lv_kc.
        PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_kc.
        IF lv_kc = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.
    IF <lt_after> IS ASSIGNED.
      LOOP AT <lt_after> ASSIGNING <ls_after>.
        CLEAR lv_ka.
        PERFORM _make_key_str_any USING <ls_after> CHANGING lv_ka.
        IF lv_ka = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.

    " Nếu thiếu 1 phía -> tạo struct rỗng để vẫn render
    IF <ls_curr>  IS NOT ASSIGNED.
      DATA lr_zero_c TYPE REF TO data.
      CREATE DATA lr_zero_c TYPE HANDLE lo_struct.
      ASSIGN lr_zero_c->* TO <ls_curr>.
      CLEAR <ls_curr>.
    ENDIF.
    IF <ls_after> IS NOT ASSIGNED.
      DATA lr_zero_a TYPE REF TO data.
      CREATE DATA lr_zero_a TYPE HANDLE lo_struct.
      ASSIGN lr_zero_a->* TO <ls_after>.
      CLEAR <ls_after>.
    ENDIF.

    " — Title record
    lv_title = |Record { lv_cnt } — KEY [{ lv_key }]|.
    lv_block =
      '<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">'
   && |<div style="font-weight:600;font-size:14px;margin-bottom:10px">{ lv_title }</div>|
   && '<div style="overflow-x:auto">'
   && '<table style="border-collapse:collapse;min-width:720px;font-family:Arial,sans-serif;font-size:12px">'.

    " — Header (nền tối, chữ trắng)
    lv_head =
  '<tr>'
&& '<th style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left">Mô tả</th>'.

    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      " chọn nhãn dễ đọc
      lv_desc = ls_field-scrtext_l.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_m. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_s. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldtext.  ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldname.  ENDIF.
      PERFORM _html_escape USING lv_desc CHANGING lv_desc_h.

      lv_head &&=
        |<th style="background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left;white-space:nowrap">{ lv_desc_h }</th>|.
    ENDLOOP.
    lv_head &&= '</tr>'.

    " — Row BEFORE
    lv_row_b =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">Before</td>'.

    " — Row AFTER
    lv_row_a =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">After</td>'.

    " — Fill cells & đánh dấu thay đổi theo ô
    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      CLEAR: lv_old, lv_new, lv_old_h, lv_new_h.

      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_curr>  TO <old>.
      IF <old> IS ASSIGNED. lv_old = <old>. ENDIF.
      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_after> TO <new>.
      IF <new> IS ASSIGNED. lv_new = <new>. ENDIF.

      PERFORM _html_escape USING lv_old CHANGING lv_old_h.
      PERFORM _html_escape USING lv_new CHANGING lv_new_h.

      DATA(lv_changed) = xsdbool( lv_old_h <> lv_new_h ).
      IF lv_changed = abap_true.
        lv_changed_total = lv_changed_total + 1.
      ENDIF.

      " Before-cell (đỏ nhạt nếu đổi)
      lv_row_b &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#FEE2E2;color:#991B1B;' ELSE '' )
       && |">{ lv_old_h }</td>|.

      " After-cell (xanh nhạt nếu đổi)
      lv_row_a &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#D1FAE5;color:#065F46;' ELSE '' )
       && |">{ lv_new_h }</td>|.
    ENDLOOP.

    lv_row_b &&= '</tr>'.
    lv_row_a &&= '</tr>'.

    lv_tbl = lv_head && lv_row_b && lv_row_a && '</table></div>'. " đóng table + overflow

    " — Gộp block
    lv_block &&= lv_tbl && '</div>'.
    cv_html  &&= lv_block.
  ENDLOOP.

  " Legend
  cv_html &&=
    |<div style="margin-top:8px;font-size:12px;color:#374151">|
 && |<b>{ lv_changed_total }</b> field(s) changed across records. |
 && |<span style="display:inline-block;margin-left:8px;padding:2px 6px;background:#FEE2E2;color:#991B1B;border-radius:999px">Before changed</span>|
 && |<span style="display:inline-block;margin-left:6px;padding:2px 6px;background:#D1FAE5;color:#065F46;border-radius:999px">After changed</span>|
 && |</div>|.

ENDFORM.


*---------------------------------------------------------------------*
* Tạo KEY string ổn định từ 1 dòng dựa trên gt_key_fields
*---------------------------------------------------------------------*
FORM _make_key_str_any
  USING    is_row TYPE any
  CHANGING cv_key TYPE string.

  DATA: lv_name TYPE dd03l-fieldname,
        lv_tmp  TYPE string,
        lv_part TYPE string.
  FIELD-SYMBOLS: <v> TYPE any.

  CLEAR cv_key.
  LOOP AT gt_key_fields INTO lv_name.
    ASSIGN COMPONENT lv_name OF STRUCTURE is_row TO <v>.
    CLEAR lv_part.
    IF sy-subrc = 0 AND <v> IS ASSIGNED.
      lv_tmp = <v>.
      TRANSLATE lv_tmp TO UPPER CASE.
      CONDENSE  lv_tmp NO-GAPS.
      lv_part = lv_tmp.
    ENDIF.
    IF cv_key IS INITIAL.
      cv_key = lv_part.
    ELSE.
      CONCATENATE cv_key lv_part INTO cv_key SEPARATED BY '|'.
    ENDIF.
  ENDLOOP.

ENDFORM.


*---------------------------------------------------------------------*
*  Get Data Element short text (DD04T-DDTEXT)
*---------------------------------------------------------------------*
FORM get_dtel_text USING    iv_rollname TYPE rollname
                   CHANGING cv_text     TYPE string.

  DATA ls_dd04v TYPE dd04v.

  CALL FUNCTION 'DDIF_DTEL_GET'
    EXPORTING
      name     = iv_rollname
    IMPORTING
      dd04v_wa = ls_dd04v
    EXCEPTIONS
      OTHERS   = 1.

  IF sy-subrc = 0 AND cv_text IS INITIAL AND ls_dd04v-ddtext IS NOT INITIAL.
    cv_text = ls_dd04v-ddtext.
  ENDIF.

ENDFORM.





*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
FORM check_unsaved_changes CHANGING ev_has_change TYPE abap_bool.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.

  ev_has_change = abap_false.

  " Nếu đang ở Add/Edit thì mới cần cảnh báo
  IF gv_add_mode = abap_true OR gv_edit_md = abap_true.

    " 1) Nếu đã có cờ bẩn => coi như chưa lưu
    IF gv_dirty = abap_true.
      ev_has_change = abap_true.
      RETURN.
    ENDIF.

    " 2) Hoặc có dòng NEWREC chưa lưu
    ASSIGN gr_data->* TO <lt_data>.
    IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
      LOOP AT <lt_data> ASSIGNING <ls_data>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          ev_has_change = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.

FORM analyze_change_state CHANGING cv_new_incomplete TYPE abap_bool
cv_other_changes  TYPE abap_bool.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_has_newrec      TYPE abap_bool VALUE abap_false,
        lv_all_keys_filled TYPE abap_bool,
        lv_key             TYPE dd03l-fieldname,
        lv_val_str         TYPE string.

  cv_new_incomplete = abap_false.
  cv_other_changes  = abap_false.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_has_newrec      = abap_true.
        lv_all_keys_filled = abap_true.

        LOOP AT gt_key_fields INTO lv_key.
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc <> 0 OR <cell> IS NOT ASSIGNED.
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.

          " Chuẩn hóa để check INITIAL cho cả char/num
          CLEAR lv_val_str.
          TRY.
              lv_val_str = <cell>.
            CATCH cx_root.
              " Nếu không gán được string (kiểu số), check INITIAL trực tiếp
          ENDTRY.

          IF lv_val_str IS NOT INITIAL.
            CONDENSE lv_val_str.
          ENDIF.

          IF ( lv_val_str IS INITIAL ) AND ( <cell> IS INITIAL ).
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_all_keys_filled = abap_false.
          cv_new_incomplete = abap_true.
          EXIT. " chỉ cần biết có 1 NEWREC thiếu khóa là đủ
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF ( gv_dirty = abap_true AND cv_new_incomplete = abap_false )
  OR ( gv_dirty_nonnewrec = abap_true ).
    cv_other_changes = abap_true.
  ENDIF.

ENDFORM.


FORM is_newrec_target_for_delete CHANGING ev_newrec_only TYPE abap_bool.
  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any, <v> TYPE any.
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col,
        lv_idx     TYPE i.

  ev_newrec_only = abap_false.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index > 0.
      APPEND VALUE lvc_s_row( index = ls_rowid-index ) TO lt_sel_idx.
    ENDIF.
  ENDIF.

  IF lines( lt_sel_idx ) <> 1.
    RETURN.
  ENDIF.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE lt_sel_idx INTO DATA(ls_sel) INDEX 1.
  IF sy-subrc <> 0. RETURN. ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX ls_sel-index.
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED. RETURN. ENDIF.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <v>.
  IF sy-subrc = 0 AND <v> = 'X'.
    " Kiểm tra xem dòng có trống hết key không
    DATA(lv_all_empty) = abap_true.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
      ASSIGN COMPONENT <k> OF STRUCTURE <ls> TO FIELD-SYMBOL(<val>).
      IF sy-subrc = 0 AND <val> IS NOT INITIAL.
        lv_all_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_all_empty = abap_true.
      ev_newrec_only = abap_true.
    ENDIF.
  ENDIF.
ENDFORM.

FORM discard_unsaved_changes.
  FIELD-SYMBOLS: <lt>  TYPE STANDARD TABLE,
                 <ls>  TYPE any,
                 <new> TYPE any.

  DATA: lt_del_idx TYPE STANDARD TABLE OF i WITH EMPTY KEY,
        lv_rows    TYPE i,
        lv_err     TYPE string.

  " 1) Quét 1 lần, gom index các dòng NEWREC
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED AND <lt> IS NOT INITIAL.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
      IF sy-subrc = 0 AND <new> = 'X'.
        APPEND sy-tabix TO lt_del_idx.
      ENDIF.
    ENDLOOP.

    " Xóa hàng loạt theo thứ tự giảm dần (để không xô lệch index)
    IF lt_del_idx IS NOT INITIAL.
      SORT lt_del_idx DESCENDING.
      LOOP AT lt_del_idx ASSIGNING FIELD-SYMBOL(<idx>).
        DELETE <lt> INDEX <idx>.
      ENDLOOP.
    ENDIF.
  ENDIF.

  " 2) Chỉ reload DB khi có chỉnh sửa dòng cũ
  IF gv_dirty = abap_true.
    PERFORM load_data USING p_tab 0 CHANGING gr_data lv_rows lv_err.
    IF lv_err IS NOT INITIAL.
      MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
  ENDIF.

  " 3) Reset trạng thái & refresh UI (1 lần)
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display(
    EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.
ENDFORM.


FORM purge_incomplete_newrecs.
  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  " Dùng bảng chỉ số để xóa theo INDEX (key mặc định)
  DATA: lt_del     TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_missing TYPE abap_bool,
        lv_key     TYPE dd03l-fieldname.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      lv_missing = abap_false.
      LOOP AT gt_key_fields INTO lv_key.
        ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
        IF sy-subrc <> 0 OR <cell> IS INITIAL.
          lv_missing = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_missing = abap_true.
        APPEND sy-tabix TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF lt_del IS NOT INITIAL.
    SORT lt_del DESCENDING.
    LOOP AT lt_del ASSIGNING FIELD-SYMBOL(<idx>).
      DELETE <lt> INDEX <idx>.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM focus_key_on_newrec.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.
  DATA: lv_idx TYPE i.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR g_alv_grid IS INITIAL.
    RETURN.
  ENDIF.

  lv_idx = 0.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_idx = sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF lv_idx = 0. RETURN. ENDIF.

  PERFORM ensure_keys USING p_tab.
  READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
  IF sy-subrc <> 0. RETURN. ENDIF.

  DATA ls_row TYPE lvc_s_row.
  DATA ls_col TYPE lvc_s_col.
  ls_row-index     = lv_idx.
  ls_col-fieldname = lv_first_key.

  TRY.
      g_alv_grid->set_current_cell_via_id(
      EXPORTING is_row_id    = ls_row
      is_column_id = ls_col ).
      g_alv_grid->set_scroll_info_via_id(
      EXPORTING is_row_info = ls_row
      is_col_info = ls_col ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

FORM analyze_change_state_detailed
  CHANGING ev_has_change          TYPE abap_bool
           ev_cnt_new_incomplete  TYPE i
           ev_cnt_new_complete    TYPE i
           ev_cnt_edited_existing TYPE i.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_is_key_missing TYPE abap_bool,
        lv_keyname        TYPE dd03l-fieldname.

  CLEAR: ev_has_change, ev_cnt_new_incomplete, ev_cnt_new_complete, ev_cnt_edited_existing.

  " Đếm NEWREC và tình trạng khóa
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_is_key_missing = abap_false.
        LOOP AT gt_key_fields INTO lv_keyname.
          ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS INITIAL.
            lv_is_key_missing = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF lv_is_key_missing = abap_true.
          ev_cnt_new_incomplete = ev_cnt_new_incomplete + 1.
        ELSE.
          ev_cnt_new_complete = ev_cnt_new_complete + 1.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " Đếm sửa dòng cũ: bạn đã set gv_dirty khi sửa non-NEWREC trong handle_data_changed
  IF gv_dirty = abap_true.
    ev_cnt_edited_existing = 1.
  ENDIF.

  IF ev_cnt_new_incomplete > 0 OR ev_cnt_new_complete > 0 OR ev_cnt_edited_existing > 0.
    ev_has_change = abap_true.
  ENDIF.

ENDFORM.

"===== ZFA25SAP23_DB =====

" Tạo itab động dựa trên tên bảng
FORM ensure_dyn_itab USING iv_tab TYPE tabname
                     CHANGING cr_tab TYPE REF TO data.

  " Nếu đã có thì thôi
  IF cr_tab IS NOT INITIAL.
    CLEAR sy-subrc.
    RETURN.
  ENDIF.

  DATA lo_any    TYPE REF TO cl_abap_typedescr.
  DATA lo_struct TYPE REF TO cl_abap_structdescr.
  DATA lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Chuẩn hóa tên bảng (đề phòng nhập thường)
  DATA(lv_tab) = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  TRY.
      lo_any = cl_abap_typedescr=>describe_by_name( lv_tab ).
    CATCH cx_root.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_struct ?= lo_any.
    CATCH cx_sy_move_cast_error.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).
      CREATE DATA cr_tab TYPE HANDLE lo_tab.
      CLEAR sy-subrc.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.


"===== Load dữ liệu từ DB vào itab =====
FORM load_data USING iv_tab TYPE tabname
iv_max TYPE i
CHANGING cr_tab TYPE REF TO data
ev_rows TYPE i
ev_err TYPE string.

  CLEAR: ev_rows, ev_err.

  " Chuẩn hóa tên bảng
  DATA(lv_tabname) = iv_tab.
  TRANSLATE lv_tabname TO UPPER CASE.

  " Validate DDIC
  TRY.
      DATA(lo_descr) = cl_abap_typedescr=>describe_by_name( lv_tabname ).
      IF lo_descr IS INITIAL.
        ev_err = |Bảng "{ lv_tabname }" không tồn tại hoặc không hợp lệ trong DDIC. Kiểm tra SE11.|.
        RETURN.
      ENDIF.
    CATCH cx_sy_create_data_error.
      ev_err = |Lỗi tạo type cho bảng "{ lv_tabname }": Bảng không active hoặc không tồn tại. Kiểm tra SE11.|.
      RETURN.
  ENDTRY.

  PERFORM ensure_dyn_itab USING lv_tabname CHANGING cr_tab.

  FIELD-SYMBOLS: <lt_load> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_load>.
  IF <lt_load> IS NOT ASSIGNED.
    ev_err = 'Không assign được itab động.'.
    RETURN.
  ENDIF.

  REFRESH <lt_load>.

  TRY.

      "--- Kiểm tra quyền truy cập theo authorization group thực tế ---
      DATA lv_authgrp TYPE tddat-cclass.
      CLEAR lv_authgrp.

      SELECT SINGLE cclass
      FROM tddat
      INTO @lv_authgrp
      WHERE tabname = @lv_tabname. " nhớ đã TRANSLATE TO UPPER CASE cho lv_tabname

      IF sy-subrc = 0 AND lv_authgrp IS NOT INITIAL.
        AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
        ID 'DICBERCLS' FIELD lv_authgrp
        ID 'ACTVT' FIELD '03'.
        IF sy-subrc <> 0.
          ev_err = |Không có quyền truy cập bảng { lv_tabname } (nhóm { lv_authgrp }). Kiểm tra SU53.|.
          RETURN.
        ENDIF.
      ENDIF.


      "=== Load dữ liệu (điểm SỬA CHÍNH: dùng CORRESPONDING FIELDS) ===
      IF iv_max > 0.
        SELECT * FROM (lv_tabname)
        INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
        UP TO @iv_max ROWS
        BYPASSING BUFFER
        ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM (lv_tabname)
        INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
        BYPASSING BUFFER
        ORDER BY PRIMARY KEY.
      ENDIF.
      ev_rows = sy-dbcnt.
"=== Bổ sung 6 field audit nếu bảng gốc không có ===
DATA: lo_tab_audit  TYPE REF TO cl_abap_tabledescr,
      lo_line_audit TYPE REF TO cl_abap_structdescr,
      lt_comp       TYPE abap_component_tab.

lo_tab_audit ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
lo_line_audit ?= lo_tab_audit->get_table_line_type( ).
lt_comp = lo_line_audit->get_components( ).

PERFORM add_field_if_missing USING 'ERDAT' 'DATS' 8 lt_comp.
PERFORM add_field_if_missing USING 'ERTIM' 'TIMS' 6 lt_comp.
PERFORM add_field_if_missing USING 'ERNAM' 'CHAR' 12 lt_comp.
PERFORM add_field_if_missing USING 'AEDAT' 'DATS' 8 lt_comp.
PERFORM add_field_if_missing USING 'AETIM' 'TIMS' 6 lt_comp.
PERFORM add_field_if_missing USING 'AENAM' 'CHAR' 12 lt_comp.


      "=== Sort theo khóa DDIC (compatible, numeric-aware) ===
      PERFORM ensure_keys USING iv_tab.
      IF gt_key_fields IS NOT INITIAL.
        DATA: lv_key TYPE dd03l-fieldname.
        lv_key = gt_key_fields[ 1 ].
        IF lv_key IS NOT INITIAL.

          FIELD-SYMBOLS: <ls_row> TYPE any, <val> TYPE any.
          DATA: lv_all_numeric TYPE c VALUE 'X'.

          " Kiểm tra tất cả giá trị key có phải là số (chỉ 0-9) sau khi CONDENSE
          LOOP AT <lt_load> ASSIGNING <ls_row>.
            ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
            IF sy-subrc <> 0 OR <val> IS INITIAL.
              CONTINUE.
            ENDIF.
            DATA lv_raw TYPE string.
            lv_raw = <val>.
            CONDENSE lv_raw NO-GAPS.
            IF NOT lv_raw CO '0123456789'.
              lv_all_numeric = space.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_all_numeric = 'X'.
            "==== Resort thật theo số (KHÔNG dùng INDEX DATA(...)) ====
            TYPES: BEGIN OF ty_idx,
                     idx TYPE i,
                     num TYPE p LENGTH 16 DECIMALS 0,
                   END OF ty_idx.
            DATA: lt_idx TYPE STANDARD TABLE OF ty_idx WITH DEFAULT KEY,
                  ls_idx TYPE ty_idx,
                  lv_idx TYPE i.

            CLEAR lt_idx.
            lv_idx = 0.
            LOOP AT <lt_load> ASSIGNING <ls_row>.
              lv_idx = lv_idx + 1.
              ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
              CLEAR ls_idx.
              ls_idx-idx = lv_idx.
              IF sy-subrc = 0 AND <val> IS ASSIGNED.
                DATA lv_raw2 TYPE string.
                lv_raw2 = <val>.
                CONDENSE lv_raw2 NO-GAPS.
                IF lv_raw2 CO '0123456789'.
                  ls_idx-num = lv_raw2. " gán số an toàn (packed)
                ELSE.
                  ls_idx-num = 0.
                ENDIF.
              ELSE.
                ls_idx-num = 0.
              ENDIF.
              APPEND ls_idx TO lt_idx.
            ENDLOOP.

            SORT lt_idx BY num.

            " Sắp lại thứ tự thực tế của <lt_load> theo lt_idx
            DATA: lr_tmp TYPE REF TO data,
                  lo_tab TYPE REF TO cl_abap_tabledescr.
            FIELD-SYMBOLS: <lt_tmp> TYPE STANDARD TABLE.

            lo_tab ?= cl_abap_tabledescr=>describe_by_data( <lt_load> ).
            CREATE DATA lr_tmp TYPE HANDLE lo_tab.
            ASSIGN lr_tmp->* TO <lt_tmp>.

            LOOP AT lt_idx INTO ls_idx.
              READ TABLE <lt_load> INDEX ls_idx-idx ASSIGNING <ls_row>.
              IF sy-subrc = 0.
                APPEND <ls_row> TO <lt_tmp>.
              ENDIF.
            ENDLOOP.

            <lt_load> = <lt_tmp>.
          ELSE.
            " Không phải numeric thuần -> sort theo chữ
            SORT <lt_load> STABLE BY (lv_key).
          ENDIF.

        ENDIF.
      ENDIF.
    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = |Bảng "{ lv_tabname }" không hợp lệ hoặc không truy vấn được: { lx_sem->get_text( ) }. Kiểm tra SE11 và activation.|.
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = |Lỗi DB cho bảng "{ lv_tabname }": { lx_db->get_text( ) }. Kiểm tra quyền truy cập (SU53).|.
"=== Merge dữ liệu audit từ bảng ZEDIT_AUDIT_LOG ===
DATA: lt_audit TYPE STANDARD TABLE OF zedit_audit_log,
      ls_audit TYPE zedit_audit_log,
      lv_key_audit TYPE string.
TRANSLATE lv_tabname TO UPPER CASE.
SELECT * FROM zedit_audit_log
  WHERE tabname = @lv_tabname
  INTO TABLE @lt_audit.

IF sy-subrc = 0.
  LOOP AT <lt_load> ASSIGNING FIELD-SYMBOL(<ls_audit_row>).
    CLEAR lv_key_audit.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<fname>).
      ASSIGN COMPONENT <fname> OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<fval>).
      IF sy-subrc = 0.
        CONCATENATE lv_key_audit <fval> INTO lv_key_audit SEPARATED BY '|'.
      ENDIF.
    ENDLOOP.

    READ TABLE lt_audit INTO ls_audit WITH KEY tabname = lv_tabname keyval = lv_key_audit.
    IF sy-subrc = 0.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<erdat>).
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<ertim>).
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<ernam>).
      ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<aedat>).
      ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<aetim>).
      ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_audit_row> TO FIELD-SYMBOL(<aenam>).

      IF <erdat> IS ASSIGNED. <erdat> = ls_audit-erdat. ENDIF.
      IF <ertim> IS ASSIGNED. <ertim> = ls_audit-ertim. ENDIF.
      IF <ernam> IS ASSIGNED. <ernam> = ls_audit-ernam. ENDIF.
      IF <aedat> IS ASSIGNED. <aedat> = ls_audit-aedat. ENDIF.
      IF <aetim> IS ASSIGNED. <aetim> = ls_audit-aetim. ENDIF.
      IF <aenam> IS ASSIGNED. <aenam> = ls_audit-aenam. ENDIF.
    ENDIF.
  ENDLOOP.
ENDIF.



  ENDTRY.
ENDFORM.



"===== Save dữ liệu từ itab xuống DB (chưa COMMIT) =====
FORM save_data USING iv_tab TYPE tabname
CHANGING cr_tab TYPE REF TO data
ev_mod TYPE i
ev_err TYPE string.

  ev_mod = 0.
  CLEAR ev_err.

  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_alv>.
  IF <lt_alv> IS NOT ASSIGNED OR <lt_alv> IS INITIAL.
    ev_err = 'Không có dữ liệu để lưu.'.
    RETURN.
  ENDIF.

  DATA lr_db_struct TYPE REF TO cl_abap_structdescr.
  DATA lr_db_table TYPE REF TO cl_abap_tabledescr.
  DATA lr_flat TYPE REF TO data.
  FIELD-SYMBOLS: <lt_flat> TYPE STANDARD TABLE,
                 <ls_flat> TYPE any,
                 <ls_alv>  TYPE any.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  lr_db_table = cl_abap_tabledescr=>create( p_line_type = lr_db_struct ).
  CREATE DATA lr_flat TYPE HANDLE lr_db_table.
  ASSIGN lr_flat->* TO <lt_flat>.

  LOOP AT <lt_alv> ASSIGNING <ls_alv>.
    APPEND INITIAL LINE TO <lt_flat> ASSIGNING <ls_flat>.
    MOVE-CORRESPONDING <ls_alv> TO <ls_flat>.

    FIELD-SYMBOLS <mandt> TYPE any.
    ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_flat> TO <mandt>.
    IF sy-subrc = 0 AND <mandt> IS ASSIGNED.
      <mandt> = sy-mandt.
    ENDIF.
  ENDLOOP.

  TRY.
      MODIFY (iv_tab) FROM TABLE <lt_flat>.
      ev_mod = sy-dbcnt.
    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.
"=== Ghi log audit cho các dòng đã lưu ===
  IF ev_mod > 0.
    LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv_row>).
      PERFORM log_audit_action USING iv_tab 'U' <ls_alv_row>.
    ENDLOOP.
  ENDIF.
ENDFORM.
*---------------------------------------------------------------------*
* FORM log_audit_action - Ghi log thêm/sửa vào ZEDIT_AUDIT_LOG
*---------------------------------------------------------------------*
FORM log_audit_action USING iv_tabname TYPE tabname
                            iv_action  TYPE c
                            is_row     TYPE any.

  DATA: ls_log TYPE zedit_audit_log,
        lv_key TYPE char255,
        lv_field TYPE tabname.

  FIELD-SYMBOLS <val> TYPE any.

  CLEAR lv_key.
  " Ghép key chính (nếu bảng có nhiều khóa)
  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<key>).
    ASSIGN COMPONENT <key> OF STRUCTURE is_row TO <val>.
    IF sy-subrc = 0 AND <val> IS ASSIGNED.
      lv_key = lv_key && <val> && '|'.
    ENDIF.
  ENDLOOP.
  SHIFT lv_key RIGHT DELETING TRAILING '|'.

  CLEAR ls_log.
  ls_log-mandt  = sy-mandt.
  ls_log-tabname = iv_tabname.
  ls_log-keyval  = lv_key.
  ls_log-action  = iv_action.

  IF iv_action = 'C'.
    ls_log-erdat = sy-datum.
    ls_log-ertim = sy-uzeit.
    ls_log-ernam = sy-uname.
  ELSEIF iv_action = 'U'.
    ls_log-aedat = sy-datum.
    ls_log-aetim = sy-uzeit.
    ls_log-aenam = sy-uname.
  ENDIF.

  TRY.
      INSERT zedit_audit_log FROM ls_log.
    CATCH cx_sy_open_sql_db.
      " Nếu trùng key -> chỉ update phần changed
      UPDATE zedit_audit_log SET
        aedat = ls_log-aedat
        aetim = ls_log-aetim
        aenam = ls_log-aenam
      WHERE tabname = ls_log-tabname
        AND keyval  = ls_log-keyval.
  ENDTRY.

ENDFORM.
FORM add_field_if_missing USING iv_name TYPE string
                                 iv_type TYPE c
                                 iv_len  TYPE i
                         CHANGING ct_comp TYPE abap_component_tab.

  DATA ls_comp TYPE abap_componentdescr.
  DATA lv_type4 TYPE c LENGTH 4.

  lv_type4 = iv_type.  " Gán 4 ký tự đầu vào biến cố định

  " Kiểm tra field đã tồn tại chưa
  READ TABLE ct_comp WITH KEY name = iv_name TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    RETURN.
  ENDIF.

  CLEAR ls_comp.
  ls_comp-name = iv_name.

  CASE lv_type4.
    WHEN 'DATS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
    WHEN 'TIMS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
    WHEN 'CHAR'.
      ls_comp-type ?= cl_abap_elemdescr=>get_c( iv_len ).
    WHEN OTHERS.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( lv_type4 ).
  ENDCASE.

  APPEND ls_comp TO ct_comp.

ENDFORM.

"===== ZFA25SAP23_MAIN =====
START-OF-SELECTION.

DATA: lv_rows_main TYPE i,
lv_err_main TYPE string,
lt_meta TYPE ddfields. " metadata chi tiết

" 1. Lấy metadata đầy đủ từ DDIC
PERFORM get_metadata USING p_tab CHANGING lt_meta.

" 2. Tạo itab động cho bảng p_tab
PERFORM create_dynamic_itab USING p_tab CHANGING gr_data.

" 3. Tạo fieldcatalog cho ALV
PERFORM build_fieldcat_all.

" 4. Đồng bộ fieldcatalog với itab động
PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.

" 5. Load dữ liệu từ DB
PERFORM load_data USING p_tab p_maxrow
CHANGING gr_data lv_rows_main lv_err_main.
IF lv_err_main IS NOT INITIAL.
MESSAGE e398(00) WITH lv_err_main.
RETURN.
ENDIF.

" 6. Gọi screen hiển thị ALV
CALL SCREEN 100.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_F01  (FINAL – multi-select rollback)
*&---------------------------------------------------------------------*

"=== Kiểu dữ liệu dùng chung ==========================================
TYPES: BEGIN OF ty_log_sel,
         sel         TYPE c LENGTH 1,          " checkbox trong popup
         mandt       TYPE mandt,
         logid       TYPE zaudit_log-logid,
         uname       TYPE zaudit_log-uname,
         udate       TYPE zaudit_log-udate,
         utime       TYPE zaudit_log-utime,
         tabname     TYPE zaudit_log-tabname,
         action      TYPE zaudit_log-action,
         before_json TYPE zaudit_log-before_json,
         after_json  TYPE zaudit_log-after_json,
       END OF ty_log_sel.

TYPES ty_t_log TYPE STANDARD TABLE OF zaudit_log WITH DEFAULT KEY.

*---------------------------------------------------------------------*
* Hiển thị lịch sử (nhiều chọn) và rollback (1 hoặc nhiều log)
*---------------------------------------------------------------------*
FORM show_audit_history.

  DATA: lt_log_raw   TYPE STANDARD TABLE OF zaudit_log,
        lt_log_disp  TYPE STANDARD TABLE OF ty_log_sel,
        ls_log_raw   TYPE zaudit_log,
        ls_log_disp  TYPE ty_log_sel,
        lt_fieldcat  TYPE slis_t_fieldcat_alv,
        lt_fieldcat2 TYPE slis_t_fieldcat_alv,
        ls_fc        TYPE slis_fieldcat_alv,
        ls_selfield  TYPE slis_selfield.

  DATA: lv_action TYPE zaudit_log-action,
        lv_title  TYPE c LENGTH 80,
        lv_msg    TYPE string,
        lv_ans    TYPE c LENGTH 1.

  DATA: lt_picked    TYPE STANDARD TABLE OF ty_log_sel WITH DEFAULT KEY,
        lt_final     TYPE ty_t_log,
        ls_final     TYPE zaudit_log,
        lt_seen_keys TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lv_keystr    TYPE string.

  DATA: lv_skip_insert TYPE i VALUE 0,
        lv_skip_empty  TYPE i VALUE 0,
        lv_conflicts   TYPE i VALUE 0,
        lv_cnt         TYPE i VALUE 0.

  DATA: lr_bef TYPE REF TO data.

  FIELD-SYMBOLS: <ls_pick> TYPE ty_log_sel,
                 <ls_bef>  TYPE any,
                 <lt_bef>  TYPE ANY TABLE,
                 <v>       TYPE any.

  " 1) Tải log
  SELECT *
    FROM zaudit_log
    INTO TABLE @lt_log_raw
    WHERE tabname = @p_tab
    ORDER BY udate DESCENDING, utime DESCENDING.

  IF lt_log_raw IS INITIAL.
    MESSAGE 'Không có lịch sử thay đổi' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Chuẩn bị outtab có checkbox
  REFRESH lt_log_disp.
  LOOP AT lt_log_raw INTO ls_log_raw.
    CLEAR ls_log_disp.
    ls_log_disp-mandt       = ls_log_raw-mandt.
    ls_log_disp-logid       = ls_log_raw-logid.
    ls_log_disp-uname       = ls_log_raw-uname.
    ls_log_disp-udate       = ls_log_raw-udate.
    ls_log_disp-utime       = ls_log_raw-utime.
    ls_log_disp-tabname     = ls_log_raw-tabname.
    ls_log_disp-action      = ls_log_raw-action.
    ls_log_disp-before_json = ls_log_raw-before_json.
    ls_log_disp-after_json  = ls_log_raw-after_json.
    APPEND ls_log_disp TO lt_log_disp.
  ENDLOOP.

  " 3) Fieldcat + chèn cột checkbox
  PERFORM build_fieldcat_audit CHANGING lt_fieldcat.
  lt_fieldcat2 = lt_fieldcat.

  CLEAR ls_fc.
  ls_fc-fieldname = 'SEL'.
  ls_fc-seltext_m = 'Sel'.
  ls_fc-checkbox  = 'X'.
  ls_fc-edit      = 'X'.
  ls_fc-outputlen = 3.
  ls_fc-no_out    = 'X'.
  INSERT ls_fc INTO lt_fieldcat2 INDEX 1.

  " 4) Popup multi-select
  lv_title = |Chọn một hoặc nhiều log để rollback cho bảng { p_tab }|.
  CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
    EXPORTING
      i_tabname             = 'ZAUDIT_LOG'   " DDIC của bảng log
      it_fieldcat           = lt_fieldcat2
      i_title               = lv_title
      i_zebra               = 'X'
      i_screen_start_column = 5
      i_screen_start_line   = 5
      i_screen_end_column   = 140
      i_screen_end_line     = 28
      i_checkbox_fieldname  = 'SEL'
    IMPORTING
      es_selfield           = ls_selfield
    TABLES
      t_outtab              = lt_log_disp
    EXCEPTIONS
      program_error         = 1
      OTHERS                = 2.
  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

  " 5) Lấy dòng đã tick
  REFRESH lt_picked.
  LOOP AT lt_log_disp ASSIGNING <ls_pick>.
    IF <ls_pick> IS ASSIGNED AND <ls_pick>-sel = 'X'.
      APPEND <ls_pick> TO lt_picked.
    ENDIF.
  ENDLOOP.
  IF lt_picked IS INITIAL.
    MESSAGE 'Chưa chọn log nào để rollback' TYPE 'S'.
    RETURN.
  ENDIF.

  " 6) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING p_tab IF FOUND.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Bảng { p_tab } không có khóa trong DDIC.| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 7) Lọc bỏ INSERT/JSON rỗng + chống conflict cùng khóa
  REFRESH lt_final.
  REFRESH lt_seen_keys.
  DATA: lv_keyname TYPE dd03l-fieldname,
        lv_piece   TYPE string,
        lv_tmp     TYPE string.

  LOOP AT lt_picked ASSIGNING <ls_pick>.
    IF <ls_pick> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    lv_action = <ls_pick>-action.
    TRANSLATE lv_action TO UPPER CASE.

    IF lv_action = 'INSERT'.
      lv_skip_insert += 1.
      CONTINUE.
    ENDIF.

    IF <ls_pick>-before_json IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    CLEAR lr_bef.
    PERFORM json_to_itab IN PROGRAM (sy-repid)
      USING <ls_pick>-tabname <ls_pick>-before_json
      CHANGING lr_bef IF FOUND.
    IF lr_bef IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    ASSIGN lr_bef->* TO <lt_bef>.
    IF <lt_bef> IS NOT ASSIGNED OR <lt_bef> IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    UNASSIGN <ls_bef>.
    LOOP AT <lt_bef> ASSIGNING <ls_bef>. EXIT. ENDLOOP.
    IF <ls_bef> IS NOT ASSIGNED.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    CLEAR lv_keystr.
    LOOP AT gt_key_fields INTO lv_keyname.
      ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls_bef> TO <v>.
      CLEAR lv_piece.
      IF sy-subrc = 0 AND <v> IS ASSIGNED.
        lv_tmp = <v>.
        TRANSLATE lv_tmp TO UPPER CASE.
        CONDENSE lv_tmp NO-GAPS.
        lv_piece = lv_tmp.
      ELSE.
        lv_piece = ''.
      ENDIF.
      IF lv_keystr IS INITIAL.
        lv_keystr = lv_piece.
      ELSE.
        CONCATENATE lv_keystr lv_piece INTO lv_keystr SEPARATED BY '|'.
      ENDIF.
    ENDLOOP.

    READ TABLE lt_seen_keys WITH KEY table_line = lv_keystr TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_conflicts = lv_conflicts + 1.
      CONTINUE.
    ELSE.
      APPEND lv_keystr TO lt_seen_keys.
    ENDIF.

    CLEAR ls_final.
    ls_final-mandt       = <ls_pick>-mandt.
    ls_final-logid       = <ls_pick>-logid.
    ls_final-uname       = <ls_pick>-uname.
    ls_final-udate       = <ls_pick>-udate.
    ls_final-utime       = <ls_pick>-utime.
    ls_final-tabname     = <ls_pick>-tabname.
    ls_final-action      = <ls_pick>-action.
    ls_final-before_json = <ls_pick>-before_json.
    ls_final-after_json  = <ls_pick>-after_json.
    APPEND ls_final TO lt_final.
  ENDLOOP.

  IF lt_final IS INITIAL.
    lv_msg = |Không có log hợp lệ để rollback (bỏ { lv_skip_insert } INSERT, { lv_skip_empty } JSON rỗng, { lv_conflicts } conflict).|.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

* 8) Xác nhận
  DESCRIBE TABLE lt_final LINES lv_cnt.
  lv_msg = |Bạn có muốn rollback { lv_cnt } log không?|.

  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
      titlebar              = 'Xác nhận'
      text_question         = lv_msg
      display_cancel_button = ' '       " Chỉ Yes/No
    IMPORTING
      answer                = lv_ans.

  IF lv_ans = '2'.                                  " '2' = No
    MESSAGE 'Hủy rollback thành công.' TYPE 'S'.    " hoặc DISPLAY LIKE 'I'
    RETURN.
  ENDIF.
  IF lv_ans <> '1'.                                 " khác 'Yes' thì thoát
    RETURN.
  ENDIF.



  " 9) Thực thi
  IF lv_cnt = 1.
    READ TABLE lt_final INDEX 1 INTO ls_final.
    IF sy-subrc = 0.
      PERFORM rollback_from_history USING ls_final.
    ENDIF.
  ELSE.
    DATA: lv_rows_ok TYPE i,
          lv_err     TYPE string.
    PERFORM perform_batch_rollback USING p_tab lt_final
                                   CHANGING lv_rows_ok lv_err.
    IF lv_err IS NOT INITIAL.
      MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.
  ENDIF.

  " 10) Refresh ALV
  PERFORM reload_after_change USING p_tab.

ENDFORM.

*=====================================================================*
* Batch rollback: rollback nhiều log trong 1 transaction + 1 email
*=====================================================================*
FORM perform_batch_rollback
  USING    iv_tab      TYPE tabname
           it_logs     TYPE ty_t_log
  CHANGING cv_rows_ok  TYPE i
           cv_err      TYPE string.

  DATA: lt_logs_local TYPE ty_t_log,
        ls_log        TYPE zaudit_log.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_targ   TYPE REF TO data,
        lr_curr   TYPE REF TO data.

  FIELD-SYMBOLS: <lt_targ> TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  DATA lr_one_json TYPE REF TO data.
  FIELD-SYMBOLS: <lt_one> TYPE ANY TABLE,
                 <ls_one> TYPE any.

  DATA: lv_where TYPE string,
        lv_we    TYPE string.

  DATA: lv_rows_ok TYPE i VALUE 0,
        lv_fail    TYPE abap_bool VALUE abap_false,
        lv_rc      TYPE sy-subrc.

  DATA: lv_curr_json TYPE zde_json_txt,
        lv_targ_json TYPE zde_json_txt,
        ls_newlog    TYPE zaudit_log.
  " Danh sách log để nhúng vào email gộp
  DATA: lv_loglist TYPE string,
        lv_one     TYPE string.

  CLEAR: cv_rows_ok, cv_err.

  " Sao chép input
  lt_logs_local = it_logs.
  IF lt_logs_local IS INITIAL.
    cv_err = 'Không có log để rollback (batch).'.
    RETURN.
  ENDIF.

  " Tạo itab động theo DDIC của iv_tab
  lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  IF lo_struct IS INITIAL.
    cv_err = |Không mô tả được cấu trúc bảng { iv_tab }|.
    RETURN.
  ENDIF.
  lo_table = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CREATE DATA lr_targ TYPE HANDLE lo_table.
  CREATE DATA lr_curr TYPE HANDLE lo_table.
  ASSIGN lr_targ->* TO <lt_targ>.
  ASSIGN lr_curr->* TO <lt_curr>.
  REFRESH: <lt_targ>, <lt_curr>.

  " Gom mục tiêu từ BEFORE_JSON
  LOOP AT lt_logs_local INTO ls_log.
    CLEAR lr_one_json.
    PERFORM json_to_itab IN PROGRAM (sy-repid)
      USING iv_tab ls_log-before_json
      CHANGING lr_one_json IF FOUND.
    IF lr_one_json IS INITIAL.
      CONTINUE.
    ENDIF.

    ASSIGN lr_one_json->* TO <lt_one>.
    IF <lt_one> IS INITIAL.
      CONTINUE.
    ENDIF.

    LOOP AT <lt_one> ASSIGNING <ls_one>.
      APPEND <ls_one> TO <lt_targ>.
    ENDLOOP.
  ENDLOOP.

  IF <lt_targ> IS INITIAL.
    cv_err = 'Không có dữ liệu mục tiêu để rollback (batch).'.
    RETURN.
  ENDIF.

  " Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING iv_tab IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_err = |Không tìm thấy key fields cho bảng { iv_tab }|.
    RETURN.
  ENDIF.

  " Snapshot hiện trạng
  LOOP AT <lt_targ> ASSIGNING <ls_row>.
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_row> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      CONTINUE.
    ENDIF.

    DATA lr_currow TYPE REF TO data.
    CREATE DATA lr_currow TYPE HANDLE lo_struct.
    ASSIGN lr_currow->* TO FIELD-SYMBOL(<lcur>).
    CLEAR <lcur>.

    SELECT SINGLE * FROM (iv_tab) WHERE (lv_where) INTO @<lcur>.
    IF sy-subrc = 0.
      APPEND <lcur> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  " Serialize snapshot & target cho audit/mail
  /ui2/cl_json=>serialize(
    EXPORTING data        = <lt_curr>
              pretty_name = /ui2/cl_json=>pretty_mode-none
    RECEIVING r_json      = lv_curr_json ).
  /ui2/cl_json=>serialize(
    EXPORTING data        = <lt_targ>
              pretty_name = /ui2/cl_json=>pretty_mode-none
    RECEIVING r_json      = lv_targ_json ).

  " Khôi phục: DELETE-by-key rồi INSERT
  LOOP AT <lt_targ> ASSIGNING <ls_row>.
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_row> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      lv_fail = abap_true.
      EXIT.
    ENDIF.

    DELETE FROM (iv_tab) WHERE (lv_where).
    INSERT (iv_tab) FROM <ls_row>.
    lv_rc = sy-subrc.
    IF lv_rc <> 0.
      lv_fail = abap_true.
      EXIT.
    ELSE.
      lv_rows_ok = lv_rows_ok + 1.
    ENDIF.
  ENDLOOP.

  IF lv_fail = abap_true.
    ROLLBACK WORK.
    cv_err = 'Rollback batch thất bại – đã ROLLBACK toàn bộ.'.
    RETURN.
  ENDIF.

  " Ghi 1 dòng audit gộp
  CLEAR ls_newlog.
  CALL FUNCTION 'GUID_CREATE'
    IMPORTING
      ev_guid_32 = ls_newlog-logid.
  ls_newlog-mandt       = sy-mandt.
  ls_newlog-uname       = sy-uname.
  ls_newlog-udate       = sy-datum.
  ls_newlog-utime       = sy-uzeit.
  ls_newlog-tabname     = iv_tab.
  ls_newlog-action      = 'ROLLBACK-BATCH'.
  ls_newlog-before_json = lv_curr_json.
  ls_newlog-after_json  = lv_targ_json.
  INSERT zaudit_log FROM ls_newlog.

  " Commit & build danh sách log để nhúng vào email gộp
  COMMIT WORK AND WAIT.

  CLEAR lv_loglist.
  lv_loglist = |Batch rollback { lines( lt_logs_local ) } log(s):|.
  LOOP AT lt_logs_local INTO ls_log.
    CLEAR lv_one.
    lv_one = |[LOGID={ ls_log-logid(8) } USER={ ls_log-uname } DATE={ ls_log-udate } TIME={ ls_log-utime } ACTION={ ls_log-action }]|.
    CONCATENATE lv_loglist
                cl_abap_char_utilities=>newline
                lv_one
           INTO lv_loglist.
  ENDLOOP.

  " Gửi 1 email gộp có kèm danh sách các log
  PERFORM notify_rollback_smtp IN PROGRAM (sy-repid)
    USING ls_newlog
          lv_rows_ok
          lv_curr_json
          lv_targ_json
          lv_loglist        " <<< thay 'space' bằng danh sách log
          IF FOUND.


  " Trả kết quả
  cv_rows_ok = lv_rows_ok.
  cv_err     = ''.

  MESSAGE |Rollback OK: { lv_rows_ok } row(s) từ { lines( lt_logs_local ) } log| TYPE 'S'.

ENDFORM.

*---------------------------------------------------------------------*
* Field catalog cho popup lịch sử
*---------------------------------------------------------------------*
FORM build_fieldcat_audit CHANGING ct_fieldcat TYPE slis_t_fieldcat_alv.
  DATA ls_fieldcat TYPE slis_fieldcat_alv.

  DEFINE add_field.
    CLEAR ls_fieldcat.
    ls_fieldcat-fieldname = &1.
    ls_fieldcat-seltext_m = &2.
    ls_fieldcat-outputlen = &3.
    APPEND ls_fieldcat TO ct_fieldcat.
  END-OF-DEFINITION.

  add_field 'LOGID'       'Log ID'               32.
  add_field 'UNAME'       'Người dùng'           12.
  add_field 'UDATE'       'Ngày'                 10.
  add_field 'UTIME'       'Giờ'                   8.
  add_field 'ACTION'      'Hành động'            10.
  add_field 'BEFORE_JSON' 'Dữ liệu trước (JSON)' 50.
  add_field 'AFTER_JSON'  'Dữ liệu sau (JSON)'   50.
ENDFORM.

*---------------------------------------------------------------------*
* Rollback 1 log (giữ nguyên behavior cũ)
*---------------------------------------------------------------------*
FORM rollback_from_history USING is_log TYPE zaudit_log.

  DATA: lv_mod       TYPE i,
        lv_err       TYPE string,
        lv_curr_json TYPE zde_json_txt,
        lr_target    TYPE REF TO data,
        lr_curr      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_target> TYPE STANDARD TABLE,
                 <ls_target> TYPE any,
                 <lt_curr>   TYPE STANDARD TABLE,
                 <ls_curr>   TYPE any.

  DATA lv_act TYPE zaudit_log-action.
  lv_act = is_log-action.
  TRANSLATE lv_act TO UPPER CASE.
  IF lv_act = 'INSERT'.
    MESSAGE |Log { is_log-logid(8) } là CREATE (INSERT) – không thể rollback.| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM json_to_itab IN PROGRAM (sy-repid)
       USING is_log-tabname is_log-before_json
       CHANGING lr_target IF FOUND.
  ASSIGN lr_target->* TO <lt_target>.
  IF <lt_target> IS NOT ASSIGNED OR <lt_target> IS INITIAL.
    MESSAGE |Không đọc được BEFORE_JSON của log { is_log-logid }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys IN PROGRAM (sy-repid) USING is_log-tabname IF FOUND.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  DATA: lo_tdesc TYPE REF TO cl_abap_tabledescr,
        lo_ldesc TYPE REF TO cl_abap_structdescr,
        lr_row   TYPE REF TO data.
  lo_tdesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_target ).
  lo_ldesc ?= lo_tdesc->get_table_line_type( ).
  CREATE DATA lr_curr TYPE HANDLE lo_tdesc.
  ASSIGN lr_curr->* TO <lt_curr>.

  LOOP AT <lt_target> ASSIGNING <ls_target>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_target> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      CONTINUE.
    ENDIF.

    CREATE DATA lr_row TYPE HANDLE lo_ldesc.
    ASSIGN lr_row->* TO <ls_curr>.
    CLEAR <ls_curr>.

    SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
    IF sy-subrc = 0.
      APPEND <ls_curr> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  IF <lt_curr> IS NOT INITIAL.
    /ui2/cl_json=>serialize(
       EXPORTING data        = <lt_curr>
                 pretty_name = /ui2/cl_json=>pretty_mode-none
       RECEIVING r_json      = lv_curr_json ).
  ELSE.
    lv_curr_json = '[]'.
  ENDIF.

  PERFORM restore_data IN PROGRAM (sy-repid)
    USING is_log-tabname
          is_log-before_json
    CHANGING lv_err lv_mod IF FOUND.
  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  MESSAGE |Rollback thành công (log: { is_log-logid(8) }, rows: { lv_mod })| TYPE 'S'.

  PERFORM notify_rollback_smtp IN PROGRAM (sy-repid)
    USING is_log
          lv_mod
          lv_curr_json
          is_log-before_json
          space
          IF FOUND.

  PERFORM reload_after_change USING is_log-tabname.

ENDFORM.

*---------------------------------------------------------------------*
* Reload dữ liệu và refresh ALV sau khi có thay đổi DB
*---------------------------------------------------------------------*
FORM reload_after_change USING iv_tab TYPE tabname.

  DATA: lv_rows TYPE i,
        lv_err  TYPE string,
        ls_stbl TYPE lvc_s_stbl.

  PERFORM load_data USING iv_tab 0
                    CHANGING gr_data lv_rows lv_err.
  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.
  PERFORM apply_editability_and_push.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    CLEAR ls_stbl.
    ls_stbl-row = 'X'.
    ls_stbl-col = 'X'.
    g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

ENDFORM.