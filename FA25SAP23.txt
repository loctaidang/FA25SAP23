*&---------------------------------------------------------------------*
*& Report ZFA25SAP23
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zfa25sap23.

INCLUDE zfa25sap23_top.     "Khai báo biến toàn cục, TYPE, constant
INCLUDE zfa25sap23_sel.     "Selection screen
INCLUDE zfa25sap23_auth.    "Check whitelist + AUTHORITY-CHECK
INCLUDE zfa25sap23_ddic.    "Metadata + RTTC/RTTS + fieldcatalog
INCLUDE zfa25sap23_alv.     "ALV show + event
INCLUDE zfa25sap23_io.      "Upload/Download CSV, clipboard
INCLUDE zfa25sap23_audit.   "Audit log + rollback
INCLUDE zfa25sap23_db.      "Load/Save DB
INCLUDE zfa25sap23_main.    "START-OF-SELECTION + flow chính
INCLUDE zfa25sap23_f01.     "FORM rollBack"
*&---------------------------------------------------------------------*


"===== INCLUDE ZFA25SAP23_TOP =====
" Global declarations dùng chung cho DB/ALV/MAIN

CONSTANTS gc_hard_rcpt TYPE ad_smtpadr VALUE 'thanhchse171611@fpt.edu.vn'. " mail nhận cố định

TYPE-POOLS: abap.
CLASS lcl_alv_handler DEFINITION DEFERRED.

DATA: gv_toolbar_mode TYPE c LENGTH 1 VALUE 'D'. " 'D' = display, 'E' = edit

"––– Dữ liệu động (itab) cho mọi bảng
DATA: gr_data TYPE REF TO data.
FIELD-SYMBOLS: <gt_data> TYPE STANDARD TABLE,
               <gs_wa>   TYPE any.
"––– Ghi log lỗi chi tiết để hiển thị + debug + tô màu
TYPES: BEGIN OF ty_error_log,
         row   TYPE i,
         col   TYPE i,
         field TYPE fieldname,
         value TYPE string,
         msg   TYPE string,
       END OF ty_error_log,
       ty_t_error_log TYPE STANDARD TABLE OF ty_error_log WITH DEFAULT KEY.

DATA: gt_error_log TYPE ty_t_error_log.
DATA gv_keys_tabname TYPE tabname.
DATA lv_msg TYPE string.

"––– Cấu trúc style để highlight lỗi trong ALV
TYPES: BEGIN OF ty_cell_style,
         fieldname TYPE fieldname,
         style     TYPE lvc_s_styl,
       END OF ty_cell_style,
       ty_t_celltab TYPE STANDARD TABLE OF ty_cell_style WITH DEFAULT KEY.


"––– ALV objects & cấu hình
DATA: g_container TYPE REF TO cl_gui_custom_container,
      g_alv_grid  TYPE REF TO cl_gui_alv_grid,
      g_okcode    TYPE sy-ucomm,
      g_handler   TYPE REF TO lcl_alv_handler,
      gv_edit_md  TYPE abap_bool VALUE abap_false. " =SPACE: VIEW, 'X': EDIT

      DATA: gt_dc_del_rows TYPE lvc_t_roid, " giữ danh sách dòng ALV báo xóa
      gv_from_dc     TYPE abap_bool.  " cờ: xóa từ data_changed (phím Delete)

DATA: gt_fieldcat TYPE lvc_t_fcat,
      gs_fieldcat TYPE lvc_s_fcat,
      gs_layout   TYPE lvc_s_layo.
TYPES: ty_fieldnames TYPE STANDARD TABLE OF fieldname WITH EMPTY KEY.
DATA: gt_fieldnames TYPE ty_fieldnames.
CONSTANTS: gc_cc_alv TYPE scrfname VALUE 'CC_ALV'.

DATA: gv_add_mode TYPE abap_bool VALUE abap_false.

"Cache danh sách trường khoá
DATA gt_key_fields TYPE STANDARD TABLE OF dd03l-fieldname WITH DEFAULT KEY.

"Buffer audit
TYPES: BEGIN OF ty_audit,
         logid       TYPE char32,
         uname       TYPE syuname,
         udate       TYPE sydatum,
         utime       TYPE syuzeit,
         tabname     TYPE tabname,
         action      TYPE char10,
         before_json TYPE zde_json_txt,
         after_json  TYPE zde_json_txt,
       END OF ty_audit.
DATA gt_audit TYPE STANDARD TABLE OF ty_audit WITH DEFAULT KEY.

DATA gv_dirty TYPE abap_bool VALUE abap_false.
DATA gv_del_newrec_only TYPE abap_bool VALUE abap_false.
DATA: gv_dirty_nonnewrec TYPE abap_bool VALUE abap_false.


TYPES: ty_fname TYPE lvc_fname.
DATA: gt_f4_whitelist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line,
      gt_f4_blacklist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line.
DATA gr_data_original TYPE REF TO data.

DATA: gv_can_create  TYPE abap_bool,
      gv_can_change  TYPE abap_bool,
      gv_can_delete  TYPE abap_bool,
      gv_can_display TYPE abap_bool.
DATA gt_added_audit_fields TYPE TABLE OF fieldname WITH EMPTY KEY.
DATA gt_tb_excl TYPE ui_functions.

TYPES: ty_keyhash TYPE string.
DATA: gt_changed_existing_keys TYPE HASHED TABLE OF ty_keyhash WITH UNIQUE KEY table_line.
DATA gv_in_upload TYPE abap_bool VALUE abap_false.


"=== Types cho payload thay đổi (SAVE email) ==========================
TYPES: BEGIN OF zty_change,
         row_key         TYPE string,        " key hợp nhất (text)
         change_type     TYPE c LENGTH 1,    " '+' insert, '~' update, '-' delete
         changed_columns TYPE string,        " CSV tên cột đổi (cho UPDATE)
         before_json     TYPE zde_json_txt,  " dùng cùng định dạng JSON như ty_audit
         after_json      TYPE zde_json_txt,
       END OF zty_change.

TYPES: zty_change_tab TYPE STANDARD TABLE OF zty_change WITH DEFAULT KEY.
"=====================================================================



"===== INCLUDE ZFA25SAP23_SEL =====

" Khối tham số
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-001.
  PARAMETERS:
    p_tab    TYPE tabname OBLIGATORY, "Bảng Z*
    p_maxrow TYPE i DEFAULT 200.
SELECTION-SCREEN END OF BLOCK b1.

" F4 cho tên bảng

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tab.
  PERFORM f4_tabname.

  " Kiểm tra hợp lệ khi người dùng nhấn Execute

AT SELECTION-SCREEN.
  PERFORM validate_tab.
  PERFORM validate_maxrow.

  "Validate bảng
FORM validate_tab.
  " Chưa nhập
  IF p_tab IS INITIAL.
    MESSAGE e398(00) WITH text-002.
  ENDIF.

  " Bảng phải là Z*, transparent, active
  SELECT SINGLE tabname
    FROM dd02l
    INTO @DATA(lv_tab)
    WHERE tabname  = @p_tab
      AND tabclass = 'TRANSP'
  AND as4local = 'A'
  AND tabname  LIKE 'Z%'.

  IF sy-subrc <> 0.

    lv_msg = TEXT-003.
    REPLACE '&1' IN lv_msg WITH p_tab.
    MESSAGE e398(00) WITH lv_msg.


*    MESSAGE e398(00) WITH |Bảng { p_tab } không hợp lệ (chỉ Z* active).|.
  ENDIF.
ENDFORM.

"Validate p_maxrow
FORM validate_maxrow.
  IF p_maxrow IS INITIAL OR p_maxrow <= 0.
*    MESSAGE e398(00) WITH 'p_maxrow phải > 0'.
    MESSAGE e398(00) WITH text-004.

  ENDIF.
ENDFORM.

" Subroutine: F4 chọn bảng Z* active
FORM f4_tabname.
  TYPES: BEGIN OF ty_tab,
           tabname TYPE dd02l-tabname,
         END OF ty_tab.
  DATA: lt_tabs TYPE STANDARD TABLE OF ty_tab,
        lt_ret  TYPE TABLE OF ddshretval.

  SELECT tabname
    FROM dd02l
    INTO TABLE lt_tabs
    WHERE tabname LIKE 'Z%'
      AND tabclass = 'TRANSP'
  AND as4local = 'A'
  ORDER BY tabname.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'TABNAME'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = 'P_TAB'
      value_org       = 'S'
    TABLES
      value_tab       = lt_tabs
      return_tab      = lt_ret
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
    READ TABLE lt_ret INDEX 1 INTO DATA(ls_ret).
    IF sy-subrc = 0.
      p_tab = ls_ret-fieldval.
    ENDIF.
  ENDIF.
ENDFORM.





*----------------------------------------------------------------------*
*  Include: ZFA25SAP23_AUTH
*----------------------------------------------------------------------*

FORM check_authorization .
  DATA: lv_can_create  TYPE abap_bool,
        lv_can_change  TYPE abap_bool,
        lv_can_delete  TYPE abap_bool,
        lv_can_display TYPE abap_bool.

  "--- Kiểm tra quyền
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '01'.
  IF sy-subrc = 0. lv_can_create = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '02'.
  IF sy-subrc = 0. lv_can_change = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '06'.
  IF sy-subrc = 0. lv_can_delete = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '03'.
  IF sy-subrc = 0. lv_can_display = abap_true. ENDIF.

  "--- LƯU Ý:
  " KHÔNG reset gv_edit_md / gv_toolbar_mode ở đây
  " Trạng thái Edit/View sẽ do người dùng bấm EVTG, hoặc do PAI quyết định.

  "--- Lưu lại quyền để toolbar biết ẩn/hiện nút
  gv_can_create  = lv_can_create.
  gv_can_change  = lv_can_change.
  gv_can_delete  = lv_can_delete.
  gv_can_display = lv_can_display.
ENDFORM.


FORM has_actvt USING iv_act TYPE activ_auth CHANGING ev_ok TYPE abap_bool.
  ev_ok = abap_false.
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD iv_act.
  IF sy-subrc = 0.
    ev_ok = abap_true.
  ENDIF.
ENDFORM.




*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_DDIC
*&---------------------------------------------------------------------*
*& Xử lý metadata, tạo itab động và fieldcatalog
*&---------------------------------------------------------------------*

"=== Build fieldcatalog cho ALV ===
FORM build_fieldcat USING p_field p_text.
  CLEAR gs_fieldcat.
  gs_fieldcat-fieldname = p_field.
  gs_fieldcat-seltext = p_text. " Tiêu đề cột
  gs_fieldcat-scrtext_m = p_text.   " Tên trung bình
  gs_fieldcat-reptext   = p_text.   " Tên report
  gs_fieldcat-coltext   = p_text.
  APPEND gs_fieldcat TO gt_fieldcat.
ENDFORM.

FORM build_fieldcat_all .
  REFRESH: gt_fieldcat, gt_fieldnames.

  "--- Lấy fieldcatalog từ DDIC
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name       = p_tab
    CHANGING
      ct_fieldcat            = gt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  IF gt_fieldcat IS INITIAL.
*    MESSAGE |Không tạo được fieldcatalog cho bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.


    lv_msg = TEXT-005.
    REPLACE '&1' IN lv_msg WITH p_tab.

    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

    RETURN.
  ENDIF.

  "--- Ẩn MANDT nếu có
  FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    IF <fs_fcat>-fieldname = 'MANDT'.
      <fs_fcat>-no_out = abap_true.
      <fs_fcat>-tech   = abap_true.
    ENDIF.
  ENDLOOP.

  "--- Thêm 6 cột audit CHỈ KHI chưa có
  DATA: lv_colpos TYPE i,
        ls_fc     TYPE lvc_s_fcat.

  DESCRIBE TABLE gt_fieldcat LINES lv_colpos.

  " ERDAT
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERDAT' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERDAT'.
    ls_fc-coltext   = 'Created On'.
    ls_fc-scrtext_m = 'Created On'.
    ls_fc-reptext   = 'Created On'.
    ls_fc-seltext   = 'Created On'.
    ls_fc-col_pos   = lv_colpos + 1.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " ERTIM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERTIM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERTIM'.
    ls_fc-coltext   = 'Created Time'.
    ls_fc-scrtext_m = 'Created Time'.
    ls_fc-reptext   = 'Created Time'.
    ls_fc-seltext   = 'Created Time'.
    ls_fc-col_pos   = lv_colpos + 2.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " ERNAM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERNAM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERNAM'.
    ls_fc-coltext   = 'Created By'.
    ls_fc-scrtext_m = 'Created By'.
    ls_fc-reptext   = 'Created By'.
    ls_fc-seltext   = 'Created By'.
    ls_fc-col_pos   = lv_colpos + 3.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AEDAT
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AEDAT' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AEDAT'.
    ls_fc-coltext   = 'Changed On'.
    ls_fc-scrtext_m = 'Changed On'.
    ls_fc-reptext   = 'Changed On'.
    ls_fc-seltext   = 'Changed On'.
    ls_fc-col_pos   = lv_colpos + 4.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AETIM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AETIM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AETIM'.
    ls_fc-coltext   = 'Changed Time'.
    ls_fc-scrtext_m = 'Changed Time'.
    ls_fc-reptext   = 'Changed Time'.
    ls_fc-seltext   = 'Changed Time'.
    ls_fc-col_pos   = lv_colpos + 5.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AENAM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AENAM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AENAM'.
    ls_fc-coltext   = 'Changed By'.
    ls_fc-scrtext_m = 'Changed By'.
    ls_fc-reptext   = 'Changed By'.
    ls_fc-seltext   = 'Changed By'.
    ls_fc-col_pos   = lv_colpos + 6.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Thêm field kỹ thuật CELLTAB (ẩn) nếu thiếu
  READ TABLE gt_fieldcat WITH KEY fieldname = 'CELLTAB' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'CELLTAB'.
    ls_fc-col_pos   = 999.
    ls_fc-no_out    = abap_true.
    ls_fc-tech      = abap_true.
    ls_fc-inttype   = 'L'.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Thêm field kỹ thuật ROW_COLOR (ẩn) nếu thiếu
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ROW_COLOR' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ROW_COLOR'.
    ls_fc-col_pos   = 1000.
    ls_fc-no_out    = abap_true.
    ls_fc-tech      = abap_true.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Force read-only cho các cột audit trên FIELDCAT
  DATA: lt_audit_f TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit_f.
  APPEND 'ERTIM' TO lt_audit_f.
  APPEND 'ERNAM' TO lt_audit_f.
  APPEND 'AEDAT' TO lt_audit_f.
  APPEND 'AETIM' TO lt_audit_f.
  APPEND 'AENAM' TO lt_audit_f.

  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    READ TABLE lt_audit_f WITH KEY table_line = <fs_fcat>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CLEAR: <fs_fcat>-edit, <fs_fcat>-f4availabl.  " xám + không F4
    ENDIF.
  ENDLOOP.

  "--- (Tuỳ chọn) Khử trùng lặp lần cuối nếu có
  PERFORM dedup_fieldcat.

  "--- Build danh sách caption để dùng nơi khác
  CLEAR gt_fieldnames.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    IF <fs_fcat>-tech = abap_true OR <fs_fcat>-no_out = abap_true.
      CONTINUE.
    ENDIF.
    DATA(lv_name) = COND string(
                       WHEN <fs_fcat>-coltext IS NOT INITIAL
                       THEN <fs_fcat>-coltext
                       ELSE <fs_fcat>-fieldname ).
    lv_name = to_upper( condense( lv_name ) ).
    CONDENSE lv_name NO-GAPS.
    APPEND lv_name TO gt_fieldnames.
  ENDLOOP.

  "--- Bật F4 (chuẩn hoặc fallback)
  PERFORM enable_f4_in_fieldcat.
ENDFORM.



"=== Tạo itab động từ bảng p_tab ===
FORM create_dynamic_itab USING p_tabname TYPE tabname
CHANGING p_itab TYPE REF TO data.

  DATA: lo_descr TYPE REF TO cl_abap_structdescr,
        lo_table TYPE REF TO cl_abap_tabledescr.

  TRY.
      " Lấy mô tả cấu trúc của bảng p_tabname
      lo_descr ?= cl_abap_typedescr=>describe_by_name( p_tabname ).
      lo_table = cl_abap_tabledescr=>create( lo_descr ).
      "=== Thêm 6 field audit tự động, tránh trùng tên ===
      DATA: lt_components TYPE abap_component_tab,
            ls_component  TYPE abap_componentdescr,
            lt_names      TYPE STANDARD TABLE OF string.

      DATA(lo_struct) = CAST cl_abap_structdescr( lo_table->get_table_line_type( ) ).
      lt_components = lo_struct->get_components( ).

      " Lấy danh sách field hiện có
      LOOP AT lt_components INTO ls_component.
        APPEND ls_component-name TO lt_names.
      ENDLOOP.

      DEFINE add_field_if_missing.
        READ TABLE lt_names WITH KEY table_line = &1 TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CLEAR ls_component.
          ls_component-name = &1.
          ls_component-type ?= cl_abap_elemdescr=>describe_by_name( &2 ).
          APPEND ls_component TO lt_components.
        ENDIF.
      END-OF-DEFINITION.

      add_field_if_missing 'ERDAT' 'DATS'.  " Created On
      add_field_if_missing 'ERTIM' 'TIMS'.  " Created Time
      add_field_if_missing 'ERNAM' 'UNAME'. " Created By
      add_field_if_missing 'AEDAT' 'DATS'.  " Changed On
      add_field_if_missing 'AETIM' 'TIMS'.  " Changed Time
      add_field_if_missing 'AENAM' 'UNAME'. " Changed By

      " Tạo lại mô tả cấu trúc có 6 field mới
      DATA(lo_new_struct) = cl_abap_structdescr=>create( lt_components ).
      DATA(lo_new_table)  = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

      CREATE DATA p_itab TYPE HANDLE lo_new_table.

*      CREATE DATA p_itab TYPE HANDLE lo_table.

    CATCH cx_sy_create_data_error INTO DATA(lx_create).
*      MESSAGE |Không tạo được itab động cho { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
      lv_msg = TEXT-006.
      REPLACE '&1' IN lv_msg WITH p_tabname.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

      RETURN.
  ENDTRY.

ENDFORM.





*---------------------------------------------------------------------*
* Đồng bộ fieldcatalog với line type của itab động (gr_data)
*---------------------------------------------------------------------*
FORM sync_fcat_with_itab CHANGING ct_fcat TYPE lvc_t_fcat.

  DATA: lo_tab  TYPE REF TO cl_abap_tabledescr,
        lo_line TYPE REF TO cl_abap_structdescr,
        lt_comp TYPE abap_component_tab.

  IF gr_data IS INITIAL.
    RETURN.
  ENDIF.

  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( gr_data ).
  lo_line ?= CAST cl_abap_structdescr( lo_tab->get_table_line_type( ) ).
  lt_comp = lo_line->get_components( ).

  LOOP AT ct_fcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
    READ TABLE lt_comp WITH KEY name = <fs_fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE ct_fcat.
    ENDIF.
  ENDLOOP.

  " Sau khi sync có thể có cột bị xóa → bật lại F4 cho chắc
  PERFORM enable_f4_in_fieldcat.


ENDFORM.



FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
CHANGING er_data TYPE REF TO data.

  DATA: lt_dfies      TYPE TABLE OF dfies,
        lt_components TYPE cl_abap_structdescr=>component_table,
        ls_component  LIKE LINE OF lt_components.

  " Lấy metadata từ DDIC
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tabname
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
*    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
    MESSAGE TEXT-007 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " Lọc các trường không phải style (tên field thường là CELLTAB)
  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'. " Thay 'CELLTAB' nếu tên field style khác
    ls_component-name = ls_dfies-fieldname.
    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
    APPEND ls_component TO lt_components.
  ENDLOOP.

  " Tạo cấu trúc động
  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
  lr_struct_type = cl_abap_structdescr=>create( lt_components ).

  " Tạo internal table động
  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
  lr_table_type = cl_abap_tabledescr=>create(
  p_line_type = lr_struct_type
  p_table_kind = cl_abap_tabledescr=>tablekind_std ).
  CREATE DATA er_data TYPE HANDLE lr_table_type.

ENDFORM.


*---------------------------------------------------------------------*
* Thêm 6 field audit (Created/Changed) vào cấu trúc động
*---------------------------------------------------------------------*
FORM add_audit_fields CHANGING ct_components TYPE cl_abap_structdescr=>component_table.
  DATA ls_component LIKE LINE OF ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERTIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERNAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AEDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AETIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AENAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.
ENDFORM.


*---------------------------------------------------------------------*
* Lấy metadata chi tiết từ DDIC (so với fieldcatalog ALV)
*---------------------------------------------------------------------*
FORM get_metadata USING p_tabname TYPE tabname
CHANGING ct_meta TYPE ddfields.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tabname
      langu          = sy-langu
      all_types      = 'X'
    TABLES
      dfies_tab      = ct_meta
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR ct_meta IS INITIAL.
*    MESSAGE |Không lấy được metadata cho bảng { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    lv_msg = TEXT-008.
    REPLACE '&1' IN lv_msg WITH p_tabname.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

    RETURN.
  ENDIF.

ENDFORM.

FORM enable_f4_in_fieldcat .
  DATA: lt_meta TYPE TABLE OF dfies,
        ls_meta TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_meta
    EXCEPTIONS
      OTHERS    = 1.

  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Mặc định tắt F4
    <fc>-f4availabl = abap_false.

    " Xác định có phải khóa?
    DATA(lv_is_key) = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    CLEAR ls_meta.
    READ TABLE lt_meta INTO ls_meta WITH KEY fieldname = <fc>-fieldname.

    " 1) Ưu tiên SH/FK
    IF sy-subrc = 0 AND ( ls_meta-f4availabl = 'X' OR ls_meta-checktable IS NOT INITIAL ).
      <fc>-f4availabl = abap_true.
    ELSE.
      " 2) Loại trừ kiểu không nên F4
      DATA(lv_is_disallowed) = abap_false.
      IF ls_meta-datatype = 'DATS' OR ls_meta-datatype = 'TIMS'.
        lv_is_disallowed = abap_true.
      ENDIF.
      IF ls_meta-datatype = 'QUAN' OR ls_meta-datatype = 'CURR'
         OR ls_meta-reffield  IS NOT INITIAL OR ls_meta-reftable IS NOT INITIAL.
        lv_is_disallowed = abap_true.
      ENDIF.

      " 3) Fallback chỉ cho non-key & không bị disallow
      IF lv_is_key = abap_false AND lv_is_disallowed = abap_false.
        CASE ls_meta-inttype.
          WHEN 'C' OR 'N' OR 'P' OR 'I' OR 'F'.
            <fc>-f4availabl = abap_true.
        ENDCASE.
      ENDIF.
    ENDIF.

    " 4) Whitelist / Blacklist
    READ TABLE gt_f4_whitelist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_true. ENDIF.

    READ TABLE gt_f4_blacklist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_false. ENDIF.

  ENDLOOP.
ENDFORM.



FORM register_f4_all .
  DATA: lt_f4   TYPE lvc_t_f4,
        ls_f4   TYPE lvc_s_f4,
        lt_seen TYPE HASHED TABLE OF lvc_fname WITH UNIQUE KEY table_line,
        lv_name TYPE lvc_fname.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  CLEAR: lt_f4, lt_seen.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    IF <fc>-f4availabl = abap_true.
      lv_name = <fc>-fieldname.
      IF lv_name IS INITIAL. CONTINUE. ENDIF.

      READ TABLE lt_seen WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. CONTINUE. ENDIF.
      INSERT lv_name INTO TABLE lt_seen.

      CLEAR ls_f4.
      ls_f4-fieldname = lv_name.
      ls_f4-register = abap_true.
      ls_f4-getbefore = abap_true.
      ls_f4-chngeafter = abap_false.

      INSERT ls_f4 INTO TABLE lt_f4.
    ENDIF.
  ENDLOOP.

  TRY.
      g_alv_grid->register_f4_for_fields( it_f4 = lt_f4 ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

"=== helper: chỉ thêm field vào fieldcatalog nếu chưa có
FORM add_fc_if_missing USING iv_field  TYPE lvc_fname
                              iv_text   TYPE string
                              iv_colpos TYPE i.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-coltext   = iv_text.
    gs_fieldcat-scrtext_m = iv_text.
    gs_fieldcat-reptext   = iv_text.
    gs_fieldcat-col_pos   = iv_colpos.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.

"=== helper: thêm cột kỹ thuật nếu chưa có (ẩn đi)
FORM add_fc_tech_if_missing USING iv_field  TYPE lvc_fname
                                   iv_colpos TYPE i
                                   iv_hidden TYPE abap_bool.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-col_pos   = iv_colpos.
    IF iv_hidden = abap_true.
      gs_fieldcat-no_out = abap_true.
      gs_fieldcat-tech   = abap_true.
    ENDIF.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.



*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_ALV
*&---------------------------------------------------------------------*

CLASS lcl_alv_handler DEFINITION.
  PUBLIC SECTION.
    METHODS handle_toolbar
      FOR EVENT toolbar OF cl_gui_alv_grid
      IMPORTING e_object e_interactive.

    METHODS handle_user_command
      FOR EVENT user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm.

    METHODS handle_onf4
      FOR EVENT onf4 OF cl_gui_alv_grid
      IMPORTING e_fieldname es_row_no er_event_data e_display.

    METHODS handle_data_changed
      FOR EVENT data_changed OF cl_gui_alv_grid
      IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.
ENDCLASS.

CLASS lcl_alv_handler IMPLEMENTATION.

  METHOD handle_toolbar.
    DATA: lt_toolbar     TYPE STANDARD TABLE OF stb_button,
          ls_btn         TYPE stb_button,
          lv_can_create  TYPE abap_bool,
          lv_can_change  TYPE abap_bool,
          lv_can_delete  TYPE abap_bool,
          lv_can_display TYPE abap_bool,
          lv_drop        TYPE abap_bool,
          ix             TYPE sy-tabix.

    FIELD-SYMBOLS: <b>  TYPE stb_button,
                   <fc> LIKE LINE OF gt_tb_excl.

    PERFORM has_actvt USING '01' CHANGING lv_can_create.
    PERFORM has_actvt USING '02' CHANGING lv_can_change.
    PERFORM has_actvt USING '06' CHANGING lv_can_delete.
    PERFORM has_actvt USING '03' CHANGING lv_can_display.

    e_interactive = space.

    " Gỡ nút chuẩn (dựa trên gt_tb_excl đã build ở PBO)
    lt_toolbar = e_object->mt_toolbar[].

    LOOP AT lt_toolbar ASSIGNING <b>.
      ix = sy-tabix.
      lv_drop = abap_false.

      LOOP AT gt_tb_excl ASSIGNING <fc>.
        IF <b>-function = <fc>.
          lv_drop = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      " Fallback
      IF lv_drop = abap_false AND (
       <b>-function = 'INSR' OR
       <b>-function = 'APND' OR
       <b>-function = 'DUPL' OR
       <b>-function = 'DELE' OR
       <b>-function = 'COPY' OR
       <b>-function = 'PASTE' OR
       <b>-function = 'SCUT' OR
       <b>-function = 'SALL' OR
       <b>-function = 'PICK'
     ).
        lv_drop = abap_true.
      ENDIF.

      IF lv_drop = abap_true.
        DELETE lt_toolbar INDEX ix.
      ENDIF.
    ENDLOOP.

    "=== 2) Thêm các nút custom (EVTG, SAVE, ADD, DELE, UPLD, XLSX, TMPL, HIST)
    "---- EVTG
    CLEAR ls_btn.
    ls_btn-function = 'EVTG'.
    IF gv_edit_md = abap_true.
      ls_btn-icon      = icon_display.
      ls_btn-text      = 'View'.
      ls_btn-quickinfo = 'Switch to view mode'.
      ls_btn-disabled  = space.
    ELSE.
      ls_btn-icon      = icon_change.
      ls_btn-text      = 'Edit'.
      ls_btn-quickinfo = 'Switch to edit mode'.
      ls_btn-disabled  = COND #( WHEN lv_can_change = abap_true THEN space ELSE 'X' ).
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "---- SAVE
    CLEAR ls_btn.
    ls_btn-function   = 'SAVE'.
    ls_btn-icon       = icon_system_save.
    ls_btn-text       = 'Save'.
    ls_btn-quickinfo  = 'Save changes'.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_change = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- ADD
    CLEAR ls_btn.
    ls_btn-function   = 'ADD'.
    ls_btn-icon       = icon_create.
    ls_btn-text       = 'Add'.
    ls_btn-quickinfo  = 'Add new entry'.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_create = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- DELE (nút custom của bạn, KHÁC mã chuẩn mc_fc_loc_delete_row)
    CLEAR ls_btn.
    ls_btn-function   = 'DELE'.
    ls_btn-icon       = icon_delete.
    ls_btn-text       = 'Delete'.
    ls_btn-quickinfo  = 'Delete selected entry'.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_delete = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- UPLD
    CLEAR ls_btn.
    ls_btn-function   = 'UPLD'.
    ls_btn-icon       = icon_import.
    ls_btn-text       = 'Upload Data'.
    ls_btn-quickinfo  = 'Upload from file'.
    ls_btn-disabled   = COND #( WHEN gv_edit_md = abap_true AND lv_can_change = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- XLSX
    CLEAR ls_btn.
    ls_btn-function   = 'XLSX'.
    ls_btn-icon       = icon_export.
    ls_btn-text       = 'Export Data'.
    ls_btn-quickinfo  = 'Export to Excel'.
    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- TMPL
    CLEAR ls_btn.
    ls_btn-function   = 'TMPL'.
    ls_btn-icon       = icon_export.
    ls_btn-text       = 'Export Template'.
    ls_btn-quickinfo  = 'Download template'.
    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    "---- HIST
    CLEAR ls_btn.
    ls_btn-function   = 'HIST'.
    ls_btn-icon       = icon_history.
    ls_btn-text       = 'History'.
    ls_btn-quickinfo  = 'View version history & rollback'.
    ls_btn-disabled   = COND #( WHEN lv_can_display = abap_true THEN space ELSE 'X' ).
    APPEND ls_btn TO lt_toolbar.

    e_object->mt_toolbar[] = lt_toolbar.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA: ls_stbl               TYPE lvc_s_stbl,
          lv_has_change         TYPE abap_bool,
          lv_answer             TYPE c,
          lv_new_incomplete     TYPE abap_bool,
          lv_other_changes      TYPE abap_bool,
          lv_ans_conf           TYPE c,
          lv_question           TYPE c LENGTH 70,
          lv_msg                TYPE c LENGTH 200,
          lv_err                TYPE c LENGTH 200,
          lv_skip_unsaved_check TYPE abap_bool VALUE abap_false,
          lv_ok                 TYPE abap_bool.


    " NEW: biết có lưu/huỷ thay đổi do popup hay không
    DATA: lv_saved_by_prompt     TYPE abap_bool VALUE abap_false,
          lv_discarded_by_prompt TYPE abap_bool VALUE abap_false.

    " --- Local vars for EVTG pre-check (no inline) ---
    DATA: lv_dup           TYPE abap_bool,
          lv_dup_msg       TYPE string,             " nhận message string từ FORM
          lv_off_idx       TYPE i,
          lv_key_for_focus TYPE dd03l-fieldname.

    FIELD-SYMBOLS:
      <fs_tab>    TYPE STANDARD TABLE,
      <fs_row>    TYPE any,
      <fs_newrec> TYPE any,
      <fs_erdat>  TYPE any,  <fs_ertim> TYPE any,  <fs_ernam> TYPE any.

    CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

    " Gom dữ liệu đang edit về itab trước
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
    ENDIF.


    IF e_ucomm = 'DELE' OR e_ucomm = 'ADD'.
      lv_skip_unsaved_check = abap_true.
    ENDIF.

    "=== Kiểm tra thay đổi chưa lưu chi tiết (popup hướng dẫn) ===
    DATA: lv_new_incomplete_cnt TYPE i,
          lv_new_complete_cnt   TYPE i,
          lv_edit_existing_cnt  TYPE i,
          lv_ans                TYPE c,
          lv_text               TYPE c LENGTH 200.

    PERFORM analyze_change_state_detailed
      CHANGING lv_has_change lv_new_incomplete_cnt lv_new_complete_cnt lv_edit_existing_cnt.

    IF e_ucomm <> 'SAVE'
       AND lv_has_change = abap_true
       AND lv_skip_unsaved_check <> abap_true.

      IF     lv_new_incomplete_cnt > 0
         AND lv_new_complete_cnt   = 0
         AND lv_edit_existing_cnt  = 0.

*        lv_text = |Có | && lv_new_incomplete_cnt &&
*                  | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và tiếp tục?|.
        lv_text = TEXT-009.
        REPLACE '&1' IN lv_text WITH CONV string( lv_new_incomplete_cnt ).
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-010
            text_question         = lv_text
            text_button_1         = TEXT-011
            text_button_2         = TEXT-012
            default_button        = '2'
            display_cancel_button = space
          IMPORTING
            answer                = lv_ans.

        IF lv_ans = '1'.
          PERFORM purge_incomplete_newrecs.
          gv_add_mode = abap_false.
          PERFORM apply_editability_and_push.
        ELSEIF lv_ans = '2'.
          PERFORM focus_key_on_newrec.
          RETURN.
        ENDIF.

      ELSEIF lv_new_complete_cnt > 0
         AND lv_edit_existing_cnt = 0
         AND lv_new_incomplete_cnt = 0.

*        lv_text = |Có | && lv_new_complete_cnt &&
*                  | dòng mới CHƯA LƯU. Lưu trước khi tiếp tục?|.
        lv_text = TEXT-013.
        REPLACE '&1' IN lv_text WITH CONV string( lv_new_complete_cnt ).

        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-014
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.

            " ⬇ SAU KHI SAVE: NẾU VẪN CÒN NEWREC HOẶC CÒN 1 DÒNG LỖI
            " THÌ ĐỪNG CHO CHẠY TIẾP ACTION CHÍNH (EVTG, v.v.)
            " CỨ Ở LẠI EDIT
            DATA(lv_has_after)         = abap_false.
            DATA(lv_new_inc_after)     = 0.
            DATA(lv_new_comp_after)    = 0.
            DATA(lv_edit_exist_after)  = 0.

            PERFORM analyze_change_state_detailed
              CHANGING lv_has_after
                       lv_new_inc_after
                       lv_new_comp_after
                       lv_edit_exist_after.

            IF gv_edit_md = abap_true OR lv_has_after = abap_true.
              " nghĩa là còn gì đó chưa xong → ở lại
              RETURN.
            ELSE.
              " Lưu OK & không còn gì → cho phép chạy tiếp action
              lv_saved_by_prompt = abap_true.
            ENDIF.

          WHEN 'A'.
            RETURN.
          WHEN '2'.
            " KHÔNG LƯU: bỏ toàn bộ thay đổi tạm (xóa NEWREC) và về View
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.


      ELSEIF lv_edit_existing_cnt > 0
         AND lv_new_incomplete_cnt = 0
         AND lv_new_complete_cnt   = 0.

*        lv_text = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi tiếp tục?'.
        lv_text = TEXT-017.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-018
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.
            IF gv_edit_md = abap_true.
              RETURN.
            ELSE.
              lv_saved_by_prompt = abap_true.
            ENDIF.
          WHEN 'A'.
            RETURN.
          WHEN '2'.
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.

      ELSE.
*        lv_text = |Có thay đổi chưa lưu: | &&
*                  lv_new_incomplete_cnt && ' NEWREC thiếu khóa, ' &&
*                  lv_new_complete_cnt   && ' NEWREC đủ khóa, ' &&
*                  lv_edit_existing_cnt  && ' thay đổi dòng cũ. Lưu trước khi tiếp tục?'.
        lv_text = TEXT-019.

        REPLACE '&1' IN lv_text WITH CONV string( lv_new_incomplete_cnt ).
        REPLACE '&2' IN lv_text WITH CONV string( lv_new_complete_cnt ).
        REPLACE '&3' IN lv_text WITH CONV string( lv_edit_existing_cnt ).

        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = TEXT-018
            text_question         = lv_text
            text_button_1         = TEXT-015
            text_button_2         = TEXT-016
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'.
            PERFORM on_save.
            IF gv_edit_md = abap_true.
              RETURN.
            ELSE.
              lv_saved_by_prompt = abap_true.
            ENDIF.
          WHEN 'A'.
            RETURN.
          WHEN '2'.
            PERFORM discard_unsaved_changes.
            lv_discarded_by_prompt = abap_true.
        ENDCASE.
      ENDIF.

    ENDIF.


    "=== Xử lý các nút ===
    CASE e_ucomm.

      WHEN 'EVTG'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-020 TYPE 'S' DISPLAY LIKE 'E'.

          RETURN.
        ENDIF.

        " Nếu vừa LƯU hoặc vừa DISCARD từ popup -> đã ở đúng mode rồi
        IF lv_saved_by_prompt = abap_true OR lv_discarded_by_prompt = abap_true.
          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.
          RETURN.
        ENDIF.

        " Nếu đang Edit/Add và CHƯA lưu/huỷ từ popup → pre-check duplicate NEWREC
        IF ( gv_edit_md = abap_true OR gv_add_mode = abap_true ).
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
          ENDIF.

          CLEAR: lv_dup, lv_dup_msg, lv_off_idx.
          PERFORM check_newrec_duplicate_all USING p_tab
                 CHANGING lv_dup lv_dup_msg lv_off_idx.

          IF lv_dup = abap_true.
            lv_msg = lv_dup_msg.
            MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.

            IF g_alv_grid IS BOUND AND lv_off_idx > 0.
              DATA: ls_row TYPE lvc_s_row, ls_col TYPE lvc_s_col.
              ls_row-index = lv_off_idx.

              CLEAR lv_key_for_focus.
              READ TABLE gt_key_fields INDEX 1 INTO lv_key_for_focus.
              IF sy-subrc = 0.
                ls_col-fieldname = lv_key_for_focus.
              ENDIF.

              TRY.
                  g_alv_grid->set_current_cell_via_id( is_row_id = ls_row is_column_id = ls_col ).
                  g_alv_grid->set_scroll_info_via_id( is_row_info = ls_row is_col_info = ls_col ).
                CATCH cx_root.
              ENDTRY.
            ENDIF.
            RETURN. " CHẶN chuyển View
          ENDIF.
        ENDIF.

        " Toggle View/Edit như cũ
        IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
          gv_edit_md      = abap_false.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'D'.
          TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
        ELSE.
          gv_edit_md      = abap_true.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'E'.
          TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
        ENDIF.

        PERFORM apply_editability_and_push.
        IF g_alv_grid IS BOUND.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'ADD'.
        PERFORM has_actvt USING '01' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-020 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ASSIGN gr_data->* TO <fs_tab>.
        IF <fs_tab> IS ASSIGNED.
          APPEND INITIAL LINE TO <fs_tab> ASSIGNING <fs_row>.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <fs_row> TO <fs_newrec>.
          IF sy-subrc = 0. <fs_newrec> = 'X'. ENDIF.

          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <fs_row> TO <fs_erdat>.
          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <fs_row> TO <fs_ertim>.
          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <fs_row> TO <fs_ernam>.
          DATA: lv_user_tzone TYPE tznzone,
                lv_local_date TYPE d,
                lv_local_time TYPE t,
                ts_utc        TYPE timestamp.

          lv_user_tzone = sy-zonlo.
          IF lv_user_tzone IS INITIAL.
            TRY.
                lv_user_tzone = cl_abap_context_info=>get_user_time_zone( ).
              CATCH cx_abap_context_info_error.
                lv_user_tzone = 'UTC'.
            ENDTRY.
          ENDIF.

          GET TIME STAMP FIELD ts_utc.
          CONVERT TIME STAMP ts_utc TIME ZONE lv_user_tzone
                  INTO DATE lv_local_date TIME lv_local_time.

          IF <fs_erdat> IS ASSIGNED. <fs_erdat> = lv_local_date. ENDIF.
          IF <fs_ertim> IS ASSIGNED. <fs_ertim> = lv_local_time. ENDIF.
          IF <fs_ernam> IS ASSIGNED. <fs_ernam> = sy-uname. ENDIF.

          gv_add_mode     = abap_true.
          gv_edit_md      = abap_true.
          gv_toolbar_mode = 'E'.

          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
            g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

          PERFORM ensure_keys USING p_tab.
          READ TABLE gt_key_fields INDEX 1 INTO lv_key_for_focus.
          IF sy-subrc = 0 AND g_alv_grid IS BOUND.
            DATA ls_row_id TYPE lvc_s_row.
            DATA ls_col_id TYPE lvc_s_col.
            ls_row_id-index     = lines( <fs_tab> ).
            ls_col_id-fieldname = lv_key_for_focus.
            TRY.
                g_alv_grid->set_current_cell_via_id(
                  EXPORTING is_row_id    = ls_row_id
                            is_column_id = ls_col_id ).
                g_alv_grid->set_scroll_info_via_id(
                  EXPORTING is_row_info = ls_row_id
                            is_col_info = ls_col_id ).
              CATCH cx_root.
            ENDTRY.
          ENDIF.
        ENDIF.

      WHEN 'SAVE'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Change (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-021 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        PERFORM on_save.

        " ⬇️ SAU KHI SAVE BẰNG NÚT: KIỂM TRA LẠI COI CÒN NEWREC/LỖI KHÔNG
        DATA: lv_has_after2        TYPE abap_bool,
              lv_new_inc_after2    TYPE i,
              lv_new_comp_after2   TYPE i,
              lv_edit_exist_after2 TYPE i.

        PERFORM analyze_change_state_detailed
          CHANGING lv_has_after2
                   lv_new_inc_after2
                   lv_new_comp_after2
                   lv_edit_exist_after2.

        " Nếu còn cái gì chưa sạch → Ở LẠI EDIT, ĐỪNG THOÁT
        IF gv_edit_md = abap_true OR lv_has_after2 = abap_true.
          " ở lại màn hình, không RETURN sớm, để ALV refresh ở dưới
        ELSE.
          " không còn gì -> có thể RETURN luôn ở đây cũng được
        ENDIF.

        RETURN.


      WHEN 'DELE'.
        PERFORM has_actvt USING '06' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Delete (ACTVT=06).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-022 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        DATA: lt_sel_idx TYPE lvc_t_row,
              ls_cur_row TYPE lvc_s_row,
              ls_cur_col TYPE lvc_s_col,
              lv_cnt     TYPE i.
        CLEAR lt_sel_idx.

        IF g_alv_grid IS BOUND.
          TRY. g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ). CATCH cx_root. ENDTRY.
        ENDIF.
        IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
          TRY.
              g_alv_grid->get_current_cell(
                IMPORTING es_row_id = ls_cur_row
                          es_col_id = ls_cur_col ).
            CATCH cx_root.
          ENDTRY.
          IF ls_cur_row-index > 0.
            APPEND VALUE lvc_s_row( index = ls_cur_row-index ) TO lt_sel_idx.
          ENDIF.
        ENDIF.

        lv_cnt = lines( lt_sel_idx ).
        IF lv_cnt = 0.
*          MESSAGE 'Vui lòng chọn dòng (hoặc đặt con trỏ) để xóa.' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-023 TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        CLEAR gv_del_newrec_only.
        CLEAR: lv_new_incomplete, lv_other_changes.
        PERFORM is_newrec_target_for_delete CHANGING gv_del_newrec_only.
        PERFORM analyze_change_state       CHANGING lv_new_incomplete lv_other_changes.

        DATA lv_need_confirm TYPE abap_bool VALUE abap_false.
        CLEAR lv_question.

        IF gv_del_newrec_only = abap_true.
          lv_need_confirm = abap_false.
        ELSE.
          lv_need_confirm = abap_true.
*          lv_question     = |Bạn có chắc muốn xóa { lv_cnt } dòng đã chọn?|.
          lv_question = TEXT-024.
          REPLACE '&1' IN lv_question WITH CONV string( lv_cnt ).

        ENDIF.

        IF lv_need_confirm = abap_true.
          CLEAR lv_ans_conf.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = TEXT-025
              text_question         = lv_question(70)
              text_button_1         = TEXT-026
              text_button_2         = TEXT-027
              default_button        = '2'
              display_cancel_button = space
            IMPORTING
              answer                = lv_ans_conf.
          IF lv_ans_conf <> '1'.
            RETURN.
          ENDIF.
        ENDIF.

        CLEAR: lv_msg, lv_err.
        PERFORM delete_selected USING p_tab CHANGING lv_msg lv_err.
        IF lv_err IS INITIAL.
*          MESSAGE |{ COND string( WHEN lv_msg IS INITIAL THEN 'Đã xóa và ghi audit.' ELSE lv_msg ) }| TYPE 'S'.
          DATA(lv_final_msg) = COND string(
          WHEN lv_msg IS INITIAL THEN TEXT-028
          ELSE lv_msg
          ).

          MESSAGE lv_final_msg TYPE 'S'.

        ELSE.
          MESSAGE |{ lv_err }| TYPE 'S' DISPLAY LIKE 'E'.
        ENDIF.

        IF g_alv_grid IS BOUND.
          PERFORM ensure_celltab_component CHANGING gr_data.
          PERFORM apply_editability_and_push.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'UPLD'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Upload (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-029 TYPE'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        PERFORM upload_data_strict_match.

      WHEN 'XLSX' OR 'TMPL' OR 'HIST'.
        PERFORM has_actvt USING '03' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
*          MESSAGE 'Bạn không có quyền Display (ACTVT=03).' TYPE 'S' DISPLAY LIKE 'E'.
          MESSAGE TEXT-030 TYPE'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        CASE e_ucomm.
          WHEN 'XLSX'.
            FIELD-SYMBOLS: <lt_all>      TYPE STANDARD TABLE,
                           <lt_filtered> TYPE STANDARD TABLE,
                           <ls_any>      TYPE any,
                           <newrec_flag> TYPE any.

            DATA: lo_typedesc TYPE REF TO cl_abap_typedescr,
                  lo_tabdescr TYPE REF TO cl_abap_tabledescr,
                  lr_filtered TYPE REF TO data.

            IF g_alv_grid IS BOUND.
              TRY.
                  g_alv_grid->check_changed_data( ).
                CATCH cx_root.
              ENDTRY.
            ENDIF.

            ASSIGN gr_data->* TO <lt_all>.
            IF <lt_all> IS ASSIGNED.
              lo_typedesc = cl_abap_tabledescr=>describe_by_data_ref( REF #( <lt_all> ) ).
              lo_tabdescr ?= lo_typedesc.
              CREATE DATA lr_filtered TYPE HANDLE lo_tabdescr.
              ASSIGN lr_filtered->* TO <lt_filtered>.

              LOOP AT <lt_all> ASSIGNING <ls_any>.
                ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_any> TO <newrec_flag>.
                IF sy-subrc = 0 AND <newrec_flag> = 'X'.
                  CONTINUE.
                ENDIF.
                APPEND <ls_any> TO <lt_filtered>.
              ENDLOOP.

              IF <lt_filtered> IS INITIAL.
*                MESSAGE 'Không có dữ liệu đã lưu để export.' TYPE 'S' DISPLAY LIKE 'E'.
                MESSAGE TEXT-031 TYPE'S' DISPLAY LIKE 'E'.
                RETURN.
              ENDIF.

*              MESSAGE 'Các dòng chưa lưu sẽ không được export.' TYPE 'S'.
              MESSAGE TEXT-032 TYPE'S' DISPLAY LIKE 'E'.
              PERFORM download_excel_xlsx USING lr_filtered.
            ELSE.
*              MESSAGE 'Không có dữ liệu để export.' TYPE 'S' DISPLAY LIKE 'E'.
              MESSAGE TEXT-033 TYPE'S' DISPLAY LIKE 'E'.
            ENDIF.

          WHEN 'TMPL'. PERFORM download_template_xlsx.
          WHEN 'HIST'. PERFORM show_audit_history.
        ENDCASE.

    ENDCASE.

    cl_gui_cfw=>flush( ).
  ENDMETHOD.





  METHOD handle_onf4.
    er_event_data->m_event_handled = abap_true.
    DATA: lt_ret   TYPE STANDARD TABLE OF ddshretval,
          ls_ret   TYPE ddshretval,
          lv_value TYPE string,
          lv_done  TYPE abap_bool.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.
    " 1) DDIC search help (nếu có)
    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname    = p_tab
        fieldname  = e_fieldname
        display    = 'F'
      TABLES
        return_tab = lt_ret
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc = 0.
      " ĐÃ gọi được SH chuẩn → không fallback nữa
      IF lt_ret IS NOT INITIAL.
        READ TABLE lt_ret INDEX 1 INTO ls_ret.
        IF sy-subrc = 0.
          lv_value = ls_ret-fieldval.
          lv_done  = abap_true.
        ENDIF.
      ELSE.
        " Người dùng Cancel/không chọn → kết thúc, KHÔNG mở popup fallback
        er_event_data->m_event_handled = 'X'.
        RETURN.
      ENDIF.
    ENDIF.

    " 2) Fallback dynamic từ dữ liệu hiện có
    IF lv_done IS INITIAL.
      DATA lv_current TYPE string.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, đổi internal -> external để dùng làm tiền tố filter
            DATA(lo_d1) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d1->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_current ).
                CATCH cx_abap_datfm.
                  lv_current = <cell>. " fallback
              ENDTRY.
            ELSE.
              lv_current = <cell>.
            ENDIF.
            CONDENSE lv_current.
          ENDIF.
        ENDIF.
      ENDIF.

      TYPES: BEGIN OF ty_val, fieldval TYPE char80, END OF ty_val.
      DATA: lt_vals TYPE STANDARD TABLE OF ty_val WITH DEFAULT KEY,
            ls_val  TYPE ty_val,
            lv_s    TYPE string.

      IF <outtab> IS ASSIGNED.
        LOOP AT <outtab> ASSIGNING <row>.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, hiển thị external trong popup
            DATA(lo_d2) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d2->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_s ).
                CATCH cx_abap_datfm.
                  lv_s = <cell>.
              ENDTRY.
            ELSE.
              lv_s = <cell>.
            ENDIF.

            CONDENSE lv_s.
            IF lv_s IS NOT INITIAL AND ( lv_current IS INITIAL OR lv_s CP lv_current && '*' ).
              ls_val-fieldval = lv_s.
              COLLECT ls_val INTO lt_vals.  " distinct
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.


      IF lt_vals IS NOT INITIAL.
        DATA: lt_field_tab TYPE TABLE OF dfies,
              ls_field_tab TYPE dfies,
              lv_coltext   TYPE string.

        " Lấy caption từ fieldcatalog
        lv_coltext = e_fieldname.
        LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>) WHERE fieldname = e_fieldname.
          IF <fc>-coltext IS NOT INITIAL.
            lv_coltext = <fc>-coltext.
          ELSEIF <fc>-scrtext_m IS NOT INITIAL.
            lv_coltext = <fc>-scrtext_m.
          ENDIF.
          EXIT.
        ENDLOOP.

        CLEAR ls_field_tab.
        ls_field_tab-fieldname = 'FIELDVAL'.
        ls_field_tab-datatype  = 'CHAR'.
        ls_field_tab-inttype   = 'C'.
        ls_field_tab-intlen    = 80.
        ls_field_tab-leng      = 80.
        ls_field_tab-outputlen = 80.
        ls_field_tab-decimals  = 0.
        ls_field_tab-reffield  = ''.
        ls_field_tab-reftable  = ''.
        ls_field_tab-reptext   = lv_coltext.
        ls_field_tab-scrtext_l = lv_coltext.
        ls_field_tab-scrtext_m = lv_coltext.
        ls_field_tab-scrtext_s = lv_coltext.
        APPEND ls_field_tab TO lt_field_tab.

        CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
          EXPORTING
            retfield   = 'FIELDVAL'
            value_org  = 'S'
            display    = 'F'
          TABLES
            value_tab  = lt_vals
            field_tab  = lt_field_tab
            return_tab = lt_ret
          EXCEPTIONS
            OTHERS     = 1.

        IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
          READ TABLE lt_ret INDEX 1 INTO ls_ret.
          IF sy-subrc = 0.
            lv_value = ls_ret-fieldval.
            lv_done = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    " 3) Gán lại vào ô hiện tại và refresh
    IF lv_done = abap_true.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            DATA(lo_desc) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).

            IF lo_desc->type_kind = cl_abap_typedescr=>typekind_date.
              DATA lv_date_int TYPE d.
              TRY.
                  cl_abap_datfm=>conv_date_ext_to_int(
                    EXPORTING im_datext = lv_value
                    IMPORTING ex_datint = lv_date_int ).
                  <cell> = lv_date_int.
                CATCH cx_abap_datfm .
                  TRY. <cell> = lv_value. CATCH cx_root. ENDTRY.
              ENDTRY.
            ELSE.
              <cell> = lv_value.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      TRY.
          g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        CATCH cx_root.
      ENDTRY.
      cl_gui_cfw=>flush( ).
      er_event_data->m_event_handled = 'X'.
    ENDIF.
  ENDMETHOD.

  METHOD handle_data_changed.
    DATA: lt_mod     TYPE lvc_t_modi,
          ls_mod     TYPE lvc_s_modi,
          lt_dc_rows TYPE lvc_t_roid,    " ALV báo dòng bị xóa
          ls_dc_row  TYPE lvc_s_roid,
          ls_stbl    TYPE lvc_s_stbl,
          lv_msg_dc  TYPE string,  " đổi sang C(200) cho khớp FORM
          lv_err_dc  TYPE string.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.

    ASSIGN gr_data->* TO <outtab>.
    IF <outtab> IS NOT ASSIGNED.
      RETURN.
    ENDIF.


    lt_mod = er_data_changed->mt_mod_cells.


    " Danh sách cột audit cần khóa tuyệt đối
    DATA: lt_audit TYPE TABLE OF lvc_fname WITH DEFAULT KEY.
    APPEND 'ERDAT' TO lt_audit.
    APPEND 'ERTIM' TO lt_audit.
    APPEND 'ERNAM' TO lt_audit.
    APPEND 'AEDAT' TO lt_audit.
    APPEND 'AETIM' TO lt_audit.
    APPEND 'AENAM' TO lt_audit.

    " Chỉ set dirty khi thật sự có thay đổi trên dòng CŨ
    DATA(lv_nonnewrec_changed) = abap_false.

    LOOP AT lt_mod INTO ls_mod.

      " --- 0) Chặn tuyệt đối: AUDIT (kể cả paste)
      READ TABLE lt_audit WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).
*            er_data_changed->add_protocol_entry(
*              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
*              i_fieldname = ls_mod-fieldname
*              i_row_id   = ls_mod-row_id
*              i_msgv1    = |Field { ls_mod-fieldname } is not editable (audit)| ).DATA(lv_msg) = text-015.
            REPLACE '&1' IN lv_msg WITH ls_mod-fieldname.

            er_data_changed->add_protocol_entry(
              i_msgid     = '00'
              i_msgno     = '398'
              i_msgty     = 'E'
              i_fieldname = ls_mod-fieldname
              i_row_id    = ls_mod-row_id
              i_msgv1     = lv_msg
            ).

          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      " --- 1) KEY: chỉ cho phép khi đang Add và dòng NEWREC = 'X'
      READ TABLE gt_key_fields WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. " Là KEY
        DATA(lv_block_key) = abap_true.
        IF gv_add_mode = abap_true AND ls_mod-row_id > 0.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0 AND <cell> = 'X'.
              lv_block_key = abap_false.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_block_key = abap_true.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0.
              er_data_changed->modify_cell(
                EXPORTING i_row_id    = ls_mod-row_id
                          i_fieldname = ls_mod-fieldname
                          i_value     = <cell> ).
              er_data_changed->add_protocol_entry(
                i_msgid = '00' i_msgno = '398' i_msgty = 'E'
                i_fieldname = ls_mod-fieldname
                i_row_id   = ls_mod-row_id
                i_msgv1    = |Field { ls_mod-fieldname } is not editable (key)| ).
            ENDIF.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      " --- 2) Non-key: chỉ cho phép khi đang Edit
      IF gv_edit_md <> abap_true.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).
            er_data_changed->add_protocol_entry(
              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
              i_fieldname = ls_mod-fieldname
              i_row_id   = ls_mod-row_id
              i_msgv1    = |Field { ls_mod-fieldname } is read-only in View mode| ).
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      " --- 3) Đánh dấu dirty CHỈ khi không phải dòng NEWREC
      DATA(lv_is_newrec) = abap_false.
      IF ls_mod-row_id > 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> = 'X'.
            lv_is_newrec = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.

      " Chỉ set cờ khi GIÁ TRỊ THỰC SỰ THAY ĐỔI và không phải NEWREC
      IF lv_is_newrec = abap_false.
        DATA(lv_old_value) = VALUE string( ).
        DATA(lv_changed)   = abap_false.

        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            " Chuẩn hóa giá trị cũ về chuỗi để so sánh an toàn
            lv_old_value = |{ <cell> }|.
            " Với DATS/TIMS hoặc số, ALV đưa ls_mod-value là text → so sánh chuỗi
            IF lv_old_value <> ls_mod-value.
              lv_changed = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_changed = abap_true.
          " Ghi nhận dòng CŨ đã chỉnh (unique theo khóa)
          DATA(lv_keyhash) = VALUE string( ).
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            PERFORM make_row_key USING <row> CHANGING lv_keyhash.
            IF lv_keyhash IS NOT INITIAL.
              INSERT lv_keyhash INTO TABLE gt_changed_existing_keys.
            ENDIF.
          ENDIF.

          lv_nonnewrec_changed = abap_true.
        ENDIF.
      ENDIF.

    ENDLOOP.

    " Cập nhật lại gv_dirty theo đúng bản chất thay đổi dòng cũ
    gv_dirty = lv_nonnewrec_changed.

    " === 4) Xử lý các dòng được chèn do paste (ALV báo qua mt_inserted_rows) ===
    DATA lt_ins TYPE lvc_t_roid.
    lt_ins = er_data_changed->mt_inserted_rows.

    IF lt_ins IS NOT INITIAL.
      FIELD-SYMBOLS: <celltab> TYPE lvc_t_styl.
      LOOP AT lt_ins INTO DATA(ls_ins).
        " bảo đảm có record tại row_id
        READ TABLE <outtab> INDEX ls_ins-row_id ASSIGNING <row>.
        IF sy-subrc <> 0.
          DATA(lv_need) = ls_ins-row_id - lines( <outtab> ).
          DO lv_need TIMES.
            APPEND INITIAL LINE TO <outtab>.
          ENDDO.
          READ TABLE <outtab> INDEX ls_ins-row_id ASSIGNING <row>.
        ENDIF.

        IF <row> IS ASSIGNED.
          " gắn NEWREC = 'X'
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0. <cell> = 'X'. ENDIF.

          " xoá trắng audit
          FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                         <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any.
          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <row> TO <erdat>.
          IF sy-subrc = 0. CLEAR <erdat>. ENDIF.
          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <row> TO <ertim>.
          IF sy-subrc = 0. CLEAR <ertim>. ENDIF.
          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <row> TO <ernam>.
          IF sy-subrc = 0. CLEAR <ernam>. ENDIF.
          ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <row> TO <aedat>.
          IF sy-subrc = 0. CLEAR <aedat>. ENDIF.
          ASSIGN COMPONENT 'AETIM' OF STRUCTURE <row> TO <aetim>.
          IF sy-subrc = 0. CLEAR <aetim>. ENDIF.
          ASSIGN COMPONENT 'AENAM' OF STRUCTURE <row> TO <aenam>.
          IF sy-subrc = 0. CLEAR <aenam>. ENDIF.

          " clear CELLTAB để áp lại style sạch
          ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <row> TO <celltab>.
          IF sy-subrc = 0. CLEAR <celltab>. ENDIF.
        ENDIF.
      ENDLOOP.

      " bật add mode & áp style cho toàn bộ dòng NEWREC vừa chèn
      gv_add_mode = abap_true.
      PERFORM apply_editability_and_push.

      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      ENDIF.
    ENDIF.
  ENDMETHOD.



ENDCLASS.


*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
  SET PF-STATUS 'MAIN100'.
  SET TITLEBAR 'T100'.
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PBO_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE pbo_0100 OUTPUT.
  PERFORM check_authorization.
  PERFORM ensure_keys USING p_tab.
  FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <fs_table>.

  IF <fs_table> IS ASSIGNED AND <fs_table> IS NOT INITIAL.
    PERFORM merge_audit_log USING p_tab CHANGING <fs_table>.
  ENDIF.

  IF <fs_table> IS NOT ASSIGNED.
    MESSAGE 'Không thể gán dữ liệu ALV.' TYPE 'S' DISPLAY LIKE 'E'.
    LEAVE TO SCREEN 0.
    RETURN.
  ENDIF.

  " Nếu bảng rỗng thì vẫn cho hiển thị ALV (không LEAVE)
  IF <fs_table> IS INITIAL.
    MESSAGE 'Không có dữ liệu để hiển thị, mở ALV trống.' TYPE 'S' DISPLAY LIKE 'I'.
  ENDIF.

  TRY.
      "=== Chuẩn bị Fieldcatalog ===
      IF gt_fieldcat IS INITIAL.
        PERFORM build_fieldcat_all.
      ENDIF.
      PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.
      PERFORM enable_f4_in_fieldcat. " Bật cờ F4 cho tất cả cột

      "=== Tạo container & grid nếu lần đầu ===
      IF g_container IS INITIAL OR g_alv_grid IS INITIAL.
        CREATE OBJECT g_container EXPORTING container_name = gc_cc_alv.
        CREATE OBJECT g_alv_grid EXPORTING i_parent = g_container.
        g_alv_grid->set_toolbar_interactive( ).

        " Gắn các handler
        IF g_handler IS INITIAL.
          CREATE OBJECT g_handler.
          SET HANDLER g_handler->handle_toolbar FOR g_alv_grid.
          SET HANDLER g_handler->handle_user_command FOR g_alv_grid.
          SET HANDLER g_handler->handle_onf4 FOR g_alv_grid.
          SET HANDLER g_handler->handle_data_changed FOR g_alv_grid.
        ENDIF.

        " Layout
        gs_layout = VALUE #( edit = abap_true zebra = abap_true
        cwidth_opt = abap_true stylefname = 'CELLTAB' ).

        PERFORM ensure_celltab_component CHANGING gr_data.
        ASSIGN gr_data->* TO <fs_table>.
        PERFORM build_excluding_toolbar.

        g_alv_grid->set_table_for_first_display(
          EXPORTING
            is_layout            = gs_layout
            it_toolbar_excluding = gt_tb_excl
          CHANGING
            it_outtab            = <fs_table>
            it_fieldcatalog      = gt_fieldcat ).
      ELSE.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
      ENDIF.
      PERFORM apply_editability_and_push.
      PERFORM register_f4_all.
      TRY.
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_enter ).
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_modified ).
        CATCH cx_root.
      ENDTRY.

      "=== Bật/tắt input cho grid ===
      g_alv_grid->set_ready_for_input(
      COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).

    CATCH cx_root.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PAI_0100 INPUT
*&---------------------------------------------------------------------*
MODULE pai_0100 INPUT.
  g_okcode = sy-ucomm.
  CLEAR sy-ucomm.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  TRY.

      CASE g_okcode.

          "==================================================================
        WHEN 'BACK' OR 'CANC' OR 'EXIT'.
          "==================================================================

          " Đẩy giá trị đang nhập về itab trước khi so sánh
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Phân tích thay đổi chi tiết
          DATA: lv_has_change_exit         TYPE abap_bool,
                lv_new_incomplete_cnt_exit TYPE i,
                lv_new_complete_cnt_exit   TYPE i,
                lv_edit_existing_cnt_exit  TYPE i,
                lv_ans_exit                TYPE c,
                lv_text_exit               TYPE c LENGTH 200.

          CLEAR: lv_has_change_exit,
                 lv_new_incomplete_cnt_exit,
                 lv_new_complete_cnt_exit,
                 lv_edit_existing_cnt_exit.

          PERFORM analyze_change_state_detailed
            CHANGING lv_has_change_exit
                     lv_new_incomplete_cnt_exit
                     lv_new_complete_cnt_exit
                     lv_edit_existing_cnt_exit.

          " Không có thay đổi -> thoát luôn
          IF lv_has_change_exit = abap_false.
            LEAVE TO SCREEN 0.
          ELSE.

            " --- CASE 1: CHỈ NEWREC THIẾU KHÓA ---
            IF     lv_new_incomplete_cnt_exit > 0
               AND lv_new_complete_cnt_exit   = 0
               AND lv_edit_existing_cnt_exit  = 0.

              lv_text_exit = |Có | && lv_new_incomplete_cnt_exit &&
                             | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và thoát?|.
              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = 'Dòng mới thiếu khóa'
                  text_question         = lv_text_exit
                  text_button_1         = 'Bỏ & Thoát'
                  text_button_2         = 'Quay lại'
                  default_button        = '2'
                  display_cancel_button = space
                IMPORTING
                  answer                = lv_ans_exit.

              IF lv_ans_exit = '1'.
                PERFORM purge_incomplete_newrecs.
                LEAVE TO SCREEN 0.
              ELSE.
                " Ở lại màn hình, GIỮ EDIT
                PERFORM stay_in_edit_and_focus.
                gv_edit_md      = abap_true.
                gv_toolbar_mode = 'E'.
                PERFORM apply_editability_and_push.
                IF g_alv_grid IS BOUND.
                  TRY.
                      g_alv_grid->set_ready_for_input( 1 ).
                      g_alv_grid->refresh_table_display(
                        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                      g_alv_grid->set_toolbar_interactive( ).
                    CATCH cx_root.
                  ENDTRY.
                ENDIF.
                CLEAR g_okcode.
                cl_gui_cfw=>flush( ).
              ENDIF.

              " --- CASE 2: CHỈ NEWREC ĐỦ KHÓA (chưa lưu) ---
            ELSEIF lv_new_complete_cnt_exit   > 0
               AND lv_edit_existing_cnt_exit  = 0
               AND lv_new_incomplete_cnt_exit = 0.

              lv_text_exit = |Có | && lv_new_complete_cnt_exit &&
                             | dòng mới CHƯA LƯU. Lưu trước khi thoát?|.
              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = 'Dòng mới chưa lưu'
                  text_question         = lv_text_exit
                  text_button_1         = 'Lưu'
                  text_button_2         = 'Không lưu'
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'. " Lưu
                  PERFORM on_save.

                  " ⬇️ SAU KHI on_save: NẾU CÒN NEWREC/LỖI → KHÔNG CHO THOÁT
                  DATA: lv_has_af_exit        TYPE abap_bool,
                        lv_new_inc_af_exit    TYPE i,
                        lv_new_comp_af_exit   TYPE i,
                        lv_edit_exist_af_exit TYPE i.

                  PERFORM analyze_change_state_detailed
                    CHANGING lv_has_af_exit
                             lv_new_inc_af_exit
                             lv_new_comp_af_exit
                             lv_edit_exist_af_exit.

                  IF gv_edit_md = abap_true OR lv_has_af_exit = abap_true.
                    " còn đồ chưa sạch -> Ở LẠI
                    PERFORM stay_in_edit_and_focus.
                    gv_edit_md      = abap_true.
                    gv_toolbar_mode = 'E'.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    " không còn gì -> THOÁT
                    LEAVE TO SCREEN 0.
                  ENDIF.



                WHEN '2'. " Không lưu -> bỏ thay đổi rồi thoát
                  PERFORM discard_unsaved_changes.
                  LEAVE TO SCREEN 0.

                WHEN 'A'. " Cancel -> ở lại và giữ Edit
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

              " --- CASE 3: CHỈ sửa dòng DB cũ ---
            ELSEIF lv_edit_existing_cnt_exit  > 0
               AND lv_new_incomplete_cnt_exit = 0
               AND lv_new_complete_cnt_exit   = 0.

              lv_text_exit = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi thoát?'.
              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = 'Thay đổi chưa lưu'
                  text_question         = lv_text_exit
                  text_button_1         = 'Lưu'
                  text_button_2         = 'Không lưu'
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'.
                  PERFORM on_save.
                  IF gv_edit_md = abap_true. " còn ở Edit => lỗi
                    PERFORM stay_in_edit_and_focus.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    LEAVE TO SCREEN 0.
                  ENDIF.

                WHEN '2'.
                  PERFORM discard_unsaved_changes.
                  LEAVE TO SCREEN 0.

                WHEN 'A'.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

              " --- CASE 4: HỖN HỢP ---
            ELSE.
              lv_text_exit = |Có thay đổi chưa lưu: | &&
                             lv_new_incomplete_cnt_exit && ' NEWREC thiếu khóa, ' &&
                             lv_new_complete_cnt_exit   && ' NEWREC đủ khóa, ' &&
                             lv_edit_existing_cnt_exit  && ' thay đổi dòng cũ. Lưu trước khi thoát?'.
              CLEAR lv_ans_exit.
              CALL FUNCTION 'POPUP_TO_CONFIRM'
                EXPORTING
                  titlebar              = 'Thay đổi chưa lưu'
                  text_question         = lv_text_exit
                  text_button_1         = 'Lưu'
                  text_button_2         = 'Không lưu'
                  default_button        = '1'
                  display_cancel_button = 'X'
                IMPORTING
                  answer                = lv_ans_exit.

              CASE lv_ans_exit.
                WHEN '1'.
                  PERFORM on_save.
                  IF gv_edit_md = abap_true. " còn ở Edit => lỗi
                    PERFORM stay_in_edit_and_focus.
                    PERFORM apply_editability_and_push.
                    IF g_alv_grid IS BOUND.
                      TRY.
                          g_alv_grid->set_ready_for_input( 1 ).
                          g_alv_grid->refresh_table_display(
                            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                          g_alv_grid->set_toolbar_interactive( ).
                        CATCH cx_root.
                      ENDTRY.
                    ENDIF.
                    CLEAR g_okcode.
                    cl_gui_cfw=>flush( ).
                  ELSE.
                    LEAVE TO SCREEN 0.
                  ENDIF.

                WHEN '2'.
                  PERFORM discard_unsaved_changes.
                  LEAVE TO SCREEN 0.

                WHEN 'A'.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
              ENDCASE.

            ENDIF. " kết thúc ELSE có thay đổi

          ENDIF. " lv_has_change_exit

          "==================================================================
        WHEN 'SAVE'.
          "==================================================================

          PERFORM on_save.  "on_save tự quyết định: OK -> về View, Lỗi -> ở lại Edit

          " Áp lại editability & toolbar theo gv_edit_md mà on_save vừa set
          PERFORM apply_editability_and_push.

          IF g_alv_grid IS BOUND.
            TRY.
                g_alv_grid->set_ready_for_input( COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).
              CATCH cx_root.
            ENDTRY.

            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).

            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " KHÔNG xóa NEWREC ở đây. on_save sẽ xóa NEWREC SAU KHI COMMIT thành công.

          "==================================================================
        WHEN OTHERS.
          "==================================================================
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

      ENDCASE.

    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.





FORM apply_editability_and_push.
  " 0) Đảm bảo danh sách KEY
  PERFORM ensure_keys USING p_tab.

  "=== Danh sách field audit cần khóa cứng
  DATA: lt_audit TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit.
  APPEND 'ERTIM' TO lt_audit.
  APPEND 'ERNAM' TO lt_audit.
  APPEND 'AEDAT' TO lt_audit.
  APPEND 'AETIM' TO lt_audit.
  APPEND 'AENAM' TO lt_audit.

  " 1) Fieldcatalog (cấp cột)
  "    - KEY: chỉ mở khi đang Add (dòng NEWREC)
  "    - Non-key: mở khi Edit
  "    - AUDIT: luôn đóng (edit = space, f4 = space)
  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.
  DATA: lv_is_key   TYPE abap_bool,
        lv_is_audit TYPE abap_bool.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Audit? -> khóa cứng
    lv_is_audit = abap_false.
    READ TABLE lt_audit WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_is_audit = abap_true.
    ENDIF.

    IF lv_is_audit = abap_true.
      CLEAR: <fc>-edit, <fc>-f4availabl.
      CONTINUE. " bỏ qua các quyết định edit khác
    ENDIF.

    " Key / Non-key
    lv_is_key = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    IF lv_is_key = abap_true.
      IF gv_add_mode = abap_true.
        <fc>-edit       = 'X'.
        <fc>-f4availabl = 'X'.
      ELSE.
        CLEAR: <fc>-edit, <fc>-f4availabl.
      ENDIF.
    ELSE.
      IF gv_edit_md = abap_true.
        <fc>-edit = 'X'.
      ELSE.
        CLEAR <fc>-edit.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Style theo dòng (cấp ô)
  "    - KEY enabled chỉ khi Add + dòng NEWREC = 'X'
  "    - AUDIT luôn disabled
  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <celltab> TYPE lvc_t_styl,
                 <newrec>  TYPE any.
  DATA: ls_styl   TYPE lvc_s_styl,
        lv_key    TYPE dd03l-fieldname,
        lv_is_new TYPE abap_bool,
        lv_af     TYPE lvc_fname.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls> TO <celltab>.
      IF sy-subrc <> 0. CONTINUE. ENDIF.
      CLEAR <celltab>.

      " Dòng mới?
      lv_is_new = abap_false.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'. lv_is_new = abap_true. ENDIF.

      " Khóa/mở cho KEY
      LOOP AT gt_key_fields INTO lv_key.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_key.
        IF gv_add_mode = abap_true AND lv_is_new = abap_true.
          ls_styl-style = cl_gui_alv_grid=>mc_style_enabled.     " cho nhập KEY ở dòng NEW
        ELSE.
          ls_styl-style = cl_gui_alv_grid=>mc_style_disabled.    " xám, không caret
        ENDIF.

        " Chỉ chèn nếu chưa có trong CELLTAB
        READ TABLE <celltab> WITH KEY fieldname = ls_styl-fieldname style = ls_styl-style TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          INSERT ls_styl INTO TABLE <celltab>.
        ENDIF.
      ENDLOOP.

      " Luôn khóa các cột audit
      LOOP AT lt_audit INTO lv_af.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_af.
        ls_styl-style     = cl_gui_alv_grid=>mc_style_disabled.

        " Chỉ chèn nếu chưa có
        READ TABLE <celltab> WITH KEY fieldname = ls_styl-fieldname style = ls_styl-style TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          INSERT ls_styl INTO TABLE <celltab>.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

  "=== 2b) Tô màu dòng NEWREC/không hợp lệ bằng ROW_COLOR ===
  " Ưu tiên: INVALID (đỏ=6) > NEWREC (xanh=5)
  FIELD-SYMBOLS: <upload_flag> TYPE any,
                 <valid_flag>  TYPE any,
                 <row_color>   TYPE lvc_t_scol.
  DATA: lt_cols  TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY,
        lv_fname TYPE lvc_fname,
        lt_scol  TYPE lvc_t_scol,
        ls_scol  TYPE lvc_s_scol.

  CLEAR lt_cols.
  LOOP AT gt_fieldcat ASSIGNING <fc> WHERE tech <> abap_true AND no_out <> abap_true.
    APPEND <fc>-fieldname TO lt_cols.
  ENDLOOP.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls> TO <row_color>.
    IF sy-subrc <> 0. CONTINUE. ENDIF.

    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <upload_flag>.
    ASSIGN COMPONENT 'VALID'  OF STRUCTURE <ls> TO <valid_flag>.

    CLEAR lt_scol.

    IF <valid_flag> IS ASSIGNED AND <valid_flag> IS INITIAL.
      LOOP AT lt_cols INTO lv_fname.
        CLEAR ls_scol.
        ls_scol-fname     = lv_fname.
        ls_scol-color-col = 6.
        ls_scol-color-int = 0.
        ls_scol-color-inv = 0.
        APPEND ls_scol TO lt_scol.
      ENDLOOP.
    ELSEIF <upload_flag> IS ASSIGNED AND <upload_flag> = 'X'.
      LOOP AT lt_cols INTO lv_fname.
        CLEAR ls_scol.
        ls_scol-fname     = lv_fname.
        ls_scol-color-col = 5.
        ls_scol-color-int = 0.
        ls_scol-color-inv = 0.
        APPEND ls_scol TO lt_scol.
      ENDLOOP.
    ENDIF.

    <row_color> = lt_scol.
  ENDLOOP.

  " 3) Đẩy xuống frontend & refresh
  PERFORM dedup_fieldcat.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_frontend_fieldcatalog( it_fieldcatalog = gt_fieldcat ).
      CATCH cx_root.
    ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
  ENDIF.
ENDFORM.



FORM stay_in_edit_and_focus.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.

  " 1) Giữ Edit; Add-mode nếu vẫn còn NEWREC
  gv_edit_md      = abap_true.
  gv_toolbar_mode = 'E'.

  gv_add_mode = abap_false.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        gv_add_mode = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " 2) Áp rule + bật input + rebuild toolbar
  PERFORM apply_editability_and_push.
  PERFORM register_f4_all.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_ready_for_input( 1 ).
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " 3) Focus về KEY của dòng NEWREC (nếu có)
  PERFORM focus_key_on_newrec.

  cl_gui_cfw=>flush( ).
ENDFORM.

FORM build_excluding_toolbar.
  CLEAR gt_tb_excl.
  " Nút thao tác cục bộ trên lưới
  APPEND cl_gui_alv_grid=>mc_fc_loc_insert_row TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_delete_row TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_append_row  TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_copy_row    TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_copy       TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_paste      TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_cut        TO gt_tb_excl.
  APPEND cl_gui_alv_grid=>mc_fc_loc_undo       TO gt_tb_excl.

ENDFORM.



*=====================================================================*
* INCLUDE ZFA25SAP23_IO - Đọc / Upload dữ liệu Excel (.XLSX, .XLS)
*=====================================================================*

TYPES: BEGIN OF alsmex_tabline,
         row   TYPE i,
         col   TYPE i,
         value TYPE string,
       END OF alsmex_tabline.
TYPES: ty_t_alsmex_tab TYPE STANDARD TABLE OF alsmex_tabline WITH DEFAULT KEY.
DATA: lv_date TYPE d,
      lv_time TYPE t,
      lr_desc TYPE REF TO cl_abap_tabledescr.

*---------------------------------------------------------------------*
* FORM read_xlsx_clfdt - Đọc file .XLSX bằng class CL_FDT_XL_SPREADSHEET
*---------------------------------------------------------------------*
FORM read_xlsx_clfdt USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.

  DATA: lt_bin   TYPE solix_tab,
        lv_xstr  TYPE xstring,
        lv_file  TYPE string,
        lo_excel TYPE REF TO cl_fdt_xl_spreadsheet,
        lt_names TYPE if_fdt_doc_spreadsheet=>t_worksheet_names,
        lv_sheet TYPE string,
        lr_src   TYPE REF TO data,
        lt_cells TYPE STANDARD TABLE OF alsmex_tabline,
        ls_cell  TYPE alsmex_tabline.

  FIELD-SYMBOLS: <lt_src> TYPE STANDARD TABLE,
                 <ls_src> TYPE any,
                 <lv_any> TYPE any,
                 <lt_ret> TYPE STANDARD TABLE.

  lv_file = iv_file.

  "--- Upload file Excel (.xlsx) dạng nhị phân ---
  cl_gui_frontend_services=>gui_upload(
  EXPORTING filename = lv_file filetype = 'BIN'
  CHANGING data_tab = lt_bin ).

  IF sy-subrc <> 0.
    MESSAGE 'Không đọc được file .xlsx từ frontend' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_xstr = cl_bcs_convert=>solix_to_xstring( lt_bin ).

  "--- Đọc nội dung file Excel ---
  CREATE OBJECT lo_excel
    EXPORTING
      xdocument     = lv_xstr
      document_name = 'UPLOAD_EXCEL'.

  lo_excel->if_fdt_doc_spreadsheet~get_worksheet_names(
  IMPORTING worksheet_names = lt_names ).
  READ TABLE lt_names INDEX 1 INTO lv_sheet.

  IF sy-subrc <> 0 OR lv_sheet IS INITIAL.
    MESSAGE 'Không xác định được worksheet đầu tiên' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_src = lo_excel->if_fdt_doc_spreadsheet~get_itab_from_worksheet( lv_sheet ).
  ASSIGN lr_src->* TO <lt_src>.
  IF <lt_src> IS NOT ASSIGNED.
    MESSAGE 'Không đọc được dữ liệu từ worksheet' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Lấy mô tả cấu trúc bảng ---
  DATA lo_tabdesc TYPE REF TO cl_abap_tabledescr.
  DATA lo_linedesc TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  lo_tabdesc ?= cl_abap_typedescr=>describe_by_data( <lt_src> ).
  lo_linedesc ?= CAST cl_abap_structdescr( lo_tabdesc->get_table_line_type( ) ).
  lt_comp = lo_linedesc->get_components( ).

  "--- Chuyển dữ liệu từ Excel → ALSMEX_TABLINE ---
  DATA lv_row TYPE i VALUE 0.
  LOOP AT <lt_src> ASSIGNING <ls_src>.
    lv_row = lv_row + 1.
    DATA(lv_col) = 0.
    LOOP AT lt_comp INTO DATA(ls_comp).
      ASSIGN COMPONENT ls_comp-name OF STRUCTURE <ls_src> TO <lv_any>.
      lv_col = lv_col + 1.

      CLEAR ls_cell.
      ls_cell-row = lv_row.
      ls_cell-col = lv_col.
      ls_cell-value = <lv_any>.
      APPEND ls_cell TO lt_cells.
    ENDLOOP.
  ENDLOOP.

  "--- Gán dữ liệu trả ra ---
  CREATE DATA cr_cells LIKE lt_cells.
  ASSIGN cr_cells->* TO <lt_ret>.
  IF <lt_ret> IS ASSIGNED.
    <lt_ret> = lt_cells.
  ENDIF.

  "--- Trích header (dòng 1) ---
  DATA lt_header TYPE STANDARD TABLE OF string.
  LOOP AT lt_cells INTO ls_cell WHERE row = 1.
    APPEND ls_cell-value TO lt_header.
  ENDLOOP.

  IF lt_header IS INITIAL.
    MESSAGE 'Không xác định được tiêu đề (header) trong Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  ct_header = lt_header.

  DESCRIBE TABLE lt_cells LINES DATA(lv_cnt).
  " Bỏ WRITE để không mở list
  " WRITE: / 'Số dòng đọc từ Excel:', lv_cnt.

  IF lv_cnt = 0.
    MESSAGE 'Không đọc được dữ liệu từ Excel ' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
ENDFORM.


*---------------------------------------------------------------------*
* FORM read_xls_fm - Đọc file .XLS bằng FM cũ ALSM_EXCEL_TO_INTERNAL_TABLE
*---------------------------------------------------------------------*
FORM read_xls_fm USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.
  " SAP GUI đời mới không còn OLE, nên gọi lại form read_xlsx_clfdt
  PERFORM read_xlsx_clfdt USING iv_file CHANGING cr_cells ct_header.
ENDFORM.


*---------------------------------------------------------------------*
* FORM upload_data_strict_match - Upload Excel → ALV data
*---------------------------------------------------------------------*
FORM upload_data_strict_match.
  gv_in_upload = abap_true. " 🔹 Đánh dấu đang upload
  TYPES: BEGIN OF alsmex_tabline,
           row   TYPE i,
           col   TYPE i,
           value TYPE string,
         END OF alsmex_tabline.

  DATA: lv_filename TYPE rlgrap-filename,
        lt_file     TYPE filetable,
        ls_file     TYPE file_table,
        ls_fc       TYPE lvc_s_fcat,
        lv_rc       TYPE i,
        lr_cells    TYPE REF TO data,
        lt_str      TYPE STANDARD TABLE OF alsmex_tabline,
        lt_header   TYPE STANDARD TABLE OF string,
        lv_msg      TYPE string.

  "=== 1) Hộp thoại chọn file Excel ===
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title      = 'Chọn file Excel để upload'
      default_extension = 'XLSX'
      file_filter       = 'Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls|All files (*.*)|*.*'
      multiselection    = abap_false
    CHANGING
      file_table        = lt_file
      rc                = lv_rc
    EXCEPTIONS
      OTHERS            = 1.

  IF lv_rc < 1 OR sy-subrc <> 0.
    MESSAGE 'Upload bị hủy hoặc lỗi khi chọn file' TYPE 'I'.

    RETURN.
  ENDIF.

  READ TABLE lt_file INTO ls_file INDEX 1.
  IF sy-subrc <> 0 OR ls_file-filename IS INITIAL.
    MESSAGE 'Không đọc được đường dẫn file' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_filename = ls_file-filename.
  "=== Tạo bảng tạm chứa dữ liệu Excel ===
  DATA: lr_upload TYPE REF TO data,
        lr_desc   TYPE REF TO cl_abap_tabledescr.

  FIELD-SYMBOLS: <lt_upload> TYPE STANDARD TABLE.

  lr_desc ?= cl_abap_tabledescr=>describe_by_data_ref( gr_data ).
  CREATE DATA lr_upload TYPE HANDLE lr_desc.
  ASSIGN lr_upload->* TO <lt_upload>.
  "=== 2) Đọc dữ liệu Excel ===
  IF lv_filename CP '*.xlsx' OR lv_filename CP '*.XLSX'.
    PERFORM read_xlsx_clfdt USING lv_filename CHANGING lr_cells lt_header.
  ELSEIF lv_filename CP '*.xls' OR lv_filename CP '*.XLS'.
    PERFORM read_xls_fm USING lv_filename CHANGING lr_cells lt_header.
  ELSE.
    MESSAGE 'Định dạng file không được hỗ trợ (chỉ .xls / .xlsx)' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lr_cells IS INITIAL.
    MESSAGE 'Không đọc được dữ liệu từ file Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  FIELD-SYMBOLS: <lt_str>      TYPE ty_t_alsmex_tab,
                 <ls_line_hdr> TYPE alsmex_tabline.

  ASSIGN lr_cells->* TO <lt_str>.
  IF <lt_str> IS INITIAL.
    MESSAGE 'File Excel rỗng hoặc lỗi định dạng' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 3b) Kiểm tra header Excel khớp DDIC ===
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        ls_ddic_field  TYPE dfies,
        lt_missing     TYPE STANDARD TABLE OF string,
        lt_extra       TYPE STANDARD TABLE OF string.

  "=== 3a) Lấy metadata & fieldcatalog chuẩn từ ZEDIT_DDIC ===
  DATA: lt_dfies     TYPE STANDARD TABLE OF dfies,
        lt_keys_meta TYPE STANDARD TABLE OF dd03l-fieldname.

  PERFORM get_metadata USING p_tab CHANGING lt_dfies.

  "--- Lấy key fields (tự SELECT ra) ---
  SELECT fieldname FROM dd03l INTO TABLE @lt_keys_meta
    WHERE tabname = @p_tab AND keyflag = 'X' AND fieldname <> 'MANDT'.

  PERFORM build_fieldcat_all.
  gt_key_fields = lt_keys_meta.

  lt_ddic_fields = lt_dfies.

  IF sy-subrc <> 0 OR lt_ddic_fields IS INITIAL.
    MESSAGE |Không lấy được metadata của bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Bỏ các field kỹ thuật không cần upload ---
  DELETE lt_ddic_fields WHERE fieldname = 'MANDT'.
  "--- Chuẩn hóa tên header Excel ---
  LOOP AT lt_header INTO DATA(lv_header_norm).
    lv_header_norm = to_upper( condense( lv_header_norm ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_header_norm WITH ''.
    CONDENSE lv_header_norm NO-GAPS.
    MODIFY lt_header FROM lv_header_norm INDEX sy-tabix.
  ENDLOOP.

  "--- Chuẩn hóa tên field DDIC ---
  DATA lt_ddic_names TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
  LOOP AT lt_ddic_fields INTO ls_ddic_field.
    DATA(lv_ddic_norm) = to_upper( condense( ls_ddic_field-fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_ddic_norm WITH ''.
    CONDENSE lv_ddic_norm NO-GAPS.
    APPEND lv_ddic_norm TO lt_ddic_names.
  ENDLOOP.

  "--- So sánh 2 danh sách ---
  LOOP AT lt_ddic_names INTO DATA(lv_fieldname).
    READ TABLE lt_header WITH KEY table_line = lv_fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Thiếu cột trong Excel: { lv_fieldname }| TO lt_missing.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_header INTO DATA(lv_hdrname).
    READ TABLE lt_ddic_names WITH KEY table_line = lv_hdrname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Cột thừa trong Excel: { lv_hdrname }| TO lt_extra.
    ENDIF.
  ENDLOOP.

  "--- Báo lỗi nếu có thiếu/thừa ---
  IF lt_missing IS NOT INITIAL.
    LOOP AT lt_missing INTO DATA(lv_miss).
      MESSAGE lv_miss TYPE 'S' DISPLAY LIKE 'E'.
    ENDLOOP.
    MESSAGE |Header Excel bị thiếu cột so với bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lt_extra IS NOT INITIAL.
    LOOP AT lt_extra INTO DATA(lv_ext).
      MESSAGE lv_ext TYPE 'S' DISPLAY LIKE 'W'.
    ENDLOOP.
    MESSAGE |Excel có thêm cột không nằm trong bảng { p_tab }| TYPE 'S'.
  ENDIF.

  "=== 6) Gán dữ liệu vào GR_DATA ===
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any,
                 <val>     TYPE any.

  ASSIGN gr_data->* TO <lt_data>.
  IF sy-subrc <> 0 OR <lt_data> IS NOT ASSIGNED.
    MESSAGE 'Lỗi gán GR_DATA' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  LOOP AT <lt_str> INTO DATA(ls_cell) WHERE row > 1.
    READ TABLE lt_header INDEX ls_cell-col INTO DATA(lv_hdr_fieldname).
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.
    "=== Chuẩn hóa tên field từ header Excel ===
    DATA(lv_field_excel) = lv_hdr_fieldname.
    TRANSLATE lv_field_excel TO UPPER CASE.
    CONDENSE lv_field_excel NO-GAPS.
    REPLACE ALL OCCURRENCES OF '_' IN lv_field_excel WITH ''.
    CONDENSE lv_field_excel NO-GAPS.


    "=== Map tên field Excel sang field DDIC ===
    DATA(lv_real_field) = lv_fieldname.

    " Kiểm tra có trong danh sách field DDIC không
    DATA(lv_in_ddic) = abap_false.
    LOOP AT lt_ddic_fields INTO DATA(ls_check_field) WHERE fieldname = lv_real_field.
      lv_in_ddic = abap_true.
      EXIT.
    ENDLOOP.

    READ TABLE gt_fieldnames TRANSPORTING NO FIELDS WITH KEY table_line = lv_real_field.

    IF sy-subrc <> 0 AND lv_in_ddic = abap_false.
      " Nếu header không tồn tại trong DDIC → bỏ qua cell này
      CONTINUE.
    ENDIF.
    DATA(lv_row) = ls_cell-row.

    "=== Bỏ qua dòng header và dòng Excel trống ===
    IF lv_row = 1.
      CONTINUE. " Dòng tiêu đề
    ENDIF.

    DATA(lv_all_empty) = abap_true.
    LOOP AT <lt_str> INTO DATA(ls_check) WHERE row = lv_row.
      IF ls_check-value IS NOT INITIAL.
        lv_all_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_all_empty = abap_true.
      CONTINUE. " Bỏ qua dòng Excel trống
    ENDIF.

    READ TABLE <lt_upload> INDEX ( lv_row - 1 ) ASSIGNING <ls_data>.
    IF sy-subrc <> 0.
      APPEND INITIAL LINE TO <lt_upload> ASSIGNING <ls_data>.
    ENDIF.


*    ASSIGN COMPONENT lv_real_field OF STRUCTURE <ls_data> TO <val>.
    ASSIGN COMPONENT lv_field_excel OF STRUCTURE <ls_data> TO <val>.


    IF <val> IS ASSIGNED.

      "-----------------------------------------------------------
      " 🔹 [1] Lấy metadata field từ DDIC
      "-----------------------------------------------------------
      READ TABLE lt_ddic_fields INTO DATA(ls_ddic) WITH KEY fieldname = lv_field_excel.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      DATA(lv_val_excel) = ls_cell-value.
      "=== 🔧 Chuẩn hóa giá trị đặc biệt (ngày & giờ Excel trống hoặc 00000000) ===
      IF ls_ddic-inttype = 'D' AND ( lv_val_excel = '00000000' OR lv_val_excel = '0' ).
        CLEAR lv_val_excel.
      ENDIF.
      IF ls_ddic-inttype = 'T' AND ( lv_val_excel = '000000' OR lv_val_excel = '0' ).
        CLEAR lv_val_excel.
      ENDIF.
      DATA(lv_type) = ls_ddic-inttype.
      DATA(lv_valid) = abap_true.

      "-----------------------------------------------------------
      " 🔹 [2] Kiểm tra kiểu dữ liệu cơ bản (DATE, TIME, NUMERIC…)
      "-----------------------------------------------------------
      lv_valid = abap_true.
      CASE lv_type.
        WHEN 'D'. " Date
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_date) = CONV d( lv_val_excel ).

                CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
                  EXPORTING
                    date                      = lv_date
                  EXCEPTIONS
                    plausibility_check_failed = 1
                    OTHERS                    = 2.

                IF sy-subrc <> 0.
                  lv_valid = abap_false. " Ngày không hợp lệ (ví dụ 30/02/2025)
                ENDIF.

              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.


        WHEN 'T'. " Time
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_time) = CONV t( lv_val_excel ).
                DATA(lv_dummy_date) = CONV d( '19700101' ).
                CONVERT DATE lv_dummy_date TIME lv_time INTO TIME STAMP DATA(lv_timestamp_t) TIME ZONE 'UTC'.
              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.
        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
          TRY.
              lv_val_excel = lv_val_excel + 0.
            CATCH cx_sy_conversion_no_number cx_sy_conversion_error.
              lv_valid = abap_false.
          ENDTRY.
        WHEN 'N'. " NUMC
          lv_val_excel = condense( to_upper( lv_val_excel ) ).
          IF lv_val_excel IS NOT INITIAL AND NOT lv_val_excel CO '0123456789'.
            lv_valid = abap_false.
          ENDIF.

        WHEN OTHERS.
          lv_valid = abap_true.
      ENDCASE.

      " Nếu dữ liệu không hợp lệ theo kiểu DDIC → đánh dấu lỗi
      IF lv_valid = abap_false.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag>).
        IF <lv_err_flag> IS ASSIGNED.
          <lv_err_flag> = 'X'.
        ENDIF.
        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_msg>).
        IF <lv_err_msg> IS ASSIGNED.
          CONCATENATE 'Sai định dạng dữ liệu tại cột' lv_real_field ' giá trị:' lv_val_excel INTO <lv_err_msg> SEPARATED BY space.
        ENDIF.
        CONTINUE.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [3] Kiểm tra giá trị hợp lệ theo DOMAIN (nếu có)
      "-----------------------------------------------------------
      IF ls_ddic-domname IS NOT INITIAL.
        DATA(lt_dom_values) = VALUE dd07v_tab( ).
        CALL FUNCTION 'DD_DOMVALUES_GET'
          EXPORTING
            domname        = ls_ddic-domname
            text           = 'X'
          TABLES
            dd07v_tab      = lt_dom_values
          EXCEPTIONS
            wrong_textflag = 1
            OTHERS         = 2.

        IF sy-subrc = 0 AND lt_dom_values IS NOT INITIAL.
          DATA(lv_value_found) = abap_false.
          LOOP AT lt_dom_values INTO DATA(ls_dom).
            IF to_upper( ls_dom-domvalue_l ) = to_upper( lv_val_excel ).
              lv_value_found = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_value_found = abap_false.
            ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag2>).
            IF <lv_err_flag2> IS ASSIGNED.
              <lv_err_flag2> = 'X'.
            ENDIF.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [4] Gán giá trị vào field nếu hợp lệ
      "-----------------------------------------------------------
      TRY.
          <val> = lv_val_excel.
        CATCH cx_sy_conversion_error.
          ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag3>).
          IF <lv_err_flag3> IS ASSIGNED.
            <lv_err_flag3> = 'X'.
          ENDIF.
          CONTINUE.
      ENDTRY.
    ENDIF.
  ENDLOOP.


  "=== ✅ STEP 3: Merge dữ liệu Excel vào ALV hiện tại (preview) ===
  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <lt_alv>.

  IF <lt_alv> IS ASSIGNED.

    DATA(lv_inserted) = 0.
    DATA(lv_updated)  = 0.

    LOOP AT <lt_upload> ASSIGNING FIELD-SYMBOL(<ls_new>).
      DATA(lv_found) = abap_false.

      LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_old>).
        DATA(lv_samekey) = abap_true.

        LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld>).
          FIELD-SYMBOLS: <v_old> TYPE any, <v_new> TYPE any.
          ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_old> TO <v_old>.
          ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_new> TO <v_new>.
          IF <v_old> IS ASSIGNED AND <v_new> IS ASSIGNED AND |{ <v_old> }| <> |{ <v_new> }|.
            lv_samekey = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_samekey = abap_true.
          " 🔹 So sánh xem có thay đổi không
          DATA(lv_changed) = abap_false.
          LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc_chk>).
    " Bỏ qua field kỹ thuật và audit
    IF <fc_chk>-tech = abap_true OR <fc_chk>-no_out = abap_true.
      CONTINUE.
    ENDIF.
    IF <fc_chk>-fieldname CP 'ER*' OR <fc_chk>-fieldname CP 'AE*' OR <fc_chk>-fieldname CP 'IS_*'.
      CONTINUE.
    ENDIF.

    ASSIGN COMPONENT <fc_chk>-fieldname OF STRUCTURE <ls_new> TO FIELD-SYMBOL(<v_n>).
    ASSIGN COMPONENT <fc_chk>-fieldname OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<v_o>).

    IF <v_n> IS ASSIGNED AND <v_o> IS ASSIGNED AND <v_n> <> <v_o>.
      lv_changed = abap_true.
      EXIT.
    ENDIF.
  ENDLOOP.
          IF lv_changed = abap_true.
            " Chỉ copy field thường, giữ nguyên 3 field create
            LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc_upd>).
              IF <fc_upd>-fieldname CP 'ER*' OR <fc_upd>-fieldname = 'MANDT'.
                CONTINUE. " Không copy ERDAT/ERNAM/ERTIM, giữ nguyên
              ENDIF.
              ASSIGN COMPONENT <fc_upd>-fieldname OF STRUCTURE <ls_new> TO FIELD-SYMBOL(<v_new2>).
              ASSIGN COMPONENT <fc_upd>-fieldname OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<v_old2>).
              IF <v_new2> IS ASSIGNED AND <v_old2> IS ASSIGNED.
                <v_old2> = <v_new2>.
              ENDIF.
            ENDLOOP.


            " ✅ Chỉ đánh dấu IS_CHANGED, không update 3 field audit ở bước preview
            ASSIGN COMPONENT 'IS_CHANGED' OF STRUCTURE <ls_old> TO FIELD-SYMBOL(<flag_upd>).
            IF sy-subrc = 0. <flag_upd> = 'X'. ENDIF.

            lv_updated += 1.
          ENDIF.

          lv_found = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_found = abap_false.
        " 🔹 Record mới
        APPEND INITIAL LINE TO <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_newrow>).
        MOVE-CORRESPONDING <ls_new> TO <ls_newrow>.

        ASSIGN COMPONENT 'IS_NEW' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<flag_new>).
        IF sy-subrc = 0. <flag_new> = 'X'. ENDIF.

        ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<erdat>).
        ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<ertim>).
        ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_newrow> TO FIELD-SYMBOL(<ernam>).
        IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
        IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
        IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.

        lv_inserted += 1.
      ENDIF.
    ENDLOOP.

    " ✅ Thông báo kết quả merge
    DATA(lv_total) = lv_inserted + lv_updated.
    IF lv_total > 0.
      MESSAGE |Đã upload { lv_total } dòng dữ liệu tạm thời (INSERT={ lv_inserted }, UPDATE={ lv_updated }).| TYPE 'S'.
    ELSE.
      MESSAGE 'Không có thay đổi mới trong file Excel.' TYPE 'I'.
    ENDIF.

  ENDIF.


  "--- Refresh hiển thị preview
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root INTO DATA(lx_refresh).
        MESSAGE lx_refresh->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDIF.



  "-----------------------------------------------------------
  " 🔹 [5] Kiểm tra trùng khóa chính trong Excel
  "-----------------------------------------------------------
  DATA(lt_keys) = VALUE string_table( ).
  LOOP AT lt_ddic_fields INTO DATA(ls_keyfld) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_keyfld-fieldname TO lt_keys.
  ENDLOOP.

  IF lt_keys IS NOT INITIAL.
    DATA(lt_seen_keys) = VALUE string_table( ).
    DATA(lv_key_string) = VALUE string( ).

    LOOP AT <lt_data> ASSIGNING <ls_data>.
      CLEAR lv_key_string.
      LOOP AT lt_keys INTO DATA(lv_keyfld).
        ASSIGN COMPONENT lv_keyfld OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_keyval3>).
        IF <lv_keyval3> IS ASSIGNED.
          lv_key_string = lv_key_string && to_upper( condense( <lv_keyval3> ) ) && '|'.
        ENDIF.
      ENDLOOP.

      IF lv_key_string IS INITIAL.
        CONTINUE.
      ENDIF.


      READ TABLE lt_seen_keys WITH KEY table_line = lv_key_string TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        ASSIGN COMPONENT 'IS_DUPLICATE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_dupflag>).
        IF <lv_dupflag> IS ASSIGNED.
          <lv_dupflag> = 'X'.
        ENDIF.
        CONTINUE.
      ELSE.
        APPEND lv_key_string TO lt_seen_keys.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "-----------------------------------------------------------
  " 🔹 [7] Kiểm tra các trường bắt buộc (Key fields)
  "-----------------------------------------------------------
  DATA: lt_errors   TYPE STANDARD TABLE OF char255,
        lv_err_text TYPE char255.
  DATA(lt_required_fields) = VALUE string_table( ).

  LOOP AT lt_ddic_fields INTO DATA(ls_req) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_req-fieldname TO lt_required_fields.
  ENDLOOP.

  IF lt_required_fields IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      DATA(lv_missing_fields) = VALUE string( ).
      LOOP AT lt_required_fields INTO DATA(lv_req_field).
        ASSIGN COMPONENT lv_req_field OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_req_val>).
        IF <lv_req_val> IS ASSIGNED AND <lv_req_val> IS INITIAL.
          lv_missing_fields = lv_missing_fields && lv_req_field && ', '.
        ENDIF.
      ENDLOOP.

      IF lv_missing_fields IS NOT INITIAL.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag_req>).
        IF <lv_err_flag_req> IS ASSIGNED.
          <lv_err_flag_req> = 'X'.
        ENDIF.

        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_msg_flag>).
        IF <lv_msg_flag> IS ASSIGNED.
          CONCATENATE 'Thiếu dữ liệu bắt buộc: ' lv_missing_fields INTO <lv_msg_flag>.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
*
*  "-----------------------------------------------------------
*  " 🔹 [8] Hiển thị tất cả lỗi trong popup (nếu có)
*  "-----------------------------------------------------------
*  IF lt_errors IS NOT INITIAL.
*    DATA(lv_err_count) = lines( lt_errors ).
*    MESSAGE |Phát hiện { lv_err_count } lỗi trong dữ liệu upload.| TYPE 'I'.
*    CALL FUNCTION 'POPUP_WITH_TABLE_DISPLAY_T'
*      EXPORTING
*        endpos_col   = 120
*        endpos_row   = 25
*        startpos_col = 5
*        startpos_row = 2
*        titletext    = |Danh sách lỗi dữ liệu (Tổng: { lv_err_count })|
*      TABLES
*        valuetab     = lt_errors
*      EXCEPTIONS
*        break_off    = 1
*        OTHERS       = 2.
*    IF sy-subrc = 1.
*      MESSAGE 'Người dùng đã đóng popup lỗi' TYPE 'S'.
*    ELSEIF sy-subrc = 2.
*      MESSAGE 'Lỗi khi hiển thị popup lỗi' TYPE 'E'.
*    ENDIF.
*  ENDIF.
"=== 7) Xác định lại dòng INSERT / UPDATE (chuẩn với logic SAVE) ===
PERFORM ensure_keys USING p_tab.

LOOP AT <lt_data> ASSIGNING <ls_data>.
  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
  IF sy-subrc = 0.
    CLEAR <newrec>.
  ENDIF.

  " Xây điều kiện WHERE theo key
  DATA(lv_where2) = VALUE string( ).
  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld2>).
    ASSIGN COMPONENT <keyfld2> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<valkey2>).
    IF <valkey2> IS ASSIGNED.
      DATA(lv_val2) = |{ <valkey2> }|.
      CONDENSE lv_val2 NO-GAPS.
      IF lv_where2 IS INITIAL.
        lv_where2 = |{ <keyfld2> } = '{ lv_val2 }'|.
      ELSE.
        lv_where2 = |{ lv_where2 } AND { <keyfld2> } = '{ lv_val2 }'|.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF lv_where2 IS INITIAL.
    CONTINUE.
  ENDIF.

  " Kiểm tra tồn tại trong DB
DATA lv_dummy TYPE i.

TRY.
    SELECT SINGLE COUNT(*)
      FROM (p_tab)
      WHERE (lv_where2)
      INTO @lv_dummy.
  CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
    MESSAGE lx_sem->get_text( ) TYPE 'I'.
    CONTINUE.
ENDTRY.
  IF sy-subrc <> 0 AND <newrec> IS ASSIGNED.
    <newrec> = 'X'. " dòng mới
  ENDIF.
ENDLOOP.
"=== Chuẩn hóa key NUMC để không mất leading zero ===
LOOP AT <lt_data> ASSIGNING <ls_data>.
  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<keyfld3>).
    READ TABLE lt_ddic_fields INTO DATA(ls_meta3) WITH KEY fieldname = <keyfld3>.
    IF sy-subrc = 0 AND ls_meta3-inttype = 'N'.
      ASSIGN COMPONENT <keyfld3> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<val3>).
      IF <val3> IS ASSIGNED.
        DATA(lv_norm3) = condense( |{ <val3> }| ).
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING input  = lv_norm3
          IMPORTING output = lv_norm3.
        <val3> = lv_norm3.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDLOOP.

  "=== 7c) Cập nhật logic insert/update cho 6 field audit ===
  DATA: lv_tabname TYPE tabname,
        lv_user    TYPE sy-uname,
        lv_tzone   TYPE tznzone,
        lv_ts      TYPE timestamp.

  lv_tabname = p_tab.
  lv_user    = sy-uname.

  " Lấy timezone thật của user (ví dụ ICT cho Việt Nam)
  TRY.
      lv_tzone = cl_abap_context_info=>get_user_time_zone( ).
    CATCH cx_abap_context_info_error.
      lv_tzone = 'UTC'.
  ENDTRY.

  GET TIME STAMP FIELD lv_ts.
  CONVERT TIME STAMP lv_ts TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.
  DATA(lv_new_count)     = 0.
  DATA(lv_changed_count) = 0.
  " Duyệt dữ liệu ALV hiện tại (đã merge)
  ASSIGN gr_data->* TO <lt_alv>.

  LOOP AT <lt_alv> ASSIGNING <ls_data>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_newrec_flag>).
  IF <lv_newrec_flag> IS ASSIGNED AND <lv_newrec_flag> = 'X'.
    lv_new_count += 1.

    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_erdat>).
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ertim>).
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ernam>).
    IF <lv_erdat> IS ASSIGNED. <lv_erdat> = lv_date. ENDIF.
    IF <lv_ertim> IS ASSIGNED. <lv_ertim> = lv_time. ENDIF.
    IF <lv_ernam> IS ASSIGNED. <lv_ernam> = lv_user. ENDIF.

    " Clear Changed*
    ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat_i>).
    ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim_i>).
    ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam_i>).
    IF <lv_aedat_i> IS ASSIGNED. CLEAR <lv_aedat_i>. ENDIF.
    IF <lv_aetim_i> IS ASSIGNED. CLEAR <lv_aetim_i>. ENDIF.
    IF <lv_aenam_i> IS ASSIGNED. CLEAR <lv_aenam_i>. ENDIF.

    CONTINUE. " ⬅️ rất quan trọng
  ENDIF.
    FIELD-SYMBOLS: <val_old> TYPE any,
                   <val_new> TYPE any.

    " Xây WHERE theo key để check record trong DB
    DATA(lv_where) = VALUE string( ).
    LOOP AT gt_key_fields ASSIGNING <keyfld>.
      ASSIGN COMPONENT <keyfld> OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_key>).
      IF <lv_key> IS ASSIGNED.
        IF lv_where IS INITIAL.
          lv_where = |{ <keyfld> } = '{ <lv_key> }'|.
        ELSE.
          lv_where = |{ lv_where } AND { <keyfld> } = '{ <lv_key> }'|.
        ENDIF.
      ENDIF.
    ENDLOOP.

    " Tạo record tạm để đọc DB
    DATA(lo_struct) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_name( lv_tabname ) ).
    DATA lr_db TYPE REF TO data.
    CREATE DATA lr_db TYPE HANDLE lo_struct.
    ASSIGN lr_db->* TO FIELD-SYMBOL(<ls_db>).

    DATA: lo_sql    TYPE REF TO cl_sql_statement,
          lo_result TYPE REF TO cl_sql_result_set,
          lx_sql2   TYPE REF TO cx_sql_exception.

    DATA(lv_sql) = |SELECT * FROM { lv_tabname } WHERE { lv_where }|.

    CREATE OBJECT lo_sql.

    TRY.
        lo_result = lo_sql->execute_query( lv_sql ).
        lo_result->set_param_struct( REF #( <ls_db> ) ).
        lo_result->next( ).
      CATCH cx_sql_exception INTO lx_sql2.
        CLEAR <ls_db>.
    ENDTRY.


    IF <ls_db> IS ASSIGNED AND <ls_db> IS NOT INITIAL.
      CLEAR lv_changed.

      LOOP AT lt_ddic_fields INTO DATA(ls_field).
        IF ls_field-fieldname CP 'MANDT' OR
           ls_field-fieldname CP 'AE*' OR
           ls_field-fieldname CP 'ER*'.
          CONTINUE.
        ENDIF.
        ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_data> TO <val_new>.
        ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_db>  TO <val_old>.
        IF <val_new> IS ASSIGNED AND <val_old> IS ASSIGNED.

          "=== Normalize giá trị theo kiểu dữ liệu
          READ TABLE lt_ddic_fields INTO DATA(ls_type) WITH KEY fieldname = ls_field-fieldname.
          IF sy-subrc = 0.
            DATA(lv_old_str) = |{ <val_old> }|.
            DATA(lv_new_str) = |{ <val_new> }|.

            CASE ls_type-inttype.
              WHEN 'N'.  " NUMC
                SHIFT lv_old_str LEFT DELETING LEADING '0'.
                SHIFT lv_new_str LEFT DELETING LEADING '0'.
              WHEN 'I' OR 'P' OR 'F' OR 'CURR' OR 'QUAN'.
                CONDENSE lv_old_str NO-GAPS.
                CONDENSE lv_new_str NO-GAPS.
              WHEN 'D'. " Date
                IF lv_old_str = '00000000'. CLEAR lv_old_str. ENDIF.
                IF lv_new_str = '00000000'. CLEAR lv_new_str. ENDIF.
              WHEN 'T'. " Time
                IF lv_old_str = '000000'. CLEAR lv_old_str. ENDIF.
                IF lv_new_str = '000000'. CLEAR lv_new_str. ENDIF.
              WHEN OTHERS.
                " Giữ nguyên
            ENDCASE.

            IF lv_old_str <> lv_new_str.
              lv_changed = abap_true.
              EXIT.
            ENDIF.
          ENDIF.

        ENDIF.

      ENDLOOP.

      IF lv_changed = abap_true.
        lv_changed_count += 1.
        ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat>).
        ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim>).
        ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam>).
        IF <lv_aedat> IS ASSIGNED. <lv_aedat> = lv_date. ENDIF.
        IF <lv_aetim> IS ASSIGNED. <lv_aetim> = lv_time. ENDIF.
        IF <lv_aenam> IS ASSIGNED. <lv_aenam> = lv_user. ENDIF.
      ENDIF.

  ELSE.
    lv_new_count += 1.
    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_erdat_i>).
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ertim_i>).
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_ernam_i>).
    IF <lv_erdat_i> IS ASSIGNED. <lv_erdat_i> = lv_date. ENDIF.
    IF <lv_ertim_i> IS ASSIGNED. <lv_ertim_i> = lv_time. ENDIF.
    IF <lv_ernam_i> IS ASSIGNED. <lv_ernam_i> = lv_user. ENDIF.

    ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aedat_new>).
    ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aetim_new>).
    ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_aenam_new>).
    IF <lv_aedat_new> IS ASSIGNED. CLEAR <lv_aedat_new>. ENDIF.
    IF <lv_aetim_new> IS ASSIGNED. CLEAR <lv_aetim_new>. ENDIF.
    IF <lv_aenam_new> IS ASSIGNED. CLEAR <lv_aenam_new>. ENDIF.
  ENDIF.



  ENDLOOP.

  DESCRIBE TABLE <lt_data> LINES DATA(lv_count).
  IF lv_count = 0.
    MESSAGE 'Không có dữ liệu hợp lệ sau upload!' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  DATA(lv_total_changed) = lv_new_count + lv_changed_count.

  IF lv_total_changed > 0.
    MESSAGE |Đã upload { lv_total_changed } dòng dữ liệu tạm thời ({ lv_new_count } dòng mới, { lv_changed_count } dòng cập nhật).| TYPE 'S'.
  ELSE.
    MESSAGE 'Không có thay đổi dữ liệu mới trong upload này.' TYPE 'I'.
  ENDIF.
*-----------------------------------------------------------------------
* 🔹 Reorder 6 field thủ công xuống cuối ALV (bản đảm bảo)
*-----------------------------------------------------------------------
PERFORM build_fieldcat_all.

DATA: lt_audit_fields TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      lt_other_fields TYPE STANDARD TABLE OF string,
      lt_final_fields TYPE STANDARD TABLE OF string.

" Danh sách 6 field thủ công chuẩn
APPEND 'ERDAT' TO lt_audit_fields.
APPEND 'ERTIM' TO lt_audit_fields.
APPEND 'ERNAM' TO lt_audit_fields.
APPEND 'AEDAT' TO lt_audit_fields.
APPEND 'AETIM' TO lt_audit_fields.
APPEND 'AENAM' TO lt_audit_fields.

" Tách field thường và field audit
LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
  DATA(lv_name) = <fs_fc>-fieldname.
  READ TABLE lt_audit_fields WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    CONTINUE. " sẽ append sau
  ELSE.
    APPEND lv_name TO lt_other_fields.
  ENDIF.
ENDLOOP.

" Gộp lại: thường trước, audit sau
APPEND LINES OF lt_audit_fields TO lt_other_fields.
lt_final_fields = lt_other_fields.

" Cập nhật lại col_pos theo thứ tự chuẩn
DATA(lv_pos) = 1.
LOOP AT lt_final_fields INTO DATA(lv_field).
  READ TABLE gt_fieldcat ASSIGNING <fs_fc> WITH KEY fieldname = lv_field.
  IF sy-subrc = 0.
    <fs_fc>-col_pos = lv_pos.
    lv_pos += 1.
  ENDIF.
ENDLOOP.

"=========================================================
" 🔹 Cập nhật ALV hiển thị theo fieldcatalog mới
"=========================================================
IF g_alv_grid IS BOUND.
  TRY.
      g_alv_grid->set_frontend_fieldcatalog( gt_fieldcat ).
      g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      g_alv_grid->set_toolbar_interactive( ).
    CATCH cx_root INTO DATA(lx_err).
      MESSAGE lx_err->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDIF.

PERFORM apply_editability_and_push.
gv_in_upload = abap_false.
ENDFORM.



FORM download_excel_xlsx USING ir_data TYPE REF TO data.

  FIELD-SYMBOLS: <lt_original> TYPE STANDARD TABLE,
                 <ls_original> TYPE any,
                 <lt_no_style> TYPE STANDARD TABLE,
                 <ls_no_style> TYPE any.

  DATA: lr_data_no_style TYPE REF TO data,
        lv_filename      TYPE string,
        lv_path          TYPE string,
        lv_fullpath      TYPE string,
        lv_action        TYPE i,
        lv_xstring       TYPE xstring,
        lt_bin           TYPE solix_tab,
        lt_cols          TYPE if_fdt_doc_spreadsheet=>t_column.

  " 1) Hộp thoại lưu file
  cl_gui_frontend_services=>file_save_dialog(
    EXPORTING
      default_extension = 'xlsx'
      default_file_name  = |DATA_{ p_tab }_{ sy-datum }_{ sy-uzeit }.xlsx|
      file_filter        = 'Excel Files (*.xlsx) | *.xlsx'
    CHANGING
      filename     = lv_filename
      path         = lv_path
      fullpath     = lv_fullpath
      user_action  = lv_action
    EXCEPTIONS
      OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Export bị hủy' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Loại bỏ style
  ASSIGN ir_data->* TO <lt_original>.
  IF <lt_original> IS NOT ASSIGNED.
    MESSAGE 'Dữ liệu gốc không được assign' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM create_dynamic_itab_no_style USING p_tab CHANGING lr_data_no_style.
  ASSIGN lr_data_no_style->* TO <lt_no_style>.
  IF <lt_no_style> IS NOT ASSIGNED.
    MESSAGE 'Không tạo được cấu trúc dữ liệu cho export' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  LOOP AT <lt_original> ASSIGNING <ls_original>.
    APPEND INITIAL LINE TO <lt_no_style> ASSIGNING <ls_no_style>.
    MOVE-CORRESPONDING <ls_original> TO <ls_no_style>.
  ENDLOOP.

  "=== Ẩn cột MANDT nếu có ===
  DATA: lo_anydesc  TYPE REF TO cl_abap_typedescr,
        lo_tabdesc  TYPE REF TO cl_abap_tabledescr,
        lo_struct   TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_filtered TYPE REF TO data.

  FIELD-SYMBOLS: <lt_filtered> TYPE STANDARD TABLE,
                 <ls_filtered> TYPE any.

  lo_anydesc = cl_abap_typedescr=>describe_by_data_ref( REF #( <lt_no_style> ) ).
  lo_tabdesc ?= lo_anydesc.
  lo_struct  ?= lo_tabdesc->get_table_line_type( ).
  lt_comp    = lo_struct->get_components( ).

  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'MANDT' OR ls_comp-name = 'mandt'.
      DELETE lt_comp INDEX sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF sy-subrc = 0.
    lo_newline = cl_abap_structdescr=>create( lt_comp ).
    lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
    CREATE DATA lr_filtered TYPE HANDLE lo_newtab.
    ASSIGN lr_filtered->* TO <lt_filtered>.

    LOOP AT <lt_no_style> ASSIGNING <ls_no_style>.
      APPEND INITIAL LINE TO <lt_filtered> ASSIGNING <ls_filtered>.
      MOVE-CORRESPONDING <ls_no_style> TO <ls_filtered>.
    ENDLOOP.

    lr_data_no_style = lr_filtered.
  ENDIF.
  "=== Nếu bảng có 6 field thủ công thì đẩy chúng xuống cuối ===
  DATA: lt_audit_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_keep        TYPE STANDARD TABLE OF string,
        lt_remove      TYPE STANDARD TABLE OF string,
        lt_ddic        TYPE TABLE OF dfies,
        ls_ddic        TYPE dfies.

  APPEND 'ERDAT' TO lt_audit_order.
  APPEND 'ERTIM' TO lt_audit_order.
  APPEND 'ERNAM' TO lt_audit_order.
  APPEND 'AEDAT' TO lt_audit_order.
  APPEND 'AETIM' TO lt_audit_order.
  APPEND 'AENAM' TO lt_audit_order.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic
    EXCEPTIONS
      OTHERS    = 1.

  DATA: lt_normal TYPE STANDARD TABLE OF string,
        lt_audit  TYPE STANDARD TABLE OF string.

  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
    READ TABLE lt_audit_order WITH KEY table_line = ls_ddic-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND ls_ddic-fieldname TO lt_audit.
    ELSE.
      APPEND ls_ddic-fieldname TO lt_normal.
    ENDIF.
  ENDLOOP.

  IF lt_audit IS NOT INITIAL.
    DATA lt_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    APPEND LINES OF lt_normal TO lt_order.
    APPEND LINES OF lt_audit  TO lt_order.
    PERFORM reorder_components_ref USING lr_data_no_style lt_order.
  ENDIF.

  " 3) Xuất Excel
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
        EXPORTING
          columns       = lt_cols
          itab          = lr_data_no_style
          iv_call_type  = 2
          iv_sheet_name = 'DATA'
        RECEIVING
          xdocument     = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  " 4) Ghi ra frontend
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).
  cl_gui_frontend_services=>gui_download(
    EXPORTING
      filename     = lv_fullpath
      filetype     = 'BIN'
      bin_filesize = xstrlen( lv_xstring )
    CHANGING
      data_tab     = lt_bin
    EXCEPTIONS
      OTHERS = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Xuất dữ liệu thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM download_template_xlsx - Export Excel Template
*---------------------------------------------------------------------*
FORM download_template_xlsx.

  FIELD-SYMBOLS: <lt_template> TYPE STANDARD TABLE.

  "=== 1) Hộp thoại lưu file ===
  DATA: lv_filename TYPE string,
        lv_path     TYPE string,
        lv_fullpath TYPE string,
        lv_action   TYPE i.

  cl_gui_frontend_services=>file_save_dialog(
    EXPORTING
      default_extension = 'xlsx'
      default_file_name = |TEMPLATE_{ p_tab }.xlsx|
      file_filter       = 'Excel Files (*.xlsx) | *.xlsx'
    CHANGING
      filename          = lv_filename
      path              = lv_path
      fullpath          = lv_fullpath
      user_action       = lv_action
    EXCEPTIONS
      OTHERS            = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Download template bị hủy' TYPE 'I'.
    RETURN.
  ENDIF.

  "=== 2) Tạo dòng mẫu dựa trên cấu trúc bảng ===
  DATA: lr_template TYPE REF TO data,
        lv_xstring  TYPE xstring,
        lt_cols     TYPE if_fdt_doc_spreadsheet=>t_column.

  PERFORM create_dynamic_itab USING p_tab
    CHANGING lr_template.

  "=== 2B) Loại bỏ 6 field thủ công nếu không có trong DDIC ===
  DATA: lt_ddic   TYPE TABLE OF dfies,
        lt_keep   TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_remove TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        ls_ddic   TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
    APPEND ls_ddic-fieldname TO lt_keep.
  ENDLOOP.

  " --- Tạo danh sách audit WITHOUT VALUE constructor ---
  DATA lt_audit TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit.
  APPEND 'ERTIM' TO lt_audit.
  APPEND 'ERNAM' TO lt_audit.
  APPEND 'AEDAT' TO lt_audit.
  APPEND 'AETIM' TO lt_audit.
  APPEND 'AENAM' TO lt_audit.

  " --- Nếu field audit KHÔNG có trong DDIC thì đưa vào lt_remove ---
  DATA lv_field TYPE string.
  LOOP AT lt_audit INTO lv_field.
    " Kiểm tra membership theo kiểu classic
    READ TABLE lt_keep WITH KEY table_line = lv_field TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND lv_field TO lt_remove.
    ENDIF.
  ENDLOOP.

  IF lt_remove IS NOT INITIAL.
    PERFORM remove_components_from_ref USING lr_template lt_remove.
  ENDIF.
  "=== Nếu bảng có các field audit thì đẩy chúng xuống cuối ===
  DATA: lt_audit_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lt_keep_order  TYPE STANDARD TABLE OF dfies,
        lt_normal      TYPE TABLE OF dfies,
        lt_audit2      TYPE TABLE OF dfies.  " ⬅️ đổi tên khác

  APPEND 'ERDAT' TO lt_audit_order.
  APPEND 'ERTIM' TO lt_audit_order.
  APPEND 'ERNAM' TO lt_audit_order.
  APPEND 'AEDAT' TO lt_audit_order.
  APPEND 'AETIM' TO lt_audit_order.
  APPEND 'AENAM' TO lt_audit_order.

  LOOP AT lt_ddic INTO ls_ddic WHERE fieldname <> 'MANDT'.
    READ TABLE lt_audit_order WITH KEY table_line = ls_ddic-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND ls_ddic TO lt_audit2.
    ELSE.
      APPEND ls_ddic TO lt_normal.
    ENDIF.
  ENDLOOP.

  IF lt_audit2 IS NOT INITIAL.
    " Reorder cấu trúc template: normal trước, audit sau
    DATA: lt_order TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    LOOP AT lt_normal INTO ls_ddic.
      APPEND ls_ddic-fieldname TO lt_order.
    ENDLOOP.
    LOOP AT lt_audit2 INTO ls_ddic.
      APPEND ls_ddic-fieldname TO lt_order.
    ENDLOOP.
    PERFORM reorder_components_ref USING lr_template lt_order.
  ENDIF.


  "=== 3) Tạo 1 dòng trống để có cấu trúc export ===
  ASSIGN lr_template->* TO <lt_template>.
  IF <lt_template> IS ASSIGNED.
    CLEAR <lt_template>.
    APPEND INITIAL LINE TO <lt_template>.
  ELSE.
    MESSAGE 'Không tạo được template từ bảng dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 4) Xuất nội dung ra file Excel ===
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
        EXPORTING
          itab         = lr_template
          iv_call_type = 2
          iv_sheet_name = 'TEMPLATE'
        RECEIVING
          xdocument = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "=== 5) Ghi file ra frontend ===
  DATA lt_bin TYPE solix_tab.
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).

  cl_gui_frontend_services=>gui_download(
    EXPORTING
      filename     = lv_fullpath
      filetype     = 'BIN'
      bin_filesize = xstrlen( lv_xstring )
    CHANGING
      data_tab     = lt_bin
    EXCEPTIONS
      OTHERS       = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Tải template thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file template' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* Helper: Xóa component khỏi data ref động
*---------------------------------------------------------------------*
FORM remove_components_from_ref USING ir_table TYPE REF TO data
                                      it_fields TYPE STANDARD TABLE.

  DATA: lo_table   TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF ir_table IS INITIAL.
    RETURN.
  ENDIF.

  lo_table ?= cl_abap_tabledescr=>describe_by_data_ref( ir_table ).
  lo_line  ?= lo_table->get_table_line_type( ).
  lt_comp   = lo_line->get_components( ).

  LOOP AT it_fields ASSIGNING FIELD-SYMBOL(<f>).
    DELETE lt_comp WHERE name = <f>.
  ENDLOOP.

  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
  CREATE DATA lr_new TYPE HANDLE lo_newtab.

  ASSIGN ir_table->* TO <lt_old>.
  ASSIGN lr_new->*  TO <lt_new>.
  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  ir_table = lr_new.

ENDFORM.
*---------------------------------------------------------------------*
* Helper: Sắp xếp lại thứ tự component trong data ref động
*---------------------------------------------------------------------*
FORM reorder_components_ref USING ir_table TYPE REF TO data
                                  it_order TYPE STANDARD TABLE.

  DATA: lo_table   TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lt_newcomp TYPE abap_component_tab,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF ir_table IS INITIAL OR it_order IS INITIAL.
    RETURN.
  ENDIF.

  lo_table ?= cl_abap_tabledescr=>describe_by_data_ref( ir_table ).
  lo_line  ?= lo_table->get_table_line_type( ).
  lt_comp  = lo_line->get_components( ).

  LOOP AT it_order ASSIGNING FIELD-SYMBOL(<f_name>).
    READ TABLE lt_comp INTO ls_comp WITH KEY name = <f_name>.
    IF sy-subrc = 0.
      APPEND ls_comp TO lt_newcomp.
    ENDIF.
  ENDLOOP.

  IF lt_newcomp IS INITIAL.
    RETURN.
  ENDIF.

  lo_newline = cl_abap_structdescr=>create( lt_newcomp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).
  CREATE DATA lr_new TYPE HANDLE lo_newtab.

  ASSIGN ir_table->* TO <lt_old>.
  ASSIGN lr_new->*  TO <lt_new>.
  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  ir_table = lr_new.

ENDFORM.




*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_AUDIT (classic-syntax, no templates/inline)
*&---------------------------------------------------------------------*

* Cache key fields for current table
FORM ensure_keys USING iv_tab TYPE tabname.
  DATA lv_tab TYPE tabname.
  IF gv_keys_tabname <> iv_tab.
    CLEAR gt_key_fields.
    gv_keys_tabname = iv_tab.
  ENDIF.

  " Upper-case để khớp DDIC
  lv_tab = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  IF gt_key_fields IS INITIAL.
    SELECT fieldname
      FROM dd03l
      INTO TABLE @gt_key_fields
      WHERE tabname  = @lv_tab
        AND as4local = 'A'
        AND keyflag  = 'X'
        AND fieldname <> 'MANDT'.
  ENDIF.

  " Fallback từ fieldcatalog nếu DD03L không trả về
  IF gt_key_fields IS INITIAL AND gt_fieldcat IS NOT INITIAL.
    FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
    LOOP AT gt_fieldcat ASSIGNING <fc>.
      IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
        CONTINUE.
      ENDIF.
      IF <fc>-key = 'X' AND to_upper( <fc>-fieldname ) <> 'MANDT'.
        APPEND <fc>-fieldname TO gt_key_fields.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM ensure_rowcolor_component CHANGING cr_tab TYPE REF TO data.
  DATA: lo_tab     TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lo_any     TYPE REF TO cl_abap_typedescr,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data,
        lr_row     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab  ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp  = lo_line->get_components( ).

  " Đã có ROW_COLOR chưa?
  LOOP AT lt_comp INTO ls_comp WHERE name = 'ROW_COLOR'.
    RETURN.
  ENDLOOP.

  " Thêm ROW_COLOR: LVC_T_SCOL
  lo_any ?= cl_abap_typedescr=>describe_by_name( 'LVC_T_SCOL' ).
  CLEAR ls_comp.
  ls_comp-name = 'ROW_COLOR'.
  ls_comp-type ?= lo_any.
  APPEND ls_comp TO lt_comp.

  " Dựng lại line type
  lo_newline = cl_abap_structdescr=>create( lt_comp ).

  " Dựng lại table type (giữ đơn giản để tương thích release cũ)
  lo_newtab  = cl_abap_tabledescr=>create( p_line_type = lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    CREATE DATA lr_row TYPE HANDLE lo_newline.
    ASSIGN lr_row->* TO <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
    APPEND <ls_new> TO <lt_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.

FORM ensure_celltab_component CHANGING cr_tab TYPE REF TO data.
  TYPE-POOLS abap.

  DATA: lo_tab      TYPE REF TO cl_abap_tabledescr,
        lo_line     TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lv_has_cell TYPE abap_bool,
        lv_has_new  TYPE abap_bool,
        lo_cell_any TYPE REF TO cl_abap_typedescr,
        lo_cell_dat TYPE REF TO cl_abap_datadescr,
        lo_bool_dat TYPE REF TO cl_abap_datadescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_new      TYPE REF TO data,
        lr_row      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).




  CLEAR: lv_has_cell, lv_has_new.
  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'CELLTAB'. lv_has_cell = abap_true. ENDIF.
    IF ls_comp-name = 'NEWREC'.  lv_has_new  = abap_true. ENDIF.
  ENDLOOP.

  IF lv_has_cell = abap_true AND lv_has_new = abap_true.
    RETURN. " đã có đủ hai cột kỹ thuật
  ENDIF.

  " Thêm CELLTAB: LVC_T_STYL
  IF lv_has_cell = abap_false.
    lo_cell_any = cl_abap_typedescr=>describe_by_name( 'LVC_T_STYL' ).
    lo_cell_dat ?= lo_cell_any.
    CLEAR ls_comp.
    ls_comp-name = 'CELLTAB'.
    ls_comp-type = lo_cell_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Thêm NEWREC: C(1)
  IF lv_has_new = abap_false.
    lo_bool_dat = cl_abap_elemdescr=>get_c( 1 ).
    CLEAR ls_comp.
    ls_comp-name = 'NEWREC'.
    ls_comp-type = lo_bool_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Tạo lại line type + table type mới
  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  IF <lt_old> IS ASSIGNED AND <lt_new> IS ASSIGNED.
    LOOP AT <lt_old> ASSIGNING <ls_old>.
      CREATE DATA lr_row TYPE HANDLE lo_newline.
      ASSIGN lr_row->* TO <ls_new>.
      MOVE-CORRESPONDING <ls_old> TO <ls_new>.
      APPEND <ls_new> TO <lt_new>.
    ENDLOOP.
    cr_tab = lr_new. " ref mới có CELLTAB + NEWREC
  ENDIF.
ENDFORM.

*=== Helper: escape dấu nháy đơn cho literal SQL
FORM _escape_single_quote USING    iv_in  TYPE string
                          CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH ''''''.
ENDFORM.

* Build dynamic WHERE from key fields (type-aware, with escaping)
FORM make_where_from_key USING    is_str  TYPE any
                                  it_keys TYPE STANDARD TABLE
                         CHANGING ev_where TYPE string
                                  ev_err   TYPE string.

  CLEAR: ev_where, ev_err.
  DATA lv_cond TYPE string.
  FIELD-SYMBOLS: <val>   TYPE any, <fname> TYPE dd03l-fieldname.

  DATA all_empty TYPE abap_bool VALUE abap_true.

  LOOP AT it_keys ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE is_str TO <val>.
    IF sy-subrc = 0 AND <val> IS ASSIGNED AND <val> IS NOT INITIAL.
      all_empty = abap_false.

      "  Phải lấy mô tả kiểu *trong từng vòng lặp*
      DATA(lo_td) = cl_abap_typedescr=>describe_by_data_ref( REF #( <val> ) ).
      DATA(lv_tk) = lo_td->type_kind.

      DATA(lv_piece) = ``.
      IF lv_tk = 'I' OR lv_tk = 'P' OR lv_tk = 'F' OR lv_tk = 'N'.
        lv_piece = |{ <fname> } = { <val> }|.
      ELSE.
        DATA(lv_s) = |{ <val> }|.
        PERFORM _escape_single_quote USING lv_s CHANGING lv_s.
        lv_piece = |{ <fname> } = '{ lv_s }'|.
      ENDIF.

      IF lv_cond IS INITIAL.
        lv_cond = lv_piece.
      ELSE.
        lv_cond = |{ lv_cond } AND { lv_piece }|.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF all_empty = abap_true.
    ev_err = 'Tất cả trường khóa đều rỗng.'.
    RETURN.
  ENDIF.

  IF lv_cond IS INITIAL.
    ev_err = 'Không tạo được điều kiện khóa.'.
  ELSE.
    ev_where = lv_cond.
  ENDIF.

ENDFORM.


* Serialize any structure to JSON (fallback XML) into ZDE_JSON_TXT
FORM to_json USING is_any TYPE any
             CHANGING cv_json TYPE zde_json_txt.
  DATA lv_str TYPE string.
  CLEAR lv_str.
  " Đồng bộ pretty_mode-none để khớp json_to_itab
  TRY.
      lv_str = /ui2/cl_json=>serialize(
                 data        = is_any
                 pretty_name = /ui2/cl_json=>pretty_mode-none ).
    CATCH cx_root.
      TRY.
          CALL TRANSFORMATION id
            SOURCE data = is_any
            RESULT XML lv_str.
        CATCH cx_root.
          lv_str = '<<serialize failed>>'.
      ENDTRY.
  ENDTRY.
  cv_json = lv_str.
ENDFORM.

* Check key when adding: key must be filled & not exist in DB
FORM check_key_on_add USING    iv_tab  TYPE tabname
                      CHANGING ev_err  TYPE string.

  DATA: lv_first_key TYPE dd03l-fieldname,
        lv_where     TYPE string,
        lv_msg       TYPE string,
        lv_label     TYPE string,
        lv_count     TYPE i.

  FIELD-SYMBOLS: <lt>    TYPE STANDARD TABLE,
                 <ls>    TYPE any,
                 <comp>  TYPE any,
                 <fname> TYPE dd03l-fieldname.

  CLEAR ev_err.

  " Chỉ kiểm tra khi đang ở chế độ Add
  IF gv_add_mode IS INITIAL.
    RETURN.
  ENDIF.

  " Lấy dòng NEW (giả định dòng cuối)
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS INITIAL.
    ev_err = 'Không có dữ liệu để kiểm tra.'.
    RETURN.
  ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX lines( <lt> ).
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED.
    ev_err = 'Không xác định được dòng mới.'.
    RETURN.
  ENDIF.

  " Lấy key fields
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC.'.
    RETURN.
  ENDIF.

  " ============ 1) Nếu tất cả khóa rỗng ============
  DATA(lv_all_empty) = abap_true.
  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc = 0 AND <comp> IS NOT INITIAL.
      lv_all_empty = abap_false.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_all_empty = abap_true.
    READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
    IF lv_first_key IS INITIAL.
      ev_err = 'Dòng mới đang trống. Vui lòng nhập khóa.'.
    ELSE.
      ev_err = |Dòng mới đang trống. Vui lòng nhập trường khóa đầu tiên: { lv_first_key }|.
    ENDIF.

    " Focus caret vào ô KEY đầu tiên
    TRY.
        DATA: ls_row TYPE lvc_s_row,
              ls_col TYPE lvc_s_col.
        ls_row-index     = lines( <lt> ).
        ls_col-fieldname = COND #( WHEN lv_first_key IS INITIAL
                                   THEN gt_key_fields[ 1 ]
                                   ELSE lv_first_key ).
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = ls_row
                      is_column_id = ls_col ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = ls_row
                      is_col_info = ls_col ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.

    RETURN. " Dừng save
  ENDIF.

  " ============ 2) Kiểm tra từng field khóa ============
  DATA: lt_dfies TYPE STANDARD TABLE OF dfies,
        ls_dfies TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tab
      all_types = 'X'
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc <> 0 OR <comp> IS INITIAL.

      CLEAR lv_label.
      READ TABLE lt_dfies INTO ls_dfies WITH KEY fieldname = <fname>.
      IF sy-subrc = 0.
        lv_label = COND #( WHEN ls_dfies-scrtext_m IS NOT INITIAL THEN ls_dfies-scrtext_m
                           WHEN ls_dfies-scrtext_l IS NOT INITIAL THEN ls_dfies-scrtext_l
                           ELSE ls_dfies-scrtext_s ).
      ENDIF.

      ev_err = COND #( WHEN lv_label IS INITIAL
                       THEN |Trường khóa { <fname> } đang rỗng|
                       ELSE |Trường khóa { <fname> } ({ lv_label }) đang rỗng| ).

      " Focus vào field khóa đang rỗng
      TRY.
          DATA: l_row TYPE lvc_s_row,
                l_col TYPE lvc_s_col.
          l_row-index     = lines( <lt> ).
          l_col-fieldname = <fname>.
          IF g_alv_grid IS BOUND.
            g_alv_grid->set_current_cell_via_id(
              EXPORTING is_row_id    = l_row
                        is_column_id = l_col ).
            g_alv_grid->set_scroll_info_via_id(
              EXPORTING is_row_info = l_row
                        is_col_info = l_col ).
          ENDIF.
        CATCH cx_root.
      ENDTRY.

      RETURN.
    ENDIF.
  ENDLOOP.

  " ============ 3) Kiểm tra trùng khóa trong DB (theo TOÀN BỘ key) ============
  PERFORM make_where_from_key USING <ls> gt_key_fields
                       CHANGING lv_where lv_msg.
  IF lv_where IS INITIAL.
    ev_err = COND #( WHEN lv_msg IS INITIAL THEN 'Không tạo được điều kiện khóa.' ELSE lv_msg ).
    RETURN.
  ENDIF.

  " Đếm số bản ghi khớp toàn bộ composite key
  TRY.
      SELECT COUNT( * ) INTO lv_count
        FROM (iv_tab)
        WHERE (lv_where).
    CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syn).
      ev_err = |Lỗi cú pháp WHERE "{ lv_where }": { lx_syn->get_text( ) }|.
      RETURN.
  ENDTRY.

  IF lv_count > 0.
    ev_err = |Khóa đã tồn tại trong { iv_tab }. Vui lòng nhập khóa khác.|.

    " Focus vào trường khóa đầu tiên
    TRY.
        DATA: l_row2 TYPE lvc_s_row,
              l_col2 TYPE lvc_s_col.
        l_row2-index = lines( <lt> ).
        READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
        IF lv_first_key IS INITIAL.
          lv_first_key = gt_key_fields[ 1 ].
        ENDIF.
        l_col2-fieldname = lv_first_key.
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = l_row2
                      is_column_id = l_col2 ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = l_row2
                      is_col_info = l_col2 ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.

    RETURN.
  ENDIF.

ENDFORM.


FORM on_save.
  DATA: lv_mod TYPE i,
        lv_err TYPE string,
        lv_msg TYPE c LENGTH 200.

  DATA: lr_to_save TYPE REF TO data,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lo_tab     TYPE REF TO cl_abap_tabledescr.

  FIELD-SYMBOLS: <lt_to_save> TYPE STANDARD TABLE,
                 <ls_to_save> TYPE any.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.

  DATA: lv_where  TYPE string,
        lv_we     TYPE string,
        lv_is_new TYPE abap_bool.

  DATA: lr_db_struct TYPE REF TO cl_abap_structdescr,
        lr_now_db    TYPE REF TO data,
        lr_old_db    TYPE REF TO data.

  FIELD-SYMBOLS: <ls_db_now> TYPE any,
                 <ls_db_old> TYPE any,
                 <fs_mandt>  TYPE any.

  DATA: lr_old TYPE REF TO data.
  FIELD-SYMBOLS: <ls_old> TYPE any.

  DATA: lxsql TYPE REF TO cx_sy_dynamic_osql_syntax.

  DATA: ls_stbl TYPE lvc_s_stbl.
  CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  " Đẩy dữ liệu đang edit về itab
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  " 1) Kiểm tra khóa khi thêm dòng (cũ của bạn)
  DATA lv_ck TYPE string.
  CLEAR lv_ck.
  PERFORM check_key_on_add USING p_tab CHANGING lv_ck.
  IF lv_ck IS NOT INITIAL.
    MESSAGE lv_ck TYPE 'S' DISPLAY LIKE 'E'.
    gv_dirty        = abap_true.
    gv_add_mode     = abap_true.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
    ENDIF.
    RETURN.
  ENDIF.

  " 2) Chuẩn bị
  REFRESH gt_audit.
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    MESSAGE 'Không có dữ liệu để lưu.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING p_tab.
  IF gt_key_fields IS INITIAL.
    MESSAGE 'Bảng không có khóa trong DDIC.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( p_tab ).
  CREATE DATA lr_now_db TYPE HANDLE lr_db_struct.
  CREATE DATA lr_old_db TYPE HANDLE lr_db_struct.
  ASSIGN lr_now_db->* TO <ls_db_now>.
  ASSIGN lr_old_db->* TO <ls_db_old>.

  " === 2.a) Chặn TRÙNG KHÓA giữa các NEWREC ngay trong ALV (cũ của bạn) ===
  TYPES: BEGIN OF ty_fp, fp TYPE string, END OF ty_fp.
  DATA: lt_seen_fp TYPE HASHED TABLE OF ty_fp WITH UNIQUE KEY fp,
        ls_fp      TYPE ty_fp,
        lv_fp      TYPE string,
        lv_any_err TYPE abap_bool VALUE abap_false.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      PERFORM build_key_fingerprint USING <ls_data> gt_key_fields CHANGING lv_fp.
      IF lv_fp IS NOT INITIAL.
        IF line_exists( lt_seen_fp[ fp = lv_fp ] ).
          lv_any_err = abap_true.
        ELSE.
          ls_fp-fp = lv_fp.
          INSERT ls_fp INTO TABLE lt_seen_fp.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF lv_any_err = abap_true.
    MESSAGE 'Có dòng NEWREC trùng khóa trong lưới. Vui lòng sửa rồi lưu lại.' TYPE 'S' DISPLAY LIKE 'E'.
    gv_dirty = abap_true.
    PERFORM apply_editability_and_push.
    IF g_alv_grid IS BOUND.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    ENDIF.
    RETURN.
  ENDIF.

  " 3) Gom danh sách cần lưu (chỉ dòng hợp lệ) + audit
  DATA: lt_ins_fp_ok        TYPE HASHED TABLE OF ty_fp WITH UNIQUE KEY fp,
        lv_missing_key_any  TYPE abap_bool VALUE abap_false,
        lv_keyname          TYPE dd03l-fieldname,
        lv_this_row_missing TYPE abap_bool.

  FIELD-SYMBOLS: <fs_key> TYPE any.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    " NEWREC?
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_is_new = abap_true.
    ELSE.
      lv_is_new = abap_false.
    ENDIF.

    "⬇️ CHẶN NEWREC THIẾU KEY Ở ĐÂY
    IF lv_is_new = abap_true.
      lv_this_row_missing = abap_false.
      LOOP AT gt_key_fields INTO lv_keyname.
        ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls_data> TO <fs_key>.
        IF sy-subrc <> 0 OR <fs_key> IS INITIAL.
          lv_this_row_missing = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_this_row_missing = abap_true.
        lv_missing_key_any = abap_true.

        " tô đỏ dòng này
        FIELD-SYMBOLS: <row_color> TYPE lvc_t_scol.
        ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls_data> TO <row_color>.
        IF sy-subrc = 0 AND <row_color> IS ASSIGNED.
          DATA: lt_scol TYPE lvc_t_scol,
                ls_scol TYPE lvc_s_scol.
          CLEAR lt_scol.
          LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc_key>) WHERE tech = abap_false AND no_out = abap_false.
            CLEAR ls_scol.
            ls_scol-fname     = <fc_key>-fieldname.
            ls_scol-color-col = 6.
            APPEND ls_scol TO lt_scol.
          ENDLOOP.
          <row_color> = lt_scol.
        ENDIF.

        CONTINUE. " bỏ dòng này, không lưu
      ENDIF.
    ENDIF.

    " WHERE theo khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields CHANGING lv_where lv_we.
    IF lv_where IS INITIAL.
      MESSAGE |Không tạo được WHERE từ key fields: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    " Lazy init danh sách cần lưu
    IF lo_line IS INITIAL.
      lo_line ?= cl_abap_typedescr=>describe_by_data( <ls_data> ).
      lo_tab  = cl_abap_tabledescr=>create( p_line_type = lo_line ).
      CREATE DATA lr_to_save TYPE HANDLE lo_tab.
      ASSIGN lr_to_save->* TO <lt_to_save>.
    ENDIF.

    " Đọc bản ghi cũ từ DB
    CREATE DATA lr_old LIKE <ls_data>.
    ASSIGN lr_old->* TO <ls_old>.
    CLEAR <ls_old>.

    TRY.
        SELECT SINGLE * FROM (p_tab)
          WHERE (lv_where)
          INTO CORRESPONDING FIELDS OF @<ls_old>.
      CATCH cx_sy_dynamic_osql_syntax INTO lxsql.
        MESSAGE lxsql->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
        CLEAR <ls_old>.
        sy-subrc = 4.
    ENDTRY.

    IF lv_is_new = abap_true.
      " === INSERT: chỉ cho qua nếu CHƯA có trên DB ===
      IF sy-subrc = 0.
        lv_any_err = abap_true.
        CONTINUE.
      ENDIF.

      " Set Created*
      FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO <erdat>.
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO <ertim>.
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO <ernam>.
      IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.

      " Audit insert
      DATA(ls_a_i) = VALUE ty_audit(
        tabname = p_tab
        action  = 'INSERT'
        uname   = sy-uname
        udate   = sy-datum
        utime   = sy-uzeit ).
      PERFORM to_json USING <ls_data> CHANGING ls_a_i-after_json.
      CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_i-logid.
      APPEND ls_a_i TO gt_audit.

      APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
      MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
      PERFORM log_audit_action USING p_tab 'C' <ls_data>.

      " giữ fingerprint để lát nữa clear NEWREC đúng dòng
      CLEAR lv_fp.
      PERFORM build_key_fingerprint USING <ls_data> gt_key_fields CHANGING lv_fp.
      IF lv_fp IS NOT INITIAL.
        ls_fp-fp = lv_fp.
        INSERT ls_fp INTO TABLE lt_ins_fp_ok.
      ENDIF.

    ELSE.
      " === UPDATE ===
      CLEAR: <ls_db_now>, <ls_db_old>.
      MOVE-CORRESPONDING <ls_data> TO <ls_db_now>.
      MOVE-CORRESPONDING <ls_old>  TO <ls_db_old>.
      ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_db_now> TO <fs_mandt>.
      IF sy-subrc = 0 AND <fs_mandt> IS ASSIGNED.
        <fs_mandt> = sy-mandt.
      ENDIF.

      IF <ls_db_old> <> <ls_db_now>.
        FIELD-SYMBOLS: <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any.
        ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO <aedat>.
        ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO <aetim>.
        ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO <aenam>.
        IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
        IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
        IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.

        DATA(ls_a_u) = VALUE ty_audit(
          tabname = p_tab
          action  = 'UPDATE'
          uname   = sy-uname
          udate   = sy-datum
          utime   = sy-uzeit ).
        PERFORM to_json USING <ls_old>  CHANGING ls_a_u-before_json.
        PERFORM to_json USING <ls_data> CHANGING ls_a_u-after_json.
        CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_u-logid.
        APPEND ls_a_u TO gt_audit.

        APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
        MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
        PERFORM log_audit_action USING p_tab 'U' <ls_data>.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " ⬇️ NẾU CÓ ÍT NHẤT 1 DÒNG NEWREC THIẾU KEY → Ở LẠI EDIT
  IF lv_missing_key_any = abap_true.
    gv_edit_md      = abap_true.
    gv_add_mode     = abap_true.
    gv_toolbar_mode = 'E'.
    MESSAGE 'Có dòng mới chưa nhập đủ khóa. Vui lòng nhập đủ rồi lưu lại.' TYPE 'S' DISPLAY LIKE 'E'.
    IF g_alv_grid IS BOUND.
      PERFORM apply_editability_and_push.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    ENDIF.
    RETURN.
  ENDIF.

  " 4) Không có gì để lưu?
  IF <lt_to_save> IS NOT ASSIGNED OR <lt_to_save> IS INITIAL.
    IF lv_any_err = abap_true.
      MESSAGE 'Có dòng lỗi (trùng khóa). Không có dữ liệu hợp lệ để lưu.' TYPE 'S' DISPLAY LIKE 'E'.
    ELSE.
      MESSAGE 'Không có gì thay đổi để lưu.' TYPE 'S'.
    ENDIF.
    RETURN.
  ENDIF.

  " 5) Lưu DB
  PERFORM save_data USING p_tab
                    CHANGING lr_to_save
                             lv_mod
                             lv_err.

  IF lv_err IS NOT INITIAL.
    ROLLBACK WORK.
    gv_dirty        = abap_true.
    gv_add_mode     = abap_false.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
      g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
      TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
    ENDIF.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 6) Ghi audit
  TYPES: BEGIN OF ty_audit_db,
           mandt       TYPE mandt,
           logid       TYPE char32,
           uname       TYPE syuname,
           udate       TYPE sydatum,
           utime       TYPE syuzeit,
           tabname     TYPE tabname,
           action      TYPE char10,
           before_json TYPE zde_json_txt,
           after_json  TYPE zde_json_txt,
         END OF ty_audit_db.
  DATA wa_log TYPE ty_audit_db.
  LOOP AT gt_audit ASSIGNING FIELD-SYMBOL(<a>).
    CLEAR wa_log.
    MOVE-CORRESPONDING <a> TO wa_log.
    wa_log-mandt = sy-mandt.
    INSERT zaudit_log FROM wa_log.
  ENDLOOP.

  " 7) Commit + clear NEWREC cho những dòng insert ok
  COMMIT WORK AND WAIT.

  DATA: lv_ins_cnt TYPE i,
        lv_upd_cnt TYPE i,
        lv_del_cnt TYPE i,          " có thể = 0 nếu DELE xử lý ở flow riêng
        lt_changes TYPE zty_change_tab.

  lv_ins_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT acc = acc + 1 ).
  lv_upd_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT acc = acc + 1 ).
  lv_del_cnt = REDUCE i( INIT acc = 0 FOR a IN gt_audit WHERE ( action = 'DELETE' ) NEXT acc = acc + 1 ).

  " Nếu bạn CHƯA map chi tiết thay đổi -> để lt_changes rỗng, mail vẫn gửi phần summary
  PERFORM notify_save_smtp
    USING    p_tab
             lv_ins_cnt
             lv_upd_cnt
             lv_del_cnt
    CHANGING lt_changes.


  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS ASSIGNED AND lt_ins_fp_ok IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        CLEAR lv_fp.
        PERFORM build_key_fingerprint USING <ls_data> gt_key_fields CHANGING lv_fp.
        IF lv_fp IS NOT INITIAL AND line_exists( lt_ins_fp_ok[ fp = lv_fp ] ).
          CLEAR <newrec>.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  CLEAR gt_changed_existing_keys.

  PERFORM resort_and_refresh_alv.
  " 7.1) Đồng bộ bản gốc để DISCARD khôi phục đúng phiên bản đã lưu
  FIELD-SYMBOLS: <lt_cur> TYPE STANDARD TABLE,
                 <lt_ori> TYPE STANDARD TABLE.

  ASSIGN gr_data->* TO <lt_cur>.
  IF <lt_cur> IS ASSIGNED.
    " Tạo vùng nhớ cho bản gốc có cùng kiểu
    CREATE DATA gr_data_original LIKE <lt_cur>.
    ASSIGN gr_data_original->* TO <lt_ori>.
    IF <lt_ori> IS ASSIGNED.
      <lt_ori> = <lt_cur>.   " snapshot sau khi SAVE
    ENDIF.
  ENDIF.

  " 8) Về View
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

  DATA(lv_ins) = REDUCE i( INIT x = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT x = x + 1 ).
  DATA(lv_upd) = REDUCE i( INIT y = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT y = y + 1 ).
  DATA(lv_cnt) = lines( <lt_to_save> ).
  MESSAGE |Đã lưu { lv_cnt } dòng (INSERT={ lv_ins }, UPDATE={ lv_upd }) và quay về chế độ xem.| TYPE 'S'.
ENDFORM.


*--------- delete ----------------------------
FORM delete_selected USING    iv_tab TYPE tabname
                     CHANGING ev_msg TYPE c
                              ev_err TYPE c.

  CLEAR: ev_msg, ev_err.

  " Ghi nhớ trạng thái để restore
  DATA lv_keep_edit TYPE abap_bool.
  IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
    lv_keep_edit = abap_true.
  ELSE.
    lv_keep_edit = abap_false.
  ENDIF.

  FIELD-SYMBOLS: <tab> TYPE STANDARD TABLE, <wa> TYPE any.
  ASSIGN gr_data->* TO <tab>.
  IF <tab> IS NOT ASSIGNED OR <tab> IS INITIAL.
    ev_err = 'Không có dữ liệu để xóa.'.
    RETURN.
  ENDIF.

  " Lấy selection hoặc dòng hiện tại
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_sel_idx TYPE lvc_s_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col.
  CLEAR lt_sel_idx.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index IS INITIAL.
      ev_err = 'Vui lòng chọn hoặc đặt con trỏ vào dòng cần xóa.'.
      RETURN.
    ENDIF.
    ls_sel_idx-index = ls_rowid-index.
    APPEND ls_sel_idx TO lt_sel_idx.
  ENDIF.

  " Đảo giảm dần để xóa không lệch
  SORT lt_sel_idx BY index DESCENDING.

  " Đảm bảo có key trong DDIC đối với xóa DB
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC — không thể xóa.'.
    RETURN.
  ENDIF.

  " Buffer audit
  REFRESH gt_audit.

  " Biến thống kê
  DATA: lv_deleted        TYPE i VALUE 0,  " xóa DB
        lv_newrec_deleted TYPE i VALUE 0.  " xóa chỉ trên lưới

  " Xử lý theo từng index
  FIELD-SYMBOLS: <newrec> TYPE any,
                 <comp>   TYPE any.
  DATA: lv_where  TYPE string,
        lv_we     TYPE string,
        lv_exists TYPE abap_bool.

  LOOP AT lt_sel_idx INTO ls_sel_idx.
    READ TABLE <tab> ASSIGNING <wa> INDEX ls_sel_idx-index.
    IF sy-subrc <> 0 OR <wa> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    " 1) NEWREC => xóa khỏi lưới
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <wa> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      DELETE <tab> INDEX ls_sel_idx-index.
      lv_newrec_deleted = lv_newrec_deleted + 1.
      CONTINUE.
    ENDIF.

    " 2) Dòng cũ => kiểm tra key đủ chưa
    DATA any_empty TYPE abap_bool VALUE abap_false.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kfld>).
      ASSIGN COMPONENT <kfld> OF STRUCTURE <wa> TO <comp>.
      IF sy-subrc = 0 AND <comp> IS INITIAL.
        any_empty = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF any_empty = abap_true.
      " không đủ khóa -> xóa khỏi lưới (không xóa DB)
      DELETE <tab> INDEX ls_sel_idx-index.
      CONTINUE.
    ENDIF.

    " Build WHERE từ khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <wa> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      ev_err = 'Không xây được điều kiện khóa để xóa.'.
      EXIT.
    ENDIF.

    " Tồn tại DB?
    CLEAR lv_exists.
    TRY.
        SELECT SINGLE @abap_true FROM (iv_tab) WHERE (lv_where) INTO @lv_exists.
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax1).
        ev_err = lx_syntax1->get_text( ).
        EXIT.
    ENDTRY.

    IF ev_err IS NOT INITIAL. EXIT. ENDIF.

    IF lv_exists = abap_true.
      " Lấy bản cũ để audit (CORRESPONDING để tránh thiếu field kỹ thuật)
      DATA lr_old TYPE REF TO data.
      CREATE DATA lr_old LIKE <wa>.
      FIELD-SYMBOLS <wa_old> TYPE any.
      ASSIGN lr_old->* TO <wa_old>.
      CLEAR <wa_old>.

      TRY.
          SELECT SINGLE * FROM (iv_tab) WHERE (lv_where)
            INTO CORRESPONDING FIELDS OF @<wa_old>.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax2).
          ev_err = lx_syntax2->get_text( ).
          EXIT.
      ENDTRY.
      IF ev_err IS NOT INITIAL. EXIT. ENDIF.
      IF sy-subrc <> 0. <wa_old> = <wa>. ENDIF.

      " Xóa DB
      TRY.
          DELETE FROM (iv_tab) WHERE (lv_where).
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syntax3).
          ev_err = lx_syntax3->get_text( ).
          EXIT.
      ENDTRY.
      IF sy-subrc <> 0.
        ev_err = 'Xóa DB thất bại cho 1 dòng; dừng lại.'.
        EXIT.
      ENDIF.

      DATA lv_del_err TYPE string.
      PERFORM delete_audit_log USING iv_tab <wa_old> CHANGING lv_del_err.  " Dùng <wa_old> hoặc <wa> (snapshot cũ)
      IF lv_del_err IS NOT INITIAL.
        ev_err = lv_del_err.
        EXIT.  " Hoặc ROLLBACK WORK nếu muốn rollback delete DB
      ENDIF.

      " Xóa trên lưới + audit
      DELETE <tab> INDEX ls_sel_idx-index.

      DATA ls_a TYPE ty_audit.
      CLEAR ls_a.
      ls_a-tabname = iv_tab.
      ls_a-action  = 'DELETE'.
      ls_a-uname   = sy-uname.
      ls_a-udate   = sy-datum.
      ls_a-utime   = sy-uzeit.
      PERFORM to_json USING <wa_old> CHANGING ls_a-before_json.
      CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a-logid.
      APPEND ls_a TO gt_audit.

      lv_deleted = lv_deleted + 1.

    ELSE.
      " Không còn DB -> xóa khỏi lưới
      DELETE <tab> INDEX ls_sel_idx-index.
    ENDIF.
  ENDLOOP.

  IF ev_err IS NOT INITIAL.
    ROLLBACK WORK.
    RETURN.
  ENDIF.

  " Ghi audit vào bảng log (nếu có)
  IF gt_audit IS NOT INITIAL.
    TYPES: BEGIN OF ty_audit_db,
             mandt       TYPE mandt,
             logid       TYPE char32,
             uname       TYPE syuname,
             udate       TYPE sydatum,
             utime       TYPE syuzeit,
             tabname     TYPE tabname,
             action      TYPE char10,
             before_json TYPE zde_json_txt,
             after_json  TYPE zde_json_txt,
           END OF ty_audit_db.
    DATA wa_log TYPE ty_audit_db.
    DATA lv_audit_tab TYPE tabname VALUE 'ZAUDIT_LOG'.

    FIELD-SYMBOLS <a> TYPE ty_audit.
    LOOP AT gt_audit ASSIGNING <a>.
      CLEAR wa_log.
      wa_log-mandt       = sy-mandt.
      wa_log-logid       = <a>-logid.
      wa_log-uname       = <a>-uname.
      wa_log-udate       = <a>-udate.
      wa_log-utime       = <a>-utime.
      wa_log-tabname     = <a>-tabname.
      wa_log-action      = <a>-action.
      wa_log-before_json = <a>-before_json.
      INSERT (lv_audit_tab) FROM wa_log.
    ENDLOOP.
  ENDIF.

  " Gửi mail thông báo DELETE (nếu có bản ghi bị xóa)
  IF lv_deleted > 0 AND gt_audit IS NOT INITIAL.
    DATA lt_dummy TYPE zty_change_tab.
    PERFORM notify_delete_smtp
      USING    iv_tab
      CHANGING lt_dummy.
  ENDIF.


  " Cập nhật trạng thái chung
  DATA lv_still_has_newrec TYPE abap_bool VALUE abap_false.
  LOOP AT <tab> ASSIGNING <wa>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <wa> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_still_has_newrec = abap_true.
      EXIT.
    ENDIF.
  ENDLOOP.

  ev_msg = |Đã xóa | && lv_deleted && | dòng DB và | &&
           lv_newrec_deleted && | dòng NEWREC.|.

  gv_dirty    = abap_false.
  gv_add_mode = COND #( WHEN lv_still_has_newrec = abap_true THEN abap_true ELSE abap_false ).
  IF lv_keep_edit = abap_true.
    gv_edit_md      = abap_true.
    gv_toolbar_mode = 'E'.
  ELSE.
    gv_edit_md      = abap_false.
    gv_toolbar_mode = 'D'.
  ENDIF.

  " Áp lại style (xám khóa, audit…), rồi caller sẽ refresh
  PERFORM apply_editability_and_push.

  " Nếu còn NEWREC thì focus vào key
  IF lv_still_has_newrec = abap_true.
    PERFORM focus_key_on_newrec.
  ENDIF.
ENDFORM.




*-------------------------------------------------------------*
* Popup hiển thị log rollback
*-------------------------------------------------------------*
FORM show_audit_log_popup USING iv_tab TYPE tabname.
  DATA: lt_log      TYPE STANDARD TABLE OF zaudit_log,
        ls_log      TYPE zaudit_log,
        ls_selfield TYPE slis_selfield.

  SELECT *
  FROM zaudit_log
  INTO TABLE @lt_log
  WHERE tabname = @iv_tab
  ORDER BY udate DESCENDING, utime DESCENDING.

  IF lt_log IS INITIAL.
    MESSAGE 'Không có log nào để rollback' TYPE 'I'.
    RETURN.
  ENDIF.

  CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
    EXPORTING
      i_title               = |Chọn log rollback cho bảng { iv_tab }|
      i_zebra               = 'X'
      i_screen_start_column = 10
      i_screen_start_line   = 5
      i_screen_end_column   = 100
      i_screen_end_line     = 20
    IMPORTING
      es_selfield           = ls_selfield
    TABLES
      t_outtab              = lt_log
    EXCEPTIONS
      OTHERS                = 1.

  IF sy-subrc = 0 AND ls_selfield-tabindex > 0.
    READ TABLE lt_log INDEX ls_selfield-tabindex INTO ls_log.
    IF sy-subrc = 0.
      PERFORM rollback_from_log USING ls_log.
    ENDIF.
  ENDIF.
ENDFORM.

*-------------------------------------------------------------*
* Rollback từ 1 log
*-------------------------------------------------------------*
FORM rollback_from_log USING is_log TYPE zaudit_log.
  DATA: lr_before    TYPE REF TO data,
        lr_curr_data TYPE REF TO data,
        lv_err       TYPE string,
        lv_mod       TYPE i,
        lv_json      TYPE zde_json_txt,
        lv_curr_json TYPE zde_json_txt.

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <ls_curr> TYPE any.

  IF is_log-tabname IS INITIAL.
    MESSAGE 'Tên bảng không được để trống' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_json = is_log-before_json.
  IF lv_json IS INITIAL AND is_log-action <> 'INSERT'.
    MESSAGE 'JSON trước đó rỗng, không thể rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM json_to_itab USING is_log-tabname lv_json CHANGING lr_before.
  ASSIGN lr_before->* TO <lt>.
  IF <lt> IS NOT ASSIGNED.
    MESSAGE 'Không parse được JSON để rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_dyn_itab USING is_log-tabname CHANGING lr_curr_data.
  IF lr_curr_data IS NOT BOUND.
    MESSAGE 'Không tạo được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  ASSIGN lr_curr_data->* TO <lt_curr>.
  IF <lt_curr> IS NOT ASSIGNED.
    MESSAGE 'Không assign được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING is_log-tabname.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_curr>.
  DATA: lo_tabledesc TYPE REF TO cl_abap_tabledescr,
        lo_linedesc  TYPE REF TO cl_abap_structdescr.
  lo_tabledesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_before ).
  lo_linedesc  ?= lo_tabledesc->get_table_line_type( ).

  LOOP AT <lt> ASSIGNING <ls>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      MESSAGE |Không xây được điều kiện khóa: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    DATA lr_line TYPE REF TO data.
    CREATE DATA lr_line TYPE HANDLE lo_linedesc.
    ASSIGN lr_line->* TO <ls_curr>.
    IF <ls_curr> IS NOT ASSIGNED.
      MESSAGE 'Không tạo được cấu trúc dòng cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    TRY.
        SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_rb1).
        MESSAGE lx_rb1->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.
    IF sy-subrc = 0.
      APPEND <ls_curr> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  IF <lt_curr> IS NOT INITIAL.
    /ui2/cl_json=>serialize(
      EXPORTING data        = <lt_curr>
                pretty_name = /ui2/cl_json=>pretty_mode-none
      RECEIVING r_json      = lv_curr_json ).
  ELSE.
    lv_curr_json = '[]'.
  ENDIF.

  PERFORM save_data USING is_log-tabname
                    CHANGING lr_before lv_mod lv_err.

  IF lv_err IS INITIAL.
    DATA: lv_newlogid TYPE char32,
          ls_new      TYPE zaudit_log.
    CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = lv_newlogid.

    CLEAR ls_new.
    ls_new-mandt       = sy-mandt.
    ls_new-logid       = lv_newlogid.
    ls_new-uname       = sy-uname.
    ls_new-udate       = sy-datum.
    ls_new-utime       = sy-uzeit.
    ls_new-tabname     = is_log-tabname.
    ls_new-action      = 'ROLLBACK'.
    ls_new-before_json = lv_curr_json.
    ls_new-after_json  = lv_json.

    INSERT zaudit_log FROM ls_new.
    COMMIT WORK AND WAIT.
    gv_dirty = abap_false.
    DATA lv_subj TYPE so_obj_des.
    DATA lv_mail_rc TYPE i.
    lv_subj = |[RB OK] { is_log-tabname } LOG { lv_newlogid(8) }|.
    PERFORM send_mail_min USING lv_subj 'thanhchse171611@fpt.edu.vn'.
    lv_mail_rc = sy-subrc.
  ELSE.
    ROLLBACK WORK.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail tối giản (raw)
*---------------------------------------------------------------------*
FORM send_mail_min USING iv_subject TYPE so_obj_des
iv_to TYPE ad_smtpadr.
  DATA: lo_req      TYPE REF TO cl_bcs,
        lo_doc      TYPE REF TO cl_document_bcs,
        lo_rcpt     TYPE REF TO if_recipient_bcs,
        lt_text     TYPE bcsy_text,
        ls_line     LIKE LINE OF lt_text,
        lv_to_local TYPE ad_smtpadr.

  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

  CLEAR lt_text.
  ls_line-line = |Rollback thành công từ { sy-repid } (user { sy-uname }).|.
  APPEND ls_line TO lt_text.

  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'RAW'
                 i_text    = lt_text
                 i_subject = iv_subject ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " (A) TẮT thông báo trạng thái gửi (không nhận status mail/express)
      lo_req->set_status_attributes(
        i_requested_status = 'N'  " no MDN/status request
        i_status_mail      = 'N'    " no status mail back to sender
      ).

      " (B) GỬI CHO BẠN VÀO SBWP NHƯNG KHÔNG EXPRESS (=> KHÔNG POPUP)
      lo_req->add_recipient(
        i_recipient = cl_sapuser_bcs=>create( sy-uname )
        i_express   = abap_false ).

      " (C) GỬI RA EMAIL INTERNET – cũng KHÔNG express
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient = lo_rcpt
        i_express   = abap_false
        i_copy      = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Restore data từ JSON (dùng cho rollback)
*---------------------------------------------------------------------*
FORM restore_data USING iv_tabname TYPE tabname
                        iv_json    TYPE zde_json_txt
                  CHANGING ev_err  TYPE string
                           ev_mod  TYPE i.

  DATA: lr_data  TYPE REF TO data,
        lv_where TYPE string,
        lv_msg   TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any.

  CLEAR: ev_err, ev_mod.

  PERFORM json_to_itab USING iv_tabname iv_json CHANGING lr_data.
  ASSIGN lr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    ev_err = |Không parse được JSON để restore cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING iv_tabname.
  IF gt_key_fields IS INITIAL.
    ev_err = |Không tìm thấy key fields cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields
      CHANGING lv_where lv_msg.
    IF lv_where IS INITIAL.
      ev_err = |Không tạo được WHERE: { lv_msg }|.
      RETURN.
    ENDIF.

    TRY.
        DELETE FROM (iv_tabname) WHERE (lv_where).
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_r1).
        ev_err = lx_r1->get_text( ).
        RETURN.
    ENDTRY.

    INSERT (iv_tabname) FROM <ls_data>.
    IF sy-subrc = 0.
      ev_mod = ev_mod + 1.
    ELSE.
      ev_err = |Không insert được dòng trong { iv_tabname } với WHERE { lv_where }|.
      RETURN.
    ENDIF.
  ENDLOOP.
ENDFORM.

*-------------------------------------------------------------*
* JSON -> itab động (rollback) – đồng bộ pretty_mode = none
*-------------------------------------------------------------*
FORM json_to_itab USING iv_tab  TYPE tabname
                        iv_json TYPE zde_json_txt
                  CHANGING cr_data TYPE REF TO data.
  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_any    TYPE REF TO data,
        lr_row    TYPE REF TO data.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  TRY.
      lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
      lo_table  = cl_abap_tabledescr=>create( lo_struct ).
      CREATE DATA lr_any TYPE HANDLE lo_table.
      ASSIGN lr_any->* TO <lt_data>.

      /ui2/cl_json=>deserialize(
  EXPORTING json        = iv_json
            pretty_name = /ui2/cl_json=>pretty_mode-none
  CHANGING  data        = <lt_data> ).

      IF <lt_data> IS INITIAL.
        CREATE DATA lr_row TYPE HANDLE lo_struct.
        ASSIGN lr_row->* TO <ls_row>.
        /ui2/cl_json=>deserialize(
          EXPORTING json        = iv_json
                    pretty_name = /ui2/cl_json=>pretty_mode-none
          CHANGING  data        = <ls_row> ).
        APPEND <ls_row> TO <lt_data>.
      ENDIF.

      cr_data = lr_any.
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail cho manager
*---------------------------------------------------------------------*
FORM get_manager_for_tab
  USING    iv_tabname       TYPE tabname
  CHANGING ev_manager_user  TYPE syuname
           ev_manager_email TYPE ad_smtpadr.

  CLEAR: ev_manager_user.
  CLEAR: ev_manager_email.

  SELECT SINGLE
         manager_uname,
         manager_email
    FROM ztab_manager
    WHERE tabname = @iv_tabname
      AND ( active = 'X' OR active IS INITIAL )
    INTO (@ev_manager_user, @ev_manager_email).

ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail sau khi rollback – (wrapper, có fallback) — FINAL (SO_OBJ_DES)
*---------------------------------------------------------------------*
FORM notify_rollback_smtp
  USING is_log       TYPE zaudit_log
        iv_mod       TYPE i
        iv_curr_json TYPE zde_json_txt
        iv_prev_json TYPE zde_json_txt
        iv_note      TYPE string.

  DATA: lv_manager_user  TYPE syuname,
        lv_manager_email TYPE ad_smtpadr,
        lv_to            TYPE ad_smtpadr.

  " 1) Lấy manager theo bảng
  PERFORM get_manager_for_tab
    USING    is_log-tabname
    CHANGING lv_manager_user
             lv_manager_email.

  " 2) Quy tắc chọn người nhận
  IF lv_manager_email IS NOT INITIAL.
    lv_to = lv_manager_email.               " gửi cho manager (email)
  ELSE.
    lv_to = 'thanhchse171611@fpt.edu.vn'.   " fallback của bạn
  ENDIF.

  " 3) Gọi đúng FORM đã build HTML & gửi mail sẵn
  "    CHÚ Ý: send_mail_rb_detail có thứ tự:
  "    (tab, logid, rows, to, json_curr, json_after, note)
PERFORM send_mail_rb_detail
  USING is_log-tabname        " iv_tab
        is_log-logid          " iv_logid
        iv_mod                " iv_rows
        lv_to                 " iv_to
        iv_curr_json          " iv_json_curr
        iv_prev_json          " iv_json_after
        iv_note               " iv_note
        ''                    " iv_subject_override (để trống -> dùng subject rollback mặc định)
        ''.                   " iv_html_override    (để trống -> build body rollback mặc định)


ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail rollback chi tiết (HTML) – có hỗ trợ override cho SAVE
*---------------------------------------------------------------------*
FORM send_mail_rb_detail
  USING iv_tab               TYPE tabname
        iv_logid             TYPE zaudit_log-logid
        iv_rows              TYPE i
        iv_to                TYPE ad_smtpadr
        iv_json_curr         TYPE zde_json_txt
        iv_json_after        TYPE zde_json_txt
        iv_note              TYPE string
        iv_subject_override  TYPE so_obj_des
        iv_html_override     TYPE string.

  DATA: lo_req        TYPE REF TO cl_bcs,
        lo_doc        TYPE REF TO cl_document_bcs,
        lo_rcpt       TYPE REF TO if_recipient_bcs,
        lo_rcptso     TYPE REF TO if_recipient_bcs,
        lt_body       TYPE bcsy_text,
        lv_subj       TYPE so_obj_des,
        lv_html       TYPE string,
*        lv_curr_html  TYPE string,
*        lv_after_html TYPE string,
        lv_to_local   TYPE ad_smtpadr.

  " Resolve người nhận
  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    " TODO: thay bằng hằng gc_hard_rcpt nếu bạn đã khai báo trong TOP
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

*  " Escape + cắt JSON (đề phòng trường hợp dùng build mặc định)
*  PERFORM _html_escape     USING iv_json_curr  CHANGING lv_curr_html.
*  PERFORM _html_escape     USING iv_json_after CHANGING lv_after_html.
*  PERFORM _ellipsize_html  USING lv_curr_html  8000 CHANGING lv_curr_html.
*  PERFORM _ellipsize_html  USING lv_after_html 8000 CHANGING lv_after_html.

  " Subject: ưu tiên override (dùng cho SAVE); nếu rỗng -> subject rollback mặc định
  IF iv_subject_override IS NOT INITIAL.
    lv_subj = iv_subject_override.
  ELSE.
    lv_subj = |[ROLLBACK OK] { iv_tab } - LOG { iv_logid(8) } - { iv_rows } row(s)|.
  ENDIF.

  " Body HTML:
  " - Nếu caller truyền iv_html_override (SAVE) -> dùng nguyên xi
  " - Ngược lại -> build mặc định cho rollback (meta + note + diff)
  IF iv_html_override IS INITIAL.

    " Header + meta (rollback)
    lv_html =
      |<html><head><meta charset="utf-8"></head>| &&
      |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
      |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
      |<h3 style="font-size:16px;margin:0 0 8px 0">Rollback thành công | &&
      |<span style="display:inline-block;padding:2px 8px;border-radius:999px;background:#e2f3e8;color:#065f46;font-size:12px">{ iv_rows } row(s)</span>| &&
      |</h3>| &&
      |<table style="border-collapse:collapse">| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Bảng</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tab }</td></tr>| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Log ID</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_logid }</td></tr>| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Người thực hiện</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Chương trình</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-repid }</td></tr>| &&
      |<tr><td style="padding:4px 8px;vertical-align:top"><b>Thời gian</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
      |</table></div>|.

    " NOTE (batch details) nếu có
    IF iv_note IS NOT INITIAL.
      DATA(lv_note_html) = iv_note.
      PERFORM _html_escape     USING lv_note_html CHANGING lv_note_html.
      PERFORM _ellipsize_html  USING lv_note_html 4000 CHANGING lv_note_html.
      lv_html = lv_html &&
        |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
        |<h4 style="margin:0 0 8px 0;font-size:14px">Batch details</h4>| &&
        |<pre style="white-space:pre-wrap;font-family:Consolas,Menlo,monospace;font-size:12px;margin:0">| &&
        lv_note_html &&
        |</pre></div>|.
    ENDIF.

    " Diff HTML
    DATA lv_diff_html TYPE string.
*    PERFORM build_html_diff USING    iv_tab
*                                     lv_curr_html
*                                     lv_after_html
*                            CHANGING lv_diff_html.

    PERFORM build_html_diff USING    iv_tab
                                 iv_json_curr
                                 iv_json_after
                        CHANGING lv_diff_html.
    lv_html = lv_html && lv_diff_html && |</body></html>|.

  ELSE.
    " Dùng body override do caller truyền vào (SAVE)
    lv_html = iv_html_override.
  ENDIF.

  " Convert HTML string -> bcsy_text
  PERFORM _string_to_bcs_text USING lv_html CHANGING lt_body.

  " Gửi qua BCS
  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'HTM'
                 i_text    = lt_body
                 i_subject = lv_subj ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " Tắt status notification
      lo_req->set_status_attributes(
        i_requested_status = 'N'
        i_status_mail      = 'N' ).

      " SBWP: người đang chạy, không express
      lo_rcptso = cl_sapuser_bcs=>create( sy-uname ).
      lo_req->add_recipient(
        i_recipient = lo_rcptso
        i_express   = abap_false ).

      " Email Internet: người nhận chính, không express/cc/bcc
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient  = lo_rcpt
        i_express    = abap_false
        i_copy       = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Helper: chọn người nhận notify (owner > manager > fallback)
*---------------------------------------------------------------------*
FORM get_notify_recipient
  USING    iv_tabname TYPE tabname
  CHANGING ev_to      TYPE ad_smtpadr.

  DATA: lv_owner_to TYPE ad_smtpadr,
        lv_mgr_u    TYPE syuname,
        lv_mgr_to   TYPE ad_smtpadr.

  CLEAR: ev_to, lv_owner_to, lv_mgr_u, lv_mgr_to.

  " Manager map từ ztab_manager
  PERFORM get_manager_for_tab USING iv_tabname CHANGING lv_mgr_u lv_mgr_to.

  IF lv_owner_to IS NOT INITIAL.
    ev_to = lv_owner_to.
  ELSEIF lv_mgr_to IS NOT INITIAL.
    ev_to = lv_mgr_to.
  ELSE.
    ev_to = gc_hard_rcpt.  " hằng fallback đã khai trong TOP
  ENDIF.

ENDFORM.




*---------------------------------------------------------------------*
* Gửi mail sau khi SAVE (summary + chi tiết như rollback)
* Dùng build_html_diff (JSON thô) cho từng record trong gt_audit
*---------------------------------------------------------------------*
FORM notify_save_smtp
  USING    iv_tabname TYPE tabname
           iv_ins     TYPE i
           iv_upd     TYPE i
           iv_del     TYPE i
  CHANGING ct_changes TYPE zty_change_tab.

  DATA: lv_subject   TYPE so_obj_des,
        lv_html      TYPE string,
        lv_to        TYPE ad_smtpadr,
        lv_rows      TYPE i,
        lv_cnt       TYPE i VALUE 0,
        lv_max_rows  TYPE i VALUE 50. " giới hạn số record hiển thị chi tiết

  " 0) Không thay đổi -> thôi
  lv_rows = iv_ins + iv_upd + iv_del.
  IF lv_rows = 0.
    RETURN.
  ENDIF.

  " 1) Người nhận (tạm fallback; nếu có mapping thì thay vào đây)
*  lv_to = gc_hard_rcpt.
  PERFORM get_notify_recipient USING iv_tabname CHANGING lv_to.

  " 2) Subject override cho SAVE
  lv_subject = |[SAVE] { iv_tabname }_ After SAVE|.

  " 3) Header + summary
  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">Thay đổi sau khi SAVE</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Bảng</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tabname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Người thực hiện</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Thời điểm</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
    |</table></div>| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
    |<p style="margin:0"><b>Tổng kết:</b> +{ iv_ins } thêm, ~{ iv_upd } sửa, –{ iv_del } xóa</p>| &&
    |</div>|.

  " 4) Chi tiết từng record: dùng JSON THÔ từ gt_audit -> build_html_diff
  FIELD-SYMBOLS <a> TYPE ty_audit.
  LOOP AT gt_audit ASSIGNING <a> WHERE tabname = iv_tabname.
    ADD 1 TO lv_cnt.
    IF lv_cnt > lv_max_rows.
      lv_html = lv_html &&
        |<div style="margin-top:8px;color:#6b7280;font-size:12px"><i>(Rút gọn… chỉ hiển thị { lv_max_rows } bản ghi đầu tiên)</i></div>|.
      EXIT.
    ENDIF.

    DATA(lv_diff_html) = VALUE string( ).
    " LƯU Ý: truyền JSON thô (KHÔNG escape/cắt trước)
    PERFORM build_html_diff USING    iv_tabname
                                     <a>-before_json   " có thể rỗng với INSERT
                                     <a>-after_json    " có thể rỗng với DELETE
                            CHANGING lv_diff_html.

    lv_html = lv_html && lv_diff_html.
  ENDLOOP.

  lv_html = lv_html && |</body></html>|.

  " 5) Gửi mail dùng form rollback (subject/body override)
  PERFORM send_mail_rb_detail
    USING iv_tabname
          space                 " iv_logid (SAVE không có -> SPACE)
          lv_rows
          lv_to
          ''                    " iv_json_curr (không dùng khi override)
          ''                    " iv_json_after
          ''                    " iv_note
          lv_subject            " override subject
          lv_html.              " override body

ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail sau khi DELETE (summary + chi tiết như rollback)
*---------------------------------------------------------------------*
FORM notify_delete_smtp
  USING    iv_tabname TYPE tabname
  CHANGING ct_changes TYPE zty_change_tab.

  DATA: lv_subject  TYPE so_obj_des,
        lv_html     TYPE string,
        lv_to       TYPE ad_smtpadr,
        lv_rows     TYPE i,
        lv_cnt      TYPE i VALUE 0,
        lv_max_rows TYPE i VALUE 50.

  " Đếm số DELETE trong batch hiện tại
  lv_rows = REDUCE i( INIT x = 0 FOR a IN gt_audit
                      WHERE ( tabname = iv_tabname AND action = 'DELETE' )
                      NEXT x = x + 1 ).
  IF lv_rows = 0.
    RETURN.
  ENDIF.

  " Người nhận (fallback; có mapping thì thay ở đây)
*  lv_to = gc_hard_rcpt.
  PERFORM get_notify_recipient USING iv_tabname CHANGING lv_to.
  " PERFORM get_manager_for_tab USING iv_tabname CHANGING lv_to. " nếu có

  " Subject
  lv_subject = |[DELETE] { iv_tabname } –{ lv_rows } by { sy-uname } at { sy-uzeit }|.

  " Header + summary
  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">Xóa dữ liệu (DELETE)</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Bảng</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tabname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Người thực hiện</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Thời điểm</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
    |</table></div>| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
    |<p style="margin:0"><b>Tổng kết:</b> –{ lv_rows } xóa</p>| &&
    |</div>|.

  " Chi tiết từng record DELETE: dùng JSON thô (before có, after rỗng)
  FIELD-SYMBOLS <a> TYPE ty_audit.
  LOOP AT gt_audit ASSIGNING <a>
       WHERE tabname = iv_tabname AND action = 'DELETE'.
    ADD 1 TO lv_cnt.
    IF lv_cnt > lv_max_rows.
      lv_html = lv_html &&
        |<div style="margin-top:8px;color:#6b7280;font-size:12px"><i>(Rút gọn… chỉ hiển thị { lv_max_rows } bản ghi đầu tiên)</i></div>|.
      EXIT.
    ENDIF.

    DATA(lv_diff_html) = VALUE string( ).
    PERFORM build_html_diff USING    iv_tabname
                                     <a>-before_json   " JSON thô
                                     ''                " after rỗng cho DELETE
                            CHANGING lv_diff_html.
    lv_html = lv_html && lv_diff_html.
  ENDLOOP.

  lv_html = lv_html && |</body></html>|.

  " Gửi (override subject/body)
  PERFORM send_mail_rb_detail
    USING iv_tabname space lv_rows lv_to '' '' '' lv_subject lv_html.

ENDFORM.


*---------------------------------------------------------------------*
* Helper: string -> bcsy_text (manual SPLIT 255 ký tự/line)
*---------------------------------------------------------------------*
FORM _string_to_bcs_text USING iv_str TYPE string
CHANGING ct_text TYPE bcsy_text.
  DATA: lv_off  TYPE i VALUE 0,
        lv_len  TYPE i,
        lv_take TYPE i,
        ls      TYPE soli.
  CLEAR ct_text.
  lv_len = strlen( iv_str ).
  WHILE lv_off < lv_len.
    lv_take = lv_len - lv_off.
    IF lv_take > 255.
      lv_take = 255.
    ENDIF.
    CLEAR ls.
    ls-line = iv_str+lv_off(lv_take).
    APPEND ls TO ct_text.
    lv_off = lv_off + lv_take.
  ENDWHILE.
  IF ct_text IS INITIAL.
    CLEAR ls.
    APPEND ls TO ct_text.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: escape tối thiểu để nhúng json vào html safely
*---------------------------------------------------------------------*
FORM _html_escape USING iv_in TYPE string
CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '&' IN cv_out WITH '&amp;'.
  REPLACE ALL OCCURRENCES OF '<' IN cv_out WITH '&lt;'.
  REPLACE ALL OCCURRENCES OF '>' IN cv_out WITH '&gt;'.
  REPLACE ALL OCCURRENCES OF '"' IN cv_out WITH '&quot;'.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH '&#39;'.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: rút gọn string nếu vượt max_len (thêm "... (truncated)")
*---------------------------------------------------------------------*
FORM _ellipsize_html USING iv_in TYPE string
iv_max_len TYPE i
CHANGING cv_out TYPE string.
  DATA: lv_len  TYPE i, lv_max TYPE i, lv_take TYPE i.
  lv_max = iv_max_len.
  IF lv_max IS INITIAL OR lv_max < 1000.
    lv_max = 1000.
  ENDIF.
  lv_len = strlen( iv_in ).
  IF lv_len > lv_max.
    lv_take = lv_max - 15.
    IF lv_take < 0.
      lv_take = 0.
    ENDIF.
    cv_out = iv_in+0(lv_take).
    cv_out = cv_out && |... (truncated)|.
  ELSE.
    cv_out = iv_in.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
*  Build HTML diff (COMPACT TABLE): 1 record -> 1 bảng ngang
*   Header:  Mô tả | <Field 1> | <Field 2> | ...
*   Body:    Before | ...values...   (ô khác biệt tô đỏ nhạt)
*            After  | ...values...   (ô khác biệt tô xanh nhạt)
*---------------------------------------------------------------------*
FORM build_html_diff USING    iv_tab        TYPE tabname
                              iv_json_curr  TYPE zde_json_txt
                              iv_json_after TYPE zde_json_txt
                     CHANGING cv_html       TYPE string.

  DATA: lr_data_curr  TYPE REF TO data,
        lr_data_after TYPE REF TO data,
        lt_fieldinfo  TYPE TABLE OF dfies,
        ls_field      TYPE dfies,
        lv_tab_up     TYPE tabname.

  FIELD-SYMBOLS: <lt_curr>  TYPE STANDARD TABLE,
                 <lt_after> TYPE STANDARD TABLE,
                 <ls_curr>  TYPE any,
                 <ls_after> TYPE any,
                 <old>      TYPE any,
                 <new>      TYPE any.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Biến key (PHẢI là string để dùng CHANGING)
  DATA: lv_kc  TYPE string,
        lv_ka  TYPE string,
        lv_key TYPE string.

  " Tổng số field changed (cho legend cuối mail)
  DATA lv_changed_total TYPE i VALUE 0.

  " -- upper-case bảng
  lv_tab_up = iv_tab.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " 0) DDIC describe & field info
  lo_struct ?= cl_abap_typedescr=>describe_by_name( lv_tab_up ).
  IF lo_struct IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>Cannot describe DDIC structure.</i></div>'.
    RETURN.
  ENDIF.
  lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = lv_tab_up
      all_types = 'X'
    TABLES
      dfies_tab = lt_fieldinfo
    EXCEPTIONS
      OTHERS    = 1.
  IF lt_fieldinfo IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No DDIC field info for table.</i></div>'.
    RETURN.
  ENDIF.

  " 1) JSON -> itab động (có thể rỗng)
  PERFORM json_to_itab USING lv_tab_up iv_json_curr  CHANGING lr_data_curr.
  PERFORM json_to_itab USING lv_tab_up iv_json_after CHANGING lr_data_after.
  IF lr_data_curr IS BOUND.  ASSIGN lr_data_curr->*  TO <lt_curr>.  ENDIF.
  IF lr_data_after IS BOUND. ASSIGN lr_data_after->* TO <lt_after>. ENDIF.

  IF ( <lt_curr>  IS NOT ASSIGNED OR <lt_curr>  IS INITIAL )
 AND ( <lt_after> IS NOT ASSIGNED OR <lt_after> IS INITIAL ).
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No parsable data for diff (both before/after empty).</i></div>'.
    RETURN.
  ENDIF.

  " 2) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING lv_tab_up IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key fields in DDIC.</i></div>'.
    RETURN.
  ENDIF.

  " 3) Hợp nhất các KEY từ cả Before/After
  DATA: lt_all_keys TYPE SORTED TABLE OF string WITH UNIQUE KEY table_line.
  IF <lt_curr> IS ASSIGNED.
    LOOP AT <lt_curr> ASSIGNING <ls_curr>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF <lt_after> IS ASSIGNED.
    LOOP AT <lt_after> ASSIGNING <ls_after>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_after> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF lt_all_keys IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key found to pair rows.</i></div>'.
    RETURN.
  ENDIF.

  " 4) Render: mỗi KEY = 1 bảng ngang (1 header + 2 dòng Before/After)
  CLEAR cv_html.
  DATA: lv_block  TYPE string,
        lv_tbl    TYPE string,
        lv_head   TYPE string,
        lv_row_b  TYPE string,
        lv_row_a  TYPE string,
        lv_title  TYPE string,
        lv_desc   TYPE string,
        lv_desc_h TYPE string,
        lv_old    TYPE string,
        lv_new    TYPE string,
        lv_old_h  TYPE string,
        lv_new_h  TYPE string,
        lv_cnt    TYPE i VALUE 0.

  LOOP AT lt_all_keys INTO lv_key.
    ADD 1 TO lv_cnt.

    " — Tìm bản ghi theo KEY ở Before / After
    UNASSIGN: <ls_curr>, <ls_after>.
    IF <lt_curr> IS ASSIGNED.
      LOOP AT <lt_curr> ASSIGNING <ls_curr>.
        CLEAR lv_kc.
        PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_kc.
        IF lv_kc = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.
    IF <lt_after> IS ASSIGNED.
      LOOP AT <lt_after> ASSIGNING <ls_after>.
        CLEAR lv_ka.
        PERFORM _make_key_str_any USING <ls_after> CHANGING lv_ka.
        IF lv_ka = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.

    " Nếu thiếu 1 phía -> tạo struct rỗng để vẫn render
    IF <ls_curr>  IS NOT ASSIGNED.
      DATA lr_zero_c TYPE REF TO data.
      CREATE DATA lr_zero_c TYPE HANDLE lo_struct.
      ASSIGN lr_zero_c->* TO <ls_curr>.
      CLEAR <ls_curr>.
    ENDIF.
    IF <ls_after> IS NOT ASSIGNED.
      DATA lr_zero_a TYPE REF TO data.
      CREATE DATA lr_zero_a TYPE HANDLE lo_struct.
      ASSIGN lr_zero_a->* TO <ls_after>.
      CLEAR <ls_after>.
    ENDIF.

    " — Title record
    lv_title = |Record { lv_cnt } — KEY [{ lv_key }]|.
    lv_block =
      '<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">'
   && |<div style="font-weight:600;font-size:14px;margin-bottom:10px">{ lv_title }</div>|
   && '<div style="overflow-x:auto">'
   && '<table style="border-collapse:collapse;min-width:720px;font-family:Arial,sans-serif;font-size:12px">'.

    " — Header (nền tối, chữ trắng)
    lv_head =
  '<tr>'
&& '<th style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left">Mô tả</th>'.

    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      " chọn nhãn dễ đọc
      lv_desc = ls_field-scrtext_l.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_m. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_s. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldtext.  ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldname.  ENDIF.
      PERFORM _html_escape USING lv_desc CHANGING lv_desc_h.

      lv_head &&=
        |<th style="background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left;white-space:nowrap">{ lv_desc_h }</th>|.
    ENDLOOP.
    lv_head &&= '</tr>'.

    " — Row BEFORE
    lv_row_b =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">Before</td>'.

    " — Row AFTER
    lv_row_a =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">After</td>'.

    " — Fill cells & đánh dấu thay đổi theo ô
    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      CLEAR: lv_old, lv_new, lv_old_h, lv_new_h.

      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_curr>  TO <old>.
      IF <old> IS ASSIGNED. lv_old = <old>. ENDIF.
      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_after> TO <new>.
      IF <new> IS ASSIGNED. lv_new = <new>. ENDIF.

      PERFORM _html_escape USING lv_old CHANGING lv_old_h.
      PERFORM _html_escape USING lv_new CHANGING lv_new_h.

      DATA(lv_changed) = xsdbool( lv_old_h <> lv_new_h ).
      IF lv_changed = abap_true.
        lv_changed_total = lv_changed_total + 1.
      ENDIF.

      " Before-cell (đỏ nhạt nếu đổi)
      lv_row_b &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#FEE2E2;color:#991B1B;' ELSE '' )
       && |">{ lv_old_h }</td>|.

      " After-cell (xanh nhạt nếu đổi)
      lv_row_a &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#D1FAE5;color:#065F46;' ELSE '' )
       && |">{ lv_new_h }</td>|.
    ENDLOOP.

    lv_row_b &&= '</tr>'.
    lv_row_a &&= '</tr>'.

    lv_tbl = lv_head && lv_row_b && lv_row_a && '</table></div>'. " đóng table + overflow

    " — Gộp block
    lv_block &&= lv_tbl && '</div>'.
    cv_html  &&= lv_block.
  ENDLOOP.

  " Legend
  cv_html &&=
    |<div style="margin-top:8px;font-size:12px;color:#374151">|
 && |<b>{ lv_changed_total }</b> field(s) changed across records. |
 && |<span style="display:inline-block;margin-left:8px;padding:2px 6px;background:#FEE2E2;color:#991B1B;border-radius:999px">Before changed</span>|
 && |<span style="display:inline-block;margin-left:6px;padding:2px 6px;background:#D1FAE5;color:#065F46;border-radius:999px">After changed</span>|
 && |</div>|.

ENDFORM.


*---------------------------------------------------------------------*
* Tạo KEY string ổn định từ 1 dòng dựa trên gt_key_fields
*---------------------------------------------------------------------*
FORM _make_key_str_any
  USING    is_row TYPE any
  CHANGING cv_key TYPE string.

  DATA: lv_name TYPE dd03l-fieldname,
        lv_tmp  TYPE string,
        lv_part TYPE string.
  FIELD-SYMBOLS: <v> TYPE any.

  CLEAR cv_key.
  LOOP AT gt_key_fields INTO lv_name.
    ASSIGN COMPONENT lv_name OF STRUCTURE is_row TO <v>.
    CLEAR lv_part.
    IF sy-subrc = 0 AND <v> IS ASSIGNED.
      lv_tmp = <v>.
      TRANSLATE lv_tmp TO UPPER CASE.
      CONDENSE  lv_tmp NO-GAPS.
      lv_part = lv_tmp.
    ENDIF.
    IF cv_key IS INITIAL.
      cv_key = lv_part.
    ELSE.
      CONCATENATE cv_key lv_part INTO cv_key SEPARATED BY '|'.
    ENDIF.
  ENDLOOP.

ENDFORM.


*---------------------------------------------------------------------*
*  Get Data Element short text (DD04T-DDTEXT)
*---------------------------------------------------------------------*
FORM get_dtel_text USING    iv_rollname TYPE rollname
                   CHANGING cv_text     TYPE string.

  DATA ls_dd04v TYPE dd04v.

  CALL FUNCTION 'DDIF_DTEL_GET'
    EXPORTING
      name     = iv_rollname
    IMPORTING
      dd04v_wa = ls_dd04v
    EXCEPTIONS
      OTHERS   = 1.

  IF sy-subrc = 0 AND cv_text IS INITIAL AND ls_dd04v-ddtext IS NOT INITIAL.
    cv_text = ls_dd04v-ddtext.
  ENDIF.

ENDFORM.





*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
FORM check_unsaved_changes CHANGING ev_has_change TYPE abap_bool.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.

  ev_has_change = abap_false.

  " Nếu đang ở Add/Edit thì mới cần cảnh báo
  IF gv_add_mode = abap_true OR gv_edit_md = abap_true.

    " 1) Nếu đã có cờ bẩn => coi như chưa lưu
    IF gv_dirty = abap_true.
      ev_has_change = abap_true.
      RETURN.
    ENDIF.

    " 2) Hoặc có dòng NEWREC chưa lưu
    ASSIGN gr_data->* TO <lt_data>.
    IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
      LOOP AT <lt_data> ASSIGNING <ls_data>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          ev_has_change = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.

FORM analyze_change_state CHANGING cv_new_incomplete TYPE abap_bool
cv_other_changes  TYPE abap_bool.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_has_newrec      TYPE abap_bool VALUE abap_false,
        lv_all_keys_filled TYPE abap_bool,
        lv_key             TYPE dd03l-fieldname,
        lv_val_str         TYPE string.

  cv_new_incomplete = abap_false.
  cv_other_changes  = abap_false.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_has_newrec      = abap_true.
        lv_all_keys_filled = abap_true.

        LOOP AT gt_key_fields INTO lv_key.
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc <> 0 OR <cell> IS NOT ASSIGNED.
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.

          " Chuẩn hóa để check INITIAL cho cả char/num
          CLEAR lv_val_str.
          TRY.
              lv_val_str = <cell>.
            CATCH cx_root.
              " Nếu không gán được string (kiểu số), check INITIAL trực tiếp
          ENDTRY.

          IF lv_val_str IS NOT INITIAL.
            CONDENSE lv_val_str.
          ENDIF.

          IF ( lv_val_str IS INITIAL ) AND ( <cell> IS INITIAL ).
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_all_keys_filled = abap_false.
          cv_new_incomplete = abap_true.
          EXIT. " chỉ cần biết có 1 NEWREC thiếu khóa là đủ
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF ( gv_dirty = abap_true AND cv_new_incomplete = abap_false )
  OR ( gv_dirty_nonnewrec = abap_true ).
    cv_other_changes = abap_true.
  ENDIF.

ENDFORM.


FORM is_newrec_target_for_delete CHANGING ev_newrec_only TYPE abap_bool.
  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any, <v> TYPE any.
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col,
        lv_idx     TYPE i.

  ev_newrec_only = abap_false.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index > 0.
      APPEND VALUE lvc_s_row( index = ls_rowid-index ) TO lt_sel_idx.
    ENDIF.
  ENDIF.

  IF lines( lt_sel_idx ) <> 1.
    RETURN.
  ENDIF.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE lt_sel_idx INTO DATA(ls_sel) INDEX 1.
  IF sy-subrc <> 0. RETURN. ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX ls_sel-index.
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED. RETURN. ENDIF.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <v>.
  IF sy-subrc = 0 AND <v> = 'X'.
    " Kiểm tra xem dòng có trống hết key không
    DATA(lv_all_empty) = abap_true.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
      ASSIGN COMPONENT <k> OF STRUCTURE <ls> TO FIELD-SYMBOL(<val>).
      IF sy-subrc = 0 AND <val> IS NOT INITIAL.
        lv_all_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_all_empty = abap_true.
      ev_newrec_only = abap_true.
    ENDIF.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Discard all unsaved changes: KHÔI PHỤC HOÀN TOÀN TỪ BẢN GỐC (SAFE)  *
* - Phù hợp cả khi line type <lt_cur> và <lt_orig> KHÔNG đồng nhất    *
* - Không dump: dùng MOVE-CORRESPONDING theo từng dòng                *
*---------------------------------------------------------------------*
FORM discard_unsaved_changes.

  FIELD-SYMBOLS: <lt_cur>  TYPE STANDARD TABLE,
                 <ls_cur>  TYPE any,
                 <lt_orig> TYPE STANDARD TABLE,
                 <ls_orig> TYPE any.

  ASSIGN gr_data->*          TO <lt_cur>.
  ASSIGN gr_data_original->* TO <lt_orig>.
  IF <lt_cur> IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  " ✅ Chỉ reset khi có bản gốc hợp lệ
  IF <lt_orig> IS ASSIGNED AND <lt_orig> IS NOT INITIAL.
    CLEAR <lt_cur>.
    LOOP AT <lt_orig> ASSIGNING <ls_orig>.
      APPEND INITIAL LINE TO <lt_cur> ASSIGNING <ls_cur>.
      MOVE-CORRESPONDING <ls_orig> TO <ls_cur>.
    ENDLOOP.
  ELSE.
    " ❗ Không có bản gốc → KHÔNG được xóa màn hình
    " (tuỳ chọn) Bạn có thể reload từ DB để “chắc cú”:
    " PERFORM reload_from_db CHANGING <lt_cur>.
  ENDIF.

  CLEAR gt_changed_existing_keys.
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

ENDFORM.





FORM purge_incomplete_newrecs.
  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  " Dùng bảng chỉ số để xóa theo INDEX (key mặc định)
  DATA: lt_del     TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_missing TYPE abap_bool,
        lv_key     TYPE dd03l-fieldname,
        lv_purged  TYPE i VALUE 0,
        lv_has_new TYPE abap_bool VALUE abap_false,
        ls_stbl    TYPE lvc_s_stbl.

  CLEAR: ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  " 1) Thu thập index các NEWREC thiếu khóa; đồng thời ghi nhận còn NEWREC nào không
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      lv_has_new = abap_true. " có ít nhất một NEWREC trong lưới
      lv_missing = abap_false.

      LOOP AT gt_key_fields INTO lv_key.
        ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
        IF sy-subrc <> 0 OR <cell> IS INITIAL.
          lv_missing = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_missing = abap_true.
        APPEND sy-tabix TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Xóa các dòng NEWREC thiếu khóa (xóa từ index lớn xuống để an toàn)
  IF lt_del IS NOT INITIAL.
    SORT lt_del DESCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_del.
    LOOP AT lt_del ASSIGNING FIELD-SYMBOL(<idx>).
      DELETE <lt> INDEX <idx>.
      lv_purged = lv_purged + 1.
    ENDLOOP.
  ENDIF.

  " 3) Kiểm tra sau khi xóa: còn NEWREC hợp lệ nào không?
  "    Nếu KHÔNG còn NEWREC → tắt add mode để tránh khóa nhầm KEY các dòng cũ
  IF lv_has_new = abap_true.
    DATA(lv_still_has_new) = abap_false.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
      IF sy-subrc = 0 AND <new> = 'X'.
        lv_still_has_new = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_still_has_new = abap_false.
      gv_add_mode = abap_false.
    ENDIF.
  ENDIF.

  " 4) Áp lại editability & refresh ALV
  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " 5) Thông báo nhẹ cho người dùng (nếu có xóa)
  IF lv_purged > 0.
    MESSAGE |Đã bỏ { lv_purged } NEWREC thiếu khóa.| TYPE 'S'.
  ENDIF.
ENDFORM.


FORM focus_key_on_newrec.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.
  DATA: lv_idx TYPE i.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR g_alv_grid IS INITIAL.
    RETURN.
  ENDIF.

  lv_idx = 0.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_idx = sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF lv_idx = 0. RETURN. ENDIF.

  PERFORM ensure_keys USING p_tab.
  READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
  IF sy-subrc <> 0. RETURN. ENDIF.

  DATA ls_row TYPE lvc_s_row.
  DATA ls_col TYPE lvc_s_col.
  ls_row-index     = lv_idx.
  ls_col-fieldname = lv_first_key.

  TRY.
      g_alv_grid->set_current_cell_via_id(
      EXPORTING is_row_id    = ls_row
      is_column_id = ls_col ).
      g_alv_grid->set_scroll_info_via_id(
      EXPORTING is_row_info = ls_row
      is_col_info = ls_col ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

FORM analyze_change_state_detailed
  CHANGING ev_has_change          TYPE abap_bool
           ev_cnt_new_incomplete  TYPE i
           ev_cnt_new_complete    TYPE i
           ev_cnt_edited_existing TYPE i.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_is_key_missing TYPE abap_bool,
        lv_keyname        TYPE dd03l-fieldname.

  CLEAR: ev_has_change, ev_cnt_new_incomplete, ev_cnt_new_complete, ev_cnt_edited_existing.

  " --- Đếm NEWREC & tình trạng khóa ---
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_is_key_missing = abap_false.
        LOOP AT gt_key_fields INTO lv_keyname.
          ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS INITIAL.
            lv_is_key_missing = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF lv_is_key_missing = abap_true.
          ev_cnt_new_incomplete = ev_cnt_new_incomplete + 1.
        ELSE.
          ev_cnt_new_complete   = ev_cnt_new_complete + 1.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  ev_cnt_edited_existing = lines( gt_changed_existing_keys ).

  " --- Có thay đổi hay không? ---
  ev_has_change = boolc( ev_cnt_new_incomplete > 0
                      OR ev_cnt_new_complete   > 0
                      OR ev_cnt_edited_existing > 0 ).

ENDFORM.


FORM build_key_fingerprint USING    is_row        TYPE any
                                     it_keyfields  TYPE STANDARD TABLE
                           CHANGING ev_fp         TYPE string.

  FIELD-SYMBOLS: <kfld> TYPE dd03l-fieldname,
                 <v>    TYPE any.

  DATA lv_s TYPE string.

  CLEAR ev_fp.

  LOOP AT it_keyfields ASSIGNING <kfld>.
    ASSIGN COMPONENT <kfld> OF STRUCTURE is_row TO <v>.
    IF sy-subrc <> 0.
      ev_fp = ev_fp && '|#|'.
      CONTINUE.
    ENDIF.
    lv_s = <v>.
    CONDENSE lv_s.
    ev_fp = ev_fp && lv_s && '|#|'.
  ENDLOOP.
ENDFORM.



FORM mark_row_error USING    iv_row TYPE i
                             iv_msg TYPE string.

  FIELD-SYMBOLS: <lt_tab>    TYPE STANDARD TABLE,
                 <ls_row>    TYPE any,
                 <celltab>   TYPE lvc_t_styl,
                 <msg_field> TYPE any.

  " 1) lấy itab đang hiển thị
  ASSIGN gr_data->* TO <lt_tab>.
  IF <lt_tab> IS NOT ASSIGNED OR iv_row <= 0.
    RETURN.
  ENDIF.

  READ TABLE <lt_tab> INDEX iv_row ASSIGNING <ls_row>.
  IF sy-subrc <> 0 OR <ls_row> IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  " 2) đảm bảo có CELLTAB
  ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls_row> TO <celltab>.
  IF sy-subrc <> 0 OR <celltab> IS NOT ASSIGNED.
    PERFORM ensure_celltab_component CHANGING gr_data.

    " đọc lại sau khi ensure
    READ TABLE <lt_tab> INDEX iv_row ASSIGNING <ls_row>.
    IF sy-subrc <> 0 OR <ls_row> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls_row> TO <celltab>.
    IF sy-subrc <> 0 OR <celltab> IS NOT ASSIGNED.
      RETURN.
    ENDIF.
  ENDIF.

  DATA ls_style TYPE lvc_s_styl.

  " 3) tô tất cả cột hiển thị nhưng giữ đúng sort order
  LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>)
       WHERE tech = abap_false AND no_out = abap_false.

    " check đã có style cho field này chưa
    READ TABLE <celltab> WITH TABLE KEY fieldname = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CONTINUE. " đã có -> khỏi chèn để tránh dump trùng key
    ENDIF.

    CLEAR ls_style.
    ls_style-fieldname = <fc>-fieldname.

    " dùng style có sẵn trong hệ thống bạn
    ls_style-style     = cl_gui_alv_grid=>mc_style_disabled.
    " nếu muốn vẫn cho sửa thì dùng:
    "* ls_style-style     = cl_gui_alv_grid=>mc_style_enabled.

    " *** QUAN TRỌNG: cho bảng SORTED phải INSERT, KHÔNG APPEND
    INSERT ls_style INTO TABLE <celltab>.
  ENDLOOP.

  " 4) gán message nếu có field IS_MESSAGE
  ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_row> TO <msg_field>.
  IF sy-subrc = 0 AND <msg_field> IS ASSIGNED.
    <msg_field> = iv_msg.
  ENDIF.

ENDFORM.




FORM make_row_key USING i_row TYPE any
                  CHANGING e_key TYPE string.
  DATA: lv_piece TYPE string.
  FIELD-SYMBOLS: <cell> TYPE any.
  CLEAR e_key.
  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
    ASSIGN COMPONENT <k> OF STRUCTURE i_row TO <cell>.
    IF sy-subrc = 0.
      lv_piece = |{ <cell> }|.
    ELSE.
      lv_piece = ''.
    ENDIF.
    " dùng ^ như delimiter an toàn
    e_key = COND string( WHEN e_key IS INITIAL THEN lv_piece ELSE e_key && '^' && lv_piece ).
  ENDLOOP.
ENDFORM.

FORM check_newrec_duplicate_all
  USING    iv_tabname                 TYPE tabname
  CHANGING ev_has_dup                 TYPE abap_bool
           ev_msg                     TYPE string
           ev_first_offending_row_idx TYPE i.

  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  DATA: lv_fp    TYPE string,
        lv_where TYPE string,
        lv_we    TYPE string.

  CLEAR: ev_has_dup, ev_msg, ev_first_offending_row_idx.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  " 1) Trùng khóa giữa các NEWREC trong lưới
  TYPES: BEGIN OF ty_fp, fp TYPE string, idx TYPE i, END OF ty_fp.
  DATA: lt_seen TYPE HASHED TABLE OF ty_fp WITH UNIQUE KEY fp,
        ls_seen TYPE ty_fp.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      CLEAR lv_fp.
      PERFORM build_key_fingerprint USING <ls> gt_key_fields CHANGING lv_fp.
      IF lv_fp IS INITIAL.
        CONTINUE.
      ENDIF.

      READ TABLE lt_seen WITH KEY fp = lv_fp INTO ls_seen.
      IF sy-subrc = 0.
        ev_has_dup = abap_true.
        ev_first_offending_row_idx = sy-tabix.  " vẫn giữ để focus
        ev_msg = |Khóa bị trùng giữa các dòng NEWREC trong lưới.|.
        RETURN.
      ELSE.
        ls_seen-fp  = lv_fp.
        ls_seen-idx = sy-tabix.
        INSERT ls_seen INTO TABLE lt_seen.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Trùng khóa với DB (chỉ kiểm tra các NEWREC đủ khóa)
  DATA lv_exist TYPE i.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.

      CLEAR: lv_where, lv_we, lv_exist.
      PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
      IF lv_where IS INITIAL.
        CONTINUE.
      ENDIF.

      SELECT COUNT( * ) FROM (iv_tabname) WHERE (lv_where) INTO @lv_exist.
      IF lv_exist > 0.
        ev_has_dup = abap_true.
        ev_first_offending_row_idx = sy-tabix.  " vẫn trả về để caller focus
        ev_msg = |Khóa đã tồn tại trên hệ thống.|.
        RETURN.
      ENDIF.

    ENDIF.
  ENDLOOP.

ENDFORM.




"===== ZFA25SAP23_DB =====

" Tạo itab động dựa trên tên bảng
FORM ensure_dyn_itab USING iv_tab TYPE tabname
                     CHANGING cr_tab TYPE REF TO data.

  " Nếu đã có thì thôi
  IF cr_tab IS NOT INITIAL.
    CLEAR sy-subrc.
    RETURN.
  ENDIF.

  DATA lo_any    TYPE REF TO cl_abap_typedescr.
  DATA lo_struct TYPE REF TO cl_abap_structdescr.
  DATA lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Chuẩn hóa tên bảng (đề phòng nhập thường)
  DATA(lv_tab) = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  TRY.
      lo_any = cl_abap_typedescr=>describe_by_name( lv_tab ).
    CATCH cx_root.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_struct ?= lo_any.
    CATCH cx_sy_move_cast_error.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).
      CREATE DATA cr_tab TYPE HANDLE lo_tab.
      CLEAR sy-subrc.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

"===== Load dữ liệu từ DB vào itab =====
FORM load_data USING    iv_tab TYPE tabname
                        iv_max TYPE i
               CHANGING cr_tab TYPE REF TO data
                        ev_rows TYPE i
                        ev_err  TYPE string.

  CLEAR: ev_rows, ev_err.

  " Chuẩn hóa tên bảng
  DATA(lv_tabname) = iv_tab.
  TRANSLATE lv_tabname TO UPPER CASE.

  " Validate DDIC
  TRY.
      DATA(lo_descr) = cl_abap_typedescr=>describe_by_name( lv_tabname ).
      IF lo_descr IS INITIAL.
        ev_err = |Bảng "{ lv_tabname }" không tồn tại hoặc không hợp lệ trong DDIC. Kiểm tra SE11.|.
        RETURN.
      ENDIF.
    CATCH cx_sy_create_data_error.
      ev_err = |Lỗi tạo type cho bảng "{ lv_tabname }": Bảng không active hoặc không tồn tại. Kiểm tra SE11.|.
      RETURN.
  ENDTRY.

  " Tạo itab động theo DDIC nếu chưa có
  PERFORM ensure_dyn_itab USING lv_tabname CHANGING cr_tab.

  FIELD-SYMBOLS: <lt_load> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_load>.
  IF <lt_load> IS NOT ASSIGNED.
    ev_err = 'Không assign được itab động.'.
    RETURN.
  ENDIF.

  " Refresh dữ liệu
  REFRESH <lt_load>.

  TRY.

      "--- Kiểm tra quyền truy cập theo authorization group ---
      DATA lv_authgrp TYPE tddat-cclass.
      CLEAR lv_authgrp.

      SELECT SINGLE cclass
        FROM tddat
        INTO @lv_authgrp
       WHERE tabname = @lv_tabname.

      IF sy-subrc = 0 AND lv_authgrp IS NOT INITIAL.
        AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
             ID 'DICBERCLS' FIELD lv_authgrp
             ID 'ACTVT'     FIELD '03'.
        IF sy-subrc <> 0.
          ev_err = |Không có quyền truy cập bảng { lv_tabname } (nhóm { lv_authgrp }). Kiểm tra SU53.|.
          RETURN.
        ENDIF.
      ENDIF.

      "=== Load dữ liệu chính ===
      IF iv_max > 0.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          UP TO @iv_max ROWS
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ENDIF.
      ev_rows = sy-dbcnt.

      "=== Bổ sung 6 field audit nếu bảng gốc không có (ERDAT...AENAM) ===
      DATA: lo_tab_audit  TYPE REF TO cl_abap_tabledescr,
            lo_line_audit TYPE REF TO cl_abap_structdescr,
            lt_comp       TYPE abap_component_tab.

      lo_tab_audit ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
      lo_line_audit ?= lo_tab_audit->get_table_line_type( ).
      lt_comp = lo_line_audit->get_components( ).

      " Lấy danh sách field hiện có trong DDIC
      DATA: lt_dd03l    TYPE TABLE OF dd03l,
            lt_existing TYPE TABLE OF fieldname,
            lv_field    TYPE fieldname.

      SELECT fieldname
        FROM dd03l
        INTO TABLE @lt_dd03l
        WHERE tabname = @lv_tabname
          AND as4local = 'A'.

      LOOP AT lt_dd03l ASSIGNING FIELD-SYMBOL(<fld>).
        APPEND <fld>-fieldname TO lt_existing.
      ENDLOOP.

      " Danh sách các field audit cần có
      DATA lt_audit_fields TYPE TABLE OF string WITH EMPTY KEY.
      APPEND 'ERDAT' TO lt_audit_fields.
      APPEND 'ERTIM' TO lt_audit_fields.
      APPEND 'ERNAM' TO lt_audit_fields.
      APPEND 'AEDAT' TO lt_audit_fields.
      APPEND 'AETIM' TO lt_audit_fields.
      APPEND 'AENAM' TO lt_audit_fields.

      LOOP AT lt_audit_fields INTO lv_field.
        READ TABLE lt_existing WITH KEY table_line = lv_field TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CASE lv_field.
            WHEN 'ERDAT'. PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
            WHEN 'ERTIM'. PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
            WHEN 'ERNAM'. PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AEDAT'. PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AETIM'. PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
            WHEN 'AENAM'. PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
                APPEND lv_field TO gt_added_audit_fields.
          ENDCASE.
        ENDIF.
      ENDLOOP.

      "=== Rebuild lại itab theo cấu trúc mới (AN TOÀN KIỂU) ===
      DATA lo_new_struct TYPE REF TO cl_abap_structdescr.
      DATA lo_new_tab    TYPE REF TO cl_abap_tabledescr.

      lo_new_struct = cl_abap_structdescr=>create( lt_comp ).
      lo_new_tab    = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

      DATA lr_new TYPE REF TO data.
      CREATE DATA lr_new TYPE HANDLE lo_new_tab.

      FIELD-SYMBOLS: <lt_new>  TYPE STANDARD TABLE,
                     <row_old> TYPE any,
                     <row_new> TYPE any.
      ASSIGN lr_new->* TO <lt_new>.

      LOOP AT <lt_load> ASSIGNING <row_old>.
        APPEND INITIAL LINE TO <lt_new> ASSIGNING <row_new>.
        MOVE-CORRESPONDING <row_old> TO <row_new>.
      ENDLOOP.

      " đổi tham chiếu sang bảng mới (tránh copy bảng ↔ bảng)
      cr_tab = lr_new.
      UNASSIGN <lt_load>.
      ASSIGN cr_tab->* TO <lt_load>.

      "=== Sort theo khóa DDIC ===
      PERFORM ensure_keys USING iv_tab.
      IF gt_key_fields IS NOT INITIAL.
        DATA(lv_key) = gt_key_fields[ 1 ].
        IF lv_key IS NOT INITIAL.
          FIELD-SYMBOLS: <ls_row> TYPE any, <val> TYPE any.
          DATA(lv_all_numeric) = abap_true.

          LOOP AT <lt_load> ASSIGNING <ls_row>.
            ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
            IF sy-subrc <> 0 OR <val> IS INITIAL.
              CONTINUE.
            ENDIF.
            DATA(lv_raw) = CONV string( <val> ).
            CONDENSE lv_raw NO-GAPS.
            IF NOT lv_raw CO '0123456789'.
              lv_all_numeric = abap_false.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_all_numeric = abap_true.

            " Lập bảng chỉ mục số
            TYPES: BEGIN OF ty_idx,
                     idx TYPE i,
                     num TYPE p LENGTH 16 DECIMALS 0,
                   END OF ty_idx.
            DATA: lt_idx TYPE STANDARD TABLE OF ty_idx,
                  ls_idx TYPE ty_idx,
                  lv_idx TYPE i VALUE 0.

            LOOP AT <lt_load> ASSIGNING <ls_row>.
              lv_idx += 1.
              ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
              CLEAR ls_idx.
              ls_idx-idx = lv_idx.
              IF sy-subrc = 0 AND <val> IS ASSIGNED.
                DATA(lv_raw2) = CONV string( <val> ).
                CONDENSE lv_raw2 NO-GAPS.
                IF lv_raw2 CO '0123456789'.
                  ls_idx-num = lv_raw2.
                ENDIF.
              ENDIF.
              APPEND ls_idx TO lt_idx.
            ENDLOOP.

            SORT lt_idx BY num.

            " Build bảng đã sort MỚI rồi đổi ref (an toàn kiểu)
            DATA lr_sorted TYPE REF TO data.
            FIELD-SYMBOLS: <lt_sorted> TYPE STANDARD TABLE,
                           <ls_src>    TYPE any,
                           <ls_new2>   TYPE any.
            CREATE DATA lr_sorted LIKE <lt_load>.
            ASSIGN lr_sorted->* TO <lt_sorted>.

            LOOP AT lt_idx INTO ls_idx.
              READ TABLE <lt_load> INDEX ls_idx-idx ASSIGNING <ls_src>.
              IF sy-subrc = 0 AND <ls_src> IS ASSIGNED.
                APPEND INITIAL LINE TO <lt_sorted> ASSIGNING <ls_new2>.
                MOVE-CORRESPONDING <ls_src> TO <ls_new2>.
              ENDIF.
            ENDLOOP.

            cr_tab = lr_sorted.
            UNASSIGN <lt_load>.
            ASSIGN cr_tab->* TO <lt_load>.

          ELSE.
            SORT <lt_load> STABLE BY (lv_key).
          ENDIF.
        ENDIF.
      ENDIF.

    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động ===
  IF <lt_load> IS ASSIGNED AND <lt_load> IS NOT INITIAL.
    PERFORM merge_audit_log USING lv_tabname CHANGING <lt_load>.
  ENDIF.

  "=== Snapshot gốc để so sánh khi SAVE (an toàn & đơn giản) ===
  FIELD-SYMBOLS: <lt_orig>  TYPE STANDARD TABLE,
                 <ls_src_o> TYPE any,
                 <ls_dst_o> TYPE any.

  " Luôn tạo mới snapshot theo kiểu hiện tại của <lt_load>
  IF gr_data_original IS NOT INITIAL.
    FREE gr_data_original.
  ENDIF.
  CREATE DATA gr_data_original LIKE <lt_load>.

  ASSIGN gr_data_original->* TO <lt_orig>.
  REFRESH <lt_orig>.

  LOOP AT <lt_load> ASSIGNING <ls_src_o>.
    APPEND INITIAL LINE TO <lt_orig> ASSIGNING <ls_dst_o>.
    MOVE-CORRESPONDING <ls_src_o> TO <ls_dst_o>.
  ENDLOOP.

    "=== Nếu không có dữ liệu, vẫn đảm bảo ALV hoạt động ===
  IF <lt_load> IS ASSIGNED AND <lt_load> IS INITIAL.
    APPEND INITIAL LINE TO <lt_load>.
    DELETE <lt_load> INDEX 1.
  ENDIF.

ENDFORM.




FORM save_data USING iv_tab TYPE tabname
               CHANGING cr_tab TYPE REF TO data
                        ev_mod TYPE i
                        ev_err TYPE string.

  ev_mod = 0.
  CLEAR ev_err.

  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_alv>.
  IF <lt_alv> IS NOT ASSIGNED OR <lt_alv> IS INITIAL.
    ev_err = 'Không có dữ liệu để lưu.'.
    RETURN.
  ENDIF.

  "=== Fill audit fields tự động (ERDAT/ERTIM/ERNAM/AEDAT/AETIM/AENAM)
  FIELD-SYMBOLS: <ls_row> TYPE any,
                 <newrec> TYPE any,
                 <erdat>  TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                 <aedat>  TYPE any, <aetim> TYPE any, <aenam> TYPE any.

  LOOP AT <lt_alv> ASSIGNING <ls_row>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_row> TO <newrec>.
    ASSIGN COMPONENT 'ERDAT'  OF STRUCTURE <ls_row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM'  OF STRUCTURE <ls_row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM'  OF STRUCTURE <ls_row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT'  OF STRUCTURE <ls_row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM'  OF STRUCTURE <ls_row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM'  OF STRUCTURE <ls_row> TO <aenam>.

    " Dòng mới -> chỉ set Created* nếu có cột và còn trống
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.
    ENDIF.
    " Mọi trường hợp lưu -> set Changed*
    IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
    IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
    IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.
  ENDLOOP.

  "=== Build itab phẳng theo DDIC rồi upsert
  DATA lr_db_struct TYPE REF TO cl_abap_structdescr.
  DATA lr_db_table  TYPE REF TO cl_abap_tabledescr.
  DATA lr_flat      TYPE REF TO data.
  FIELD-SYMBOLS: <lt_flat> TYPE STANDARD TABLE,
                 <ls_flat> TYPE any,
                 <ls_alv>  TYPE any.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  lr_db_table = cl_abap_tabledescr=>create( p_line_type = lr_db_struct ).
  CREATE DATA lr_flat TYPE HANDLE lr_db_table.
  ASSIGN lr_flat->* TO <lt_flat>.

  LOOP AT <lt_alv> ASSIGNING <ls_alv>.
    APPEND INITIAL LINE TO <lt_flat> ASSIGNING <ls_flat>.
    MOVE-CORRESPONDING <ls_alv> TO <ls_flat>.

    FIELD-SYMBOLS <mandt> TYPE any.
    ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_flat> TO <mandt>.
    IF sy-subrc = 0 AND <mandt> IS ASSIGNED.
      <mandt> = sy-mandt.
    ENDIF.
  ENDLOOP.

  TRY.
      MODIFY (iv_tab) FROM TABLE <lt_flat>.
      ev_mod = sy-dbcnt.
    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== (tuỳ chọn) Ghi log audit chi tiết theo dòng
* IF ev_mod > 0.
*   LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv_row>).
*     PERFORM log_audit_action USING iv_tab 'U' <ls_alv_row>.
*   ENDLOOP.
* ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM log_audit_action - Ghi log thêm/sửa vào ZEDIT_AUDIT_LOG
*---------------------------------------------------------------------*
FORM log_audit_action USING iv_tabname TYPE tabname
                            iv_action  TYPE c
                            is_row     TYPE any.

  DATA: ls_log    TYPE zedit_audit_log,
        ls_old    TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        lv_ts_utc TYPE timestampl,
        lv_date   TYPE sydatum,
        lv_time   TYPE syuzeit.

  " Khóa log (chuẩn hóa theo key DDIC)
  PERFORM build_key_audit USING is_row CHANGING lv_key.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Lấy timestamp UTC hiện tại + convert sang giờ hiển thị
  GET TIME STAMP FIELD lv_ts_utc.
  PERFORM get_view_tzone CHANGING lv_tzone.
  CONVERT TIME STAMP lv_ts_utc TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.

  CLEAR ls_log.
  ls_log-mandt     = sy-mandt.
  ls_log-tabname   = lv_tab_up.
  ls_log-keyval    = lv_key.
  ls_log-action    = iv_action.

  " Upsert
  SELECT SINGLE * INTO @ls_old
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
      AND keyval  = @lv_key.

  IF sy-subrc <> 0.
    " ---- CHƯA CÓ LOG: chèn mới ----
    " Luôn set Created* cho lần đầu tiên
    ls_log-erdat       = lv_date.
    ls_log-ertim       = lv_time.
    ls_log-ernam       = sy-uname.
    ls_log-crt_ts_utc  = lv_ts_utc.

    " Nếu action là 'U' (rollback/update) mà chưa hề có log trước đó,
    " ta cũng set luôn Changed* để ALV có thể hiển thị Changed On/By/Time ngay lập tức.
    IF iv_action = 'U'.
      ls_log-aedat      = lv_date.
      ls_log-aetim      = lv_time.
      ls_log-aenam      = sy-uname.
      ls_log-chg_ts_utc = lv_ts_utc.
    ENDIF.

    INSERT zedit_audit_log FROM ls_log.

  ELSE.
    " ---- ĐÃ CÓ LOG: cập nhật Changed* khi action = 'U' ----
    IF iv_action = 'U'.
      UPDATE zedit_audit_log
         SET aedat      = @lv_date,
             aetim      = @lv_time,
             aenam      = @sy-uname,
             chg_ts_utc = @lv_ts_utc
       WHERE tabname    = @lv_tab_up
         AND keyval     = @lv_key.
    ENDIF.
  ENDIF.

  COMMIT WORK AND WAIT. "persist ngay để lần load sau/merge đọc được

ENDFORM.


FORM add_field_if_missing USING iv_name TYPE fieldname
                                 iv_type TYPE c
                                 iv_len  TYPE i
                         CHANGING ct_comp TYPE abap_component_tab.

  DATA ls_comp TYPE abap_componentdescr.
  DATA lv_type4 TYPE c LENGTH 4.

  lv_type4 = iv_type.  " Gán 4 ký tự đầu vào biến cố định

  " Kiểm tra field đã tồn tại chưa
  READ TABLE ct_comp WITH KEY name = iv_name TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    RETURN.
  ENDIF.

  CLEAR ls_comp.
  ls_comp-name = iv_name.

  CASE lv_type4.
    WHEN 'DATS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
    WHEN 'TIMS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
    WHEN 'CHAR'.
      ls_comp-type ?= cl_abap_elemdescr=>get_c( iv_len ).
    WHEN OTHERS.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( lv_type4 ).
  ENDCASE.

  APPEND ls_comp TO ct_comp.

ENDFORM.

*---------------------------------------------------------------------*
* FORM merge_audit_log - Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động
*---------------------------------------------------------------------*
FORM merge_audit_log USING    iv_tabname TYPE tabname
                     CHANGING ct_data    TYPE STANDARD TABLE.

  DATA: lt_audit  TYPE STANDARD TABLE OF zedit_audit_log,
        ls_audit  TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        d1        TYPE sydatum,
        t1        TYPE syuzeit,
        d2        TYPE sydatum,
        t2        TYPE syuzeit.

  FIELD-SYMBOLS: <row>   TYPE any,
                 <erdat> TYPE any,
                 <ertim> TYPE any,
                 <ernam> TYPE any,
                 <aedat> TYPE any,
                 <aetim> TYPE any,
                 <aenam> TYPE any.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Đọc log mới nhất
  SELECT *
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
    INTO TABLE @lt_audit
    BYPASSING BUFFER.

  PERFORM get_view_tzone CHANGING lv_tzone.

  LOOP AT ct_data ASSIGNING <row>.

    CLEAR lv_key.
    PERFORM build_key_audit USING <row> CHANGING lv_key.
    IF lv_key IS INITIAL.
      CONTINUE.
    ENDIF.

    " --- Tìm log theo key ---
    CLEAR ls_audit.
    READ TABLE lt_audit INTO ls_audit
         WITH KEY tabname = lv_tab_up keyval = lv_key.
    IF sy-subrc <> 0.
      " Không có log → dùng dữ liệu từ DB (hoặc fallback nếu trống)
      PERFORM fallback_audit_fields CHANGING <row>.
      CONTINUE.
    ENDIF.

    " --- Kiểm tra log có hợp lệ không? ---
    " Nếu cả crt_ts_utc và chg_ts_utc đều = 0 → log lỗi → bỏ qua
    IF ls_audit-crt_ts_utc IS INITIAL AND ls_audit-chg_ts_utc IS INITIAL.
      PERFORM fallback_audit_fields CHANGING <row>.
      CONTINUE.
    ENDIF.

    " --- Chuyển đổi timestamp ---
    CLEAR: d1, t1, d2, t2.
    IF ls_audit-crt_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-crt_ts_utc TIME ZONE lv_tzone INTO DATE d1 TIME t1.
    ENDIF.
    IF ls_audit-chg_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-chg_ts_utc TIME ZONE lv_tzone INTO DATE d2 TIME t2.
    ENDIF.

    " --- Gán field ---
    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM' OF STRUCTURE <row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM' OF STRUCTURE <row> TO <aenam>.

    " Created*
    IF <erdat> IS ASSIGNED.
      <erdat> = COND #( WHEN d1 IS NOT INITIAL THEN d1 ELSE ls_audit-erdat ).
    ENDIF.
    IF <ertim> IS ASSIGNED.
      <ertim> = COND #( WHEN t1 IS NOT INITIAL THEN t1 ELSE ls_audit-ertim ).
    ENDIF.
    IF <ernam> IS ASSIGNED.
      <ernam> = COND string( WHEN ls_audit-ernam IS NOT INITIAL THEN ls_audit-ernam ELSE sy-uname ).
    ENDIF.

    " Changed*
    IF <aedat> IS ASSIGNED.
      <aedat> = COND #( WHEN d2 IS NOT INITIAL THEN d2 ELSE ls_audit-aedat ).
    ENDIF.
    IF <aetim> IS ASSIGNED.
      <aetim> = COND #( WHEN t2 IS NOT INITIAL THEN t2 ELSE ls_audit-aetim ).
    ENDIF.
    IF <aenam> IS ASSIGNED.
      <aenam> = COND string( WHEN ls_audit-aenam IS NOT INITIAL THEN ls_audit-aenam ELSE sy-uname ).
    ENDIF.

  ENDLOOP.

ENDFORM.

FORM build_key_audit USING    is_row TYPE any
                     CHANGING ev_key TYPE string.

  DATA lv_val TYPE string.
  CLEAR ev_key.

  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kname>).
    ASSIGN COMPONENT <kname> OF STRUCTURE is_row TO FIELD-SYMBOL(<f>).
    IF sy-subrc = 0 AND <f> IS ASSIGNED.
      lv_val = <f>.
      CONDENSE lv_val NO-GAPS.
      IF ev_key IS INITIAL.
        ev_key = lv_val.
      ELSE.
        CONCATENATE ev_key lv_val INTO ev_key SEPARATED BY '|'.
      ENDIF.
    ENDIF.
  ENDLOOP.

  TRANSLATE ev_key TO UPPER CASE.
ENDFORM.

FORM get_view_tzone CHANGING ev_tzone TYPE ttzz-tzone.
  CLEAR ev_tzone.
  IF sy-zonlo IS NOT INITIAL.
    ev_tzone = sy-zonlo.
    RETURN.
  ENDIF.

  " hệ thống (nếu có cài đặt)
  DATA(lv_sys_tz) = VALUE ttzz-tzone( ).
  CALL FUNCTION 'GET_SYSTEM_TIMEZONE'
    IMPORTING
      timezone = lv_sys_tz
    EXCEPTIONS
      OTHERS   = 1.
  IF sy-subrc = 0 AND lv_sys_tz IS NOT INITIAL.
    ev_tzone = lv_sys_tz.
  ELSE.
    ev_tzone = 'UTC'.
  ENDIF.
ENDFORM.

FORM ts_utc_to_local USING    iv_ts_utc TYPE timestampl
                              iv_tzone  TYPE ttzz-tzone
                     CHANGING ev_date   TYPE sydatum
                              ev_time   TYPE syuzeit.
  CLEAR: ev_date, ev_time.
  IF iv_ts_utc IS INITIAL.
    RETURN.
  ENDIF.
  CONVERT TIME STAMP iv_ts_utc TIME ZONE iv_tzone
         INTO DATE ev_date TIME ev_time.
ENDFORM.

FORM dedup_fieldcat .

  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.

  "===== Khai báo cấu trúc tạm lưu field đã gặp =====
  TYPES: BEGIN OF ty_seen,
           fieldname TYPE lvc_fname,
           idx       TYPE i,    " vị trí trong gt_fieldcat (để xóa)
           score     TYPE i,    " điểm ưu tiên
         END OF ty_seen.

  DATA: lt_seen TYPE STANDARD TABLE OF ty_seen WITH DEFAULT KEY,
        ls_seen TYPE ty_seen.

  DATA: lt_del TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_idx TYPE i,
        lv_scr TYPE i.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    lv_idx = sy-tabix.

    IF <fc>-fieldname IS INITIAL.
      CONTINUE.
    ENDIF.

    "===== Tính điểm ưu tiên cho field hiện tại =====
    CLEAR lv_scr.
    IF <fc>-coltext   IS NOT INITIAL. lv_scr = lv_scr + 4. ENDIF.
    IF <fc>-scrtext_l IS NOT INITIAL. lv_scr = lv_scr + 2. ENDIF.
    IF <fc>-scrtext_m IS NOT INITIAL. lv_scr = lv_scr + 1. ENDIF.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      lv_scr = lv_scr - 1.
    ENDIF.

    "===== Kiểm tra xem field này đã có chưa =====
    READ TABLE lt_seen INTO ls_seen WITH KEY fieldname = <fc>-fieldname.
    IF sy-subrc <> 0.
      " Lần đầu gặp field này
      CLEAR ls_seen.
      ls_seen-fieldname = <fc>-fieldname.
      ls_seen-idx       = lv_idx.
      ls_seen-score     = lv_scr.
      APPEND ls_seen TO lt_seen.
    ELSE.
      " Đã gặp rồi → chọn giữ bản tốt hơn
      IF lv_scr > ls_seen-score.
        " Bản mới tốt hơn → xóa bản cũ
        APPEND ls_seen-idx TO lt_del.
        ls_seen-idx   = lv_idx.
        ls_seen-score = lv_scr.
        MODIFY lt_seen FROM ls_seen TRANSPORTING idx score WHERE fieldname = ls_seen-fieldname.
      ELSE.
        " Bản mới kém hơn → xóa bản hiện tại
        APPEND lv_idx TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  "===== Xóa an toàn theo thứ tự giảm dần =====
  SORT lt_del DESCENDING.
  LOOP AT lt_del INTO lv_idx.
    IF lv_idx GT 0 AND lv_idx LE lines( gt_fieldcat ).
      DELETE gt_fieldcat INDEX lv_idx.
    ENDIF.
  ENDLOOP.

ENDFORM.


FORM normalize_itab_type CHANGING cr_tab TYPE REF TO data.
  DATA lo_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_line TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL. RETURN. ENDIF.
  ASSIGN cr_tab->* TO <lt_old>.
  IF <lt_old> IS INITIAL. RETURN. ENDIF.

  lo_tab  ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).

  DATA(lo_newline) = cl_abap_structdescr=>create( lt_comp ).
  DATA(lo_newtab)  = cl_abap_tabledescr=>create( lo_newline ).

  DATA lr_new TYPE REF TO data.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.

FORM delete_audit_log USING iv_tabname TYPE tabname
                            is_row     TYPE any
                   CHANGING ev_err     TYPE string.

  DATA: lv_key    TYPE string,
        lv_tab_up TYPE tabname.

  CLEAR ev_err.

  " Build keyval từ row bị delete
  PERFORM build_key_audit USING is_row CHANGING lv_key.
  IF lv_key IS INITIAL.
    ev_err = 'Không build được keyval để xóa log.'.
    RETURN.
  ENDIF.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Xóa log tương ứng
  DELETE FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
      AND keyval  = @lv_key.

  IF sy-subrc <> 0.
    ev_err = |Xóa log thất bại cho key { lv_key }|.
  ELSE.
    COMMIT WORK AND WAIT.  " Persist ngay để tránh đọc lại log cũ
  ENDIF.

ENDFORM.

FORM fallback_audit_fields CHANGING cs_row TYPE any.

  FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                 <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any,
                 <newrec> TYPE any.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE cs_row TO <newrec>.
  ASSIGN COMPONENT 'ERDAT'  OF STRUCTURE cs_row TO <erdat>.
  ASSIGN COMPONENT 'ERTIM'  OF STRUCTURE cs_row TO <ertim>.
  ASSIGN COMPONENT 'ERNAM'  OF STRUCTURE cs_row TO <ernam>.
  ASSIGN COMPONENT 'AEDAT'  OF STRUCTURE cs_row TO <aedat>.
  ASSIGN COMPONENT 'AETIM'  OF STRUCTURE cs_row TO <aetim>.
  ASSIGN COMPONENT 'AENAM'  OF STRUCTURE cs_row TO <aenam>.

  DATA: lv_tzone TYPE ttzz-tzone,
       lv_ts TYPE timestampl,
        lv_date  TYPE sydatum,
        lv_time  TYPE syuzeit.

  PERFORM get_view_tzone CHANGING lv_tzone.
  GET TIME STAMP FIELD lv_ts.
  PERFORM ts_utc_to_local USING lv_ts lv_tzone CHANGING lv_date lv_time.

  " Nếu là NEWREC → fill Created*
  IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
    IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = lv_date. ENDIF.
    IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = lv_time. ENDIF.
    IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.
  ENDIF.

  " Luôn fill Changed* nếu trống (vì vừa load từ DB)
  IF <aedat> IS ASSIGNED AND <aedat> IS INITIAL. <aedat> = lv_date. ENDIF.
  IF <aetim> IS ASSIGNED AND <aetim> IS INITIAL. <aetim> = lv_time. ENDIF.
  IF <aenam> IS ASSIGNED AND <aenam> IS INITIAL. <aenam> = sy-uname. ENDIF.

ENDFORM.



"===== ZFA25SAP23_MAIN =====
START-OF-SELECTION.

DATA: lv_rows_main TYPE i,
      lv_err_main  TYPE string,
      lt_meta      TYPE ddfields. " metadata chi tiết

" 1. Lấy metadata đầy đủ từ DDIC
PERFORM get_metadata USING p_tab CHANGING lt_meta.

" 2. Tạo itab động cho bảng p_tab
PERFORM create_dynamic_itab USING p_tab CHANGING gr_data.

" 3. Load dữ liệu từ DB
PERFORM load_data USING p_tab p_maxrow
  CHANGING gr_data lv_rows_main lv_err_main.

" Nếu có lỗi thật sự (SQL lỗi, bảng không tồn tại, v.v.)
IF lv_err_main IS NOT INITIAL.
  MESSAGE e398(00) WITH lv_err_main.
  RETURN.
ENDIF.

" Nếu load thành công nhưng không có bản ghi → chỉ báo nhẹ, KHÔNG chặn chương trình
IF lv_rows_main = 0.
  MESSAGE 'Không có dữ liệu trong bảng, hiển thị khung trống.' TYPE 'S' DISPLAY LIKE 'I'.
ENDIF.

" 4. Merge audit log ngay sau khi load
FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.
ASSIGN gr_data->* TO <lt_data>.
PERFORM ensure_keys USING p_tab.
IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
  PERFORM merge_audit_log USING p_tab CHANGING <lt_data>.
ENDIF.

" 5. Tạo fieldcatalog cho ALV
PERFORM build_fieldcat_all.

" 6. Đồng bộ fieldcatalog với itab động
PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.

" 7. Đưa ERDAT về ngay trước nhóm Created*/Changed*
PERFORM reorder_audit_cols CHANGING gt_fieldcat.

" 8. Gọi screen hiển thị ALV
CALL SCREEN 100.




*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_F01  (FINAL – multi-select rollback)
*&---------------------------------------------------------------------*

"=== Kiểu dữ liệu dùng chung ==========================================
TYPES: BEGIN OF ty_log_sel,
         sel         TYPE c LENGTH 1,          " checkbox trong popup
         mandt       TYPE mandt,
         logid       TYPE zaudit_log-logid,
         uname       TYPE zaudit_log-uname,
         udate       TYPE zaudit_log-udate,
         utime       TYPE zaudit_log-utime,
         tabname     TYPE zaudit_log-tabname,
         action      TYPE zaudit_log-action,
         before_json TYPE zaudit_log-before_json,
         after_json  TYPE zaudit_log-after_json,
       END OF ty_log_sel.

TYPES ty_t_log TYPE STANDARD TABLE OF zaudit_log WITH DEFAULT KEY.

*---------------------------------------------------------------------*
* Hiển thị lịch sử (nhiều chọn) và rollback (1 hoặc nhiều log)
*---------------------------------------------------------------------*
FORM show_audit_history.

  DATA: lt_log_raw   TYPE STANDARD TABLE OF zaudit_log,
        lt_log_disp  TYPE STANDARD TABLE OF ty_log_sel,
        ls_log_raw   TYPE zaudit_log,
        ls_log_disp  TYPE ty_log_sel,
        lt_fieldcat  TYPE slis_t_fieldcat_alv,
        lt_fieldcat2 TYPE slis_t_fieldcat_alv,
        ls_fc        TYPE slis_fieldcat_alv,
        ls_selfield  TYPE slis_selfield.

  DATA: lv_action TYPE zaudit_log-action,
        lv_title  TYPE c LENGTH 80,
        lv_msg    TYPE string,
        lv_ans    TYPE c LENGTH 1.

  DATA: lt_picked    TYPE STANDARD TABLE OF ty_log_sel WITH DEFAULT KEY,
        lt_final     TYPE ty_t_log,
        ls_final     TYPE zaudit_log,
        lt_seen_keys TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lv_keystr    TYPE string.

  DATA: lv_skip_insert TYPE i VALUE 0,
        lv_skip_empty  TYPE i VALUE 0,
        lv_conflicts   TYPE i VALUE 0,
        lv_cnt         TYPE i VALUE 0.

  DATA: lr_bef TYPE REF TO data.

  FIELD-SYMBOLS: <ls_pick> TYPE ty_log_sel,
                 <ls_bef>  TYPE any,
                 <lt_bef>  TYPE ANY TABLE,
                 <v>       TYPE any.

  " 1) Tải log
  SELECT *
    FROM zaudit_log
    INTO TABLE @lt_log_raw
    WHERE tabname = @p_tab
    ORDER BY udate DESCENDING, utime DESCENDING.

  IF lt_log_raw IS INITIAL.
    MESSAGE 'Không có lịch sử thay đổi' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Chuẩn bị outtab có checkbox
  REFRESH lt_log_disp.
  LOOP AT lt_log_raw INTO ls_log_raw.
    CLEAR ls_log_disp.
    ls_log_disp-mandt       = ls_log_raw-mandt.
    ls_log_disp-logid       = ls_log_raw-logid.
    ls_log_disp-uname       = ls_log_raw-uname.
    ls_log_disp-udate       = ls_log_raw-udate.
    ls_log_disp-utime       = ls_log_raw-utime.
    ls_log_disp-tabname     = ls_log_raw-tabname.
    ls_log_disp-action      = ls_log_raw-action.
    ls_log_disp-before_json = ls_log_raw-before_json.
    ls_log_disp-after_json  = ls_log_raw-after_json.
    APPEND ls_log_disp TO lt_log_disp.
  ENDLOOP.

  " 3) Fieldcat + chèn cột checkbox
  PERFORM build_fieldcat_audit CHANGING lt_fieldcat.
  lt_fieldcat2 = lt_fieldcat.

  CLEAR ls_fc.
  ls_fc-fieldname = 'SEL'.
  ls_fc-seltext_m = 'Sel'.
  ls_fc-checkbox  = 'X'.
  ls_fc-edit      = 'X'.
  ls_fc-outputlen = 3.
  ls_fc-no_out    = 'X'.
  INSERT ls_fc INTO lt_fieldcat2 INDEX 1.

  " 4) Popup multi-select
  lv_title = |Chọn một hoặc nhiều log để rollback cho bảng { p_tab }|.
  CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
    EXPORTING
      i_tabname             = 'ZAUDIT_LOG'   " DDIC của bảng log
      it_fieldcat           = lt_fieldcat2
      i_title               = lv_title
      i_zebra               = 'X'
      i_screen_start_column = 5
      i_screen_start_line   = 5
      i_screen_end_column   = 140
      i_screen_end_line     = 28
      i_checkbox_fieldname  = 'SEL'
    IMPORTING
      es_selfield           = ls_selfield
    TABLES
      t_outtab              = lt_log_disp
    EXCEPTIONS
      program_error         = 1
      OTHERS                = 2.
  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

  " 5) Lấy dòng đã tick
  REFRESH lt_picked.
  LOOP AT lt_log_disp ASSIGNING <ls_pick>.
    IF <ls_pick> IS ASSIGNED AND <ls_pick>-sel = 'X'.
      APPEND <ls_pick> TO lt_picked.
    ENDIF.
  ENDLOOP.
  IF lt_picked IS INITIAL.
    MESSAGE 'Chưa chọn log nào để rollback' TYPE 'S'.
    RETURN.
  ENDIF.

  " 6) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING p_tab IF FOUND.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Bảng { p_tab } không có khóa trong DDIC.| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 7) Lọc bỏ INSERT/JSON rỗng + chống conflict cùng khóa
  REFRESH lt_final.
  REFRESH lt_seen_keys.
  DATA: lv_keyname TYPE dd03l-fieldname,
        lv_piece   TYPE string,
        lv_tmp     TYPE string.

  LOOP AT lt_picked ASSIGNING <ls_pick>.
    IF <ls_pick> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    lv_action = <ls_pick>-action.
    TRANSLATE lv_action TO UPPER CASE.

    "Cấm mọi action bắt đầu bằng 'ROLLBACK'
    IF lv_action CP 'ROLLBACK*'.
      lv_msg = |Không thể rollback log { <ls_pick>-logid(8) } vì action = { <ls_pick>-action }.|.
      MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN. " hoặc EXIT khỏi loop rồi RETURN, tùy bạn muốn cứng hay mềm
    ENDIF.

    IF lv_action = 'INSERT'.
      lv_skip_insert += 1.
      CONTINUE.
    ENDIF.

    IF <ls_pick>-before_json IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    CLEAR lr_bef.
    PERFORM json_to_itab IN PROGRAM (sy-repid)
      USING <ls_pick>-tabname <ls_pick>-before_json
      CHANGING lr_bef IF FOUND.
    IF lr_bef IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    ASSIGN lr_bef->* TO <lt_bef>.
    IF <lt_bef> IS NOT ASSIGNED OR <lt_bef> IS INITIAL.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    UNASSIGN <ls_bef>.
    LOOP AT <lt_bef> ASSIGNING <ls_bef>. EXIT. ENDLOOP.
    IF <ls_bef> IS NOT ASSIGNED.
      lv_skip_empty += 1.
      CONTINUE.
    ENDIF.

    CLEAR lv_keystr.
    LOOP AT gt_key_fields INTO lv_keyname.
      ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls_bef> TO <v>.
      CLEAR lv_piece.
      IF sy-subrc = 0 AND <v> IS ASSIGNED.
        lv_tmp = <v>.
        TRANSLATE lv_tmp TO UPPER CASE.
        CONDENSE lv_tmp NO-GAPS.
        lv_piece = lv_tmp.
      ELSE.
        lv_piece = ''.
      ENDIF.
      IF lv_keystr IS INITIAL.
        lv_keystr = lv_piece.
      ELSE.
        CONCATENATE lv_keystr lv_piece INTO lv_keystr SEPARATED BY '|'.
      ENDIF.
    ENDLOOP.

    READ TABLE lt_seen_keys WITH KEY table_line = lv_keystr TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_conflicts = lv_conflicts + 1.
      CONTINUE.
    ELSE.
      APPEND lv_keystr TO lt_seen_keys.
    ENDIF.

    CLEAR ls_final.
    ls_final-mandt       = <ls_pick>-mandt.
    ls_final-logid       = <ls_pick>-logid.
    ls_final-uname       = <ls_pick>-uname.
    ls_final-udate       = <ls_pick>-udate.
    ls_final-utime       = <ls_pick>-utime.
    ls_final-tabname     = <ls_pick>-tabname.
    ls_final-action      = <ls_pick>-action.
    ls_final-before_json = <ls_pick>-before_json.
    ls_final-after_json  = <ls_pick>-after_json.
    APPEND ls_final TO lt_final.
  ENDLOOP.

  IF lt_final IS INITIAL.
    lv_msg = |Không có log hợp lệ để rollback (bỏ { lv_skip_insert } INSERT, { lv_skip_empty } JSON rỗng, { lv_conflicts } conflict).|.
    MESSAGE lv_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

* 8) Xác nhận
  DESCRIBE TABLE lt_final LINES lv_cnt.

  DATA: lv_text TYPE string,
        lv_ok   TYPE abap_bool.

  PERFORM build_rollback_summary_text
    USING    p_tab lt_final
    CHANGING lv_text lv_cnt.

  PERFORM popup_confirm_rollback_text
    USING    lv_text
    CHANGING lv_ok.

  IF lv_ok IS INITIAL.
    MESSAGE 'Hủy rollback thành công.' TYPE 'S'.
    RETURN.
  ENDIF.




  " 9) Thực thi
  IF lv_cnt = 1.
    READ TABLE lt_final INDEX 1 INTO ls_final.
    IF sy-subrc = 0.
      PERFORM rollback_from_history USING ls_final.
    ENDIF.
  ELSE.
    DATA: lv_rows_ok TYPE i,
          lv_err     TYPE string.
    PERFORM perform_batch_rollback USING p_tab lt_final
                                   CHANGING lv_rows_ok lv_err.
    IF lv_err IS NOT INITIAL.
      MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.
  ENDIF.

  " 10) Refresh ALV
  PERFORM reload_after_change USING p_tab.
ENDFORM.


*=====================================================================*
* Batch rollback: rollback nhiều log trong 1 transaction + 1 email
*=====================================================================*
FORM perform_batch_rollback
  USING    iv_tab      TYPE tabname
           it_logs     TYPE ty_t_log
  CHANGING cv_rows_ok  TYPE i
           cv_err      TYPE string.

  DATA: lt_logs_local TYPE ty_t_log,
        ls_log        TYPE zaudit_log.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_targ   TYPE REF TO data,
        lr_curr   TYPE REF TO data.

  FIELD-SYMBOLS: <lt_targ> TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  DATA lr_one_json TYPE REF TO data.
  FIELD-SYMBOLS: <lt_one> TYPE ANY TABLE,
                 <ls_one> TYPE any.

  DATA: lv_where TYPE string,
        lv_we    TYPE string.

  DATA: lv_rows_ok TYPE i VALUE 0,
        lv_fail    TYPE abap_bool VALUE abap_false,
        lv_rc      TYPE sy-subrc.

  DATA: lv_curr_json TYPE zde_json_txt,
        lv_targ_json TYPE zde_json_txt,
        ls_newlog    TYPE zaudit_log.
  " Danh sách log để nhúng vào email gộp
  DATA: lv_loglist TYPE string,
        lv_one     TYPE string.

  CLEAR: cv_rows_ok, cv_err.

  " Sao chép input
  lt_logs_local = it_logs.
  IF lt_logs_local IS INITIAL.
    cv_err = 'Không có log để rollback (batch).'.
    RETURN.
  ENDIF.

  " Tạo itab động theo DDIC của iv_tab
  lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  IF lo_struct IS INITIAL.
    cv_err = |Không mô tả được cấu trúc bảng { iv_tab }|.
    RETURN.
  ENDIF.
  lo_table = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CREATE DATA lr_targ TYPE HANDLE lo_table.
  CREATE DATA lr_curr TYPE HANDLE lo_table.
  ASSIGN lr_targ->* TO <lt_targ>.
  ASSIGN lr_curr->* TO <lt_curr>.
  REFRESH: <lt_targ>, <lt_curr>.

  " Gom mục tiêu từ BEFORE_JSON
  LOOP AT lt_logs_local INTO ls_log.
    CLEAR lr_one_json.
    PERFORM json_to_itab IN PROGRAM (sy-repid)
      USING iv_tab ls_log-before_json
      CHANGING lr_one_json IF FOUND.
    IF lr_one_json IS INITIAL.
      CONTINUE.
    ENDIF.

    ASSIGN lr_one_json->* TO <lt_one>.
    IF <lt_one> IS INITIAL.
      CONTINUE.
    ENDIF.

    LOOP AT <lt_one> ASSIGNING <ls_one>.
      APPEND <ls_one> TO <lt_targ>.
    ENDLOOP.
  ENDLOOP.

  IF <lt_targ> IS INITIAL.
    cv_err = 'Không có dữ liệu mục tiêu để rollback (batch).'.
    RETURN.
  ENDIF.

  " Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING iv_tab IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_err = |Không tìm thấy key fields cho bảng { iv_tab }|.
    RETURN.
  ENDIF.

  " Snapshot hiện trạng
  LOOP AT <lt_targ> ASSIGNING <ls_row>.
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_row> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      CONTINUE.
    ENDIF.

    DATA lr_currow TYPE REF TO data.
    CREATE DATA lr_currow TYPE HANDLE lo_struct.
    ASSIGN lr_currow->* TO FIELD-SYMBOL(<lcur>).
    CLEAR <lcur>.

    SELECT SINGLE * FROM (iv_tab) WHERE (lv_where) INTO @<lcur>.
    IF sy-subrc = 0.
      APPEND <lcur> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  " Serialize snapshot & target cho audit/mail
  /ui2/cl_json=>serialize(
    EXPORTING data        = <lt_curr>
              pretty_name = /ui2/cl_json=>pretty_mode-none
    RECEIVING r_json      = lv_curr_json ).
  /ui2/cl_json=>serialize(
    EXPORTING data        = <lt_targ>
              pretty_name = /ui2/cl_json=>pretty_mode-none
    RECEIVING r_json      = lv_targ_json ).

  " Khôi phục: DELETE-by-key rồi INSERT
  LOOP AT <lt_targ> ASSIGNING <ls_row>.
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_row> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      lv_fail = abap_true.
      EXIT.
    ENDIF.


    DELETE FROM (iv_tab) WHERE (lv_where).
    INSERT (iv_tab) FROM <ls_row>.
    lv_rc = sy-subrc.
    IF lv_rc <> 0.
      lv_fail = abap_true.
      EXIT.
    ELSE.
      lv_rows_ok = lv_rows_ok + 1.
      PERFORM log_audit_action IN PROGRAM (sy-repid)
       USING iv_tab 'U' <ls_row> IF FOUND.
    ENDIF.
  ENDLOOP.

  IF lv_fail = abap_true.
    ROLLBACK WORK.
    cv_err = 'Rollback batch thất bại – đã ROLLBACK toàn bộ.'.
    RETURN.
  ENDIF.

  " Ghi 1 dòng audit gộp
  CLEAR ls_newlog.
  CALL FUNCTION 'GUID_CREATE'
    IMPORTING
      ev_guid_32 = ls_newlog-logid.
  ls_newlog-mandt       = sy-mandt.
  ls_newlog-uname       = sy-uname.
  ls_newlog-udate       = sy-datum.
  ls_newlog-utime       = sy-uzeit.
  ls_newlog-tabname     = iv_tab.
  ls_newlog-action      = 'ROLLBACK-BATCH'.
  ls_newlog-before_json = lv_curr_json.
  ls_newlog-after_json  = lv_targ_json.
  INSERT zaudit_log FROM ls_newlog.

  " Commit & build danh sách log để nhúng vào email gộp
  COMMIT WORK AND WAIT.

  CLEAR lv_loglist.
  lv_loglist = |Batch rollback { lines( lt_logs_local ) } log(s):|.
  LOOP AT lt_logs_local INTO ls_log.
    CLEAR lv_one.
    lv_one = |[LOGID={ ls_log-logid(8) } USER={ ls_log-uname } DATE={ ls_log-udate } TIME={ ls_log-utime } ACTION={ ls_log-action }]|.
    CONCATENATE lv_loglist
                cl_abap_char_utilities=>newline
                lv_one
           INTO lv_loglist.
  ENDLOOP.

  " Gửi 1 email gộp có kèm danh sách các log
  PERFORM notify_rollback_smtp IN PROGRAM (sy-repid)
    USING ls_newlog
          lv_rows_ok
          lv_curr_json
          lv_targ_json
          lv_loglist        " <<< thay 'space' bằng danh sách log
          IF FOUND.


  " Trả kết quả
  cv_rows_ok = lv_rows_ok.
  cv_err     = ''.

  MESSAGE |Rollback OK: { lv_rows_ok } row(s) từ { lines( lt_logs_local ) } log| TYPE 'S'.


ENDFORM.

*---------------------------------------------------------------------*
* Field catalog cho popup lịch sử
*---------------------------------------------------------------------*
FORM build_fieldcat_audit CHANGING ct_fieldcat TYPE slis_t_fieldcat_alv.
  DATA ls_fieldcat TYPE slis_fieldcat_alv.

  DEFINE add_field.
    CLEAR ls_fieldcat.
    ls_fieldcat-fieldname = &1.
    ls_fieldcat-seltext_m = &2.
    ls_fieldcat-outputlen = &3.
    APPEND ls_fieldcat TO ct_fieldcat.
  END-OF-DEFINITION.

  add_field 'LOGID'       'Log ID'               32.
  add_field 'UNAME'       'Người dùng'           12.
  add_field 'UDATE'       'Ngày'                 10.
  add_field 'UTIME'       'Giờ'                   8.
  add_field 'ACTION'      'Hành động'            10.
  add_field 'BEFORE_JSON' 'Dữ liệu trước (JSON)' 50.
  add_field 'AFTER_JSON'  'Dữ liệu sau (JSON)'   50.
ENDFORM.

*---------------------------------------------------------------------*
* Rollback 1 log (giữ nguyên behavior cũ)
*---------------------------------------------------------------------*
FORM rollback_from_history USING is_log TYPE zaudit_log.

  DATA: lv_mod       TYPE i,
        lv_err       TYPE string,
        lv_curr_json TYPE zde_json_txt,
        lr_target    TYPE REF TO data,
        lr_curr      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_target> TYPE STANDARD TABLE,
                 <ls_target> TYPE any,
                 <lt_curr>   TYPE STANDARD TABLE,
                 <ls_curr>   TYPE any.

  "--- Không cho rollback log tạo mới
  DATA lv_act TYPE zaudit_log-action.
  lv_act = is_log-action.
  TRANSLATE lv_act TO UPPER CASE.
  IF lv_act = 'INSERT'.
    MESSAGE |Log { is_log-logid(8) } là CREATE (INSERT) – không thể rollback.| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Parse BEFORE_JSON -> itab mục tiêu
  PERFORM json_to_itab IN PROGRAM (sy-repid)
       USING is_log-tabname is_log-before_json
       CHANGING lr_target IF FOUND.
  ASSIGN lr_target->* TO <lt_target>.
  IF <lt_target> IS NOT ASSIGNED OR <lt_target> IS INITIAL.
    MESSAGE |Không đọc được BEFORE_JSON của log { is_log-logid }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Lấy key
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING is_log-tabname IF FOUND.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Snapshot hiện trạng (để gửi mail)
  DATA: lo_tdesc TYPE REF TO cl_abap_tabledescr,
        lo_ldesc TYPE REF TO cl_abap_structdescr,
        lr_row   TYPE REF TO data.
  lo_tdesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_target ).
  lo_ldesc ?= lo_tdesc->get_table_line_type( ).
  CREATE DATA lr_curr TYPE HANDLE lo_tdesc.
  ASSIGN lr_curr->* TO <lt_curr>.

  LOOP AT <lt_target> ASSIGNING <ls_target>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key IN PROGRAM (sy-repid)
      USING <ls_target> gt_key_fields
      CHANGING lv_where lv_we IF FOUND.
    IF lv_where IS INITIAL.
      CONTINUE.
    ENDIF.

    CREATE DATA lr_row TYPE HANDLE lo_ldesc.
    ASSIGN lr_row->* TO <ls_curr>.
    CLEAR <ls_curr>.

    SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
    IF sy-subrc = 0.
      APPEND <ls_curr> TO <lt_curr>.
    ENDIF.
  ENDLOOP.

  IF <lt_curr> IS NOT INITIAL.
    /ui2/cl_json=>serialize(
       EXPORTING data        = <lt_curr>
                 pretty_name = /ui2/cl_json=>pretty_mode-none
       RECEIVING r_json      = lv_curr_json ).
  ELSE.
    lv_curr_json = '[]'.
  ENDIF.

  "--- Khôi phục dữ liệu theo BEFORE_JSON
  PERFORM restore_data IN PROGRAM (sy-repid)
    USING is_log-tabname
          is_log-before_json
    CHANGING lv_err lv_mod IF FOUND.

  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

    "--- Ghi 1 dòng audit 'ROLLBACK' (single)
  DATA ls_rb TYPE zaudit_log.
  CLEAR ls_rb.
  CALL FUNCTION 'GUID_CREATE'
    IMPORTING
      ev_guid_32 = ls_rb-logid.
  ls_rb-mandt       = sy-mandt.
  ls_rb-uname       = sy-uname.
  ls_rb-udate       = sy-datum.
  ls_rb-utime       = sy-uzeit.
  ls_rb-tabname     = is_log-tabname.
  ls_rb-action      = 'ROLLBACK'.
  ls_rb-before_json = lv_curr_json.        " snapshot trước khi khôi phục
  ls_rb-after_json  = is_log-before_json.  " trạng thái mục tiêu sau khôi phục
  INSERT zaudit_log FROM ls_rb.


  COMMIT WORK AND WAIT. " để merge_audit_log đọc được ngay

  "--- Thông báo & gửi mail
  MESSAGE |Rollback thành công (log: { is_log-logid(8) }, rows: { lv_mod })| TYPE 'S'.

  PERFORM notify_rollback_smtp IN PROGRAM (sy-repid)
    USING is_log
          lv_mod
          lv_curr_json
          is_log-before_json
          space
          IF FOUND.

  "--- Reload để hiển thị Changed* ngay
  PERFORM reload_after_change USING is_log-tabname.

ENDFORM.


*---------------------------------------------------------------------*
* Build text: "Khôi phục 1 Delete, 2 Update cho bảng XYZ?"
*---------------------------------------------------------------------*
FORM build_rollback_summary_text
  USING    iv_tabname TYPE tabname
           it_logs    TYPE ty_t_log
  CHANGING ev_text    TYPE string
           ev_total   TYPE i.

  DATA: ls_log TYPE zaudit_log,
        lv_act TYPE zaudit_log-action,
        n_del  TYPE i VALUE 0,
        n_upd  TYPE i VALUE 0,
        n_ins  TYPE i VALUE 0,
        n_oth  TYPE i VALUE 0.

  ev_total = lines( it_logs ).

  LOOP AT it_logs INTO ls_log.
    lv_act = ls_log-action.
    TRANSLATE lv_act TO UPPER CASE.

    IF lv_act = 'DELETE' OR lv_act = 'DEL' OR lv_act = 'D'.
      n_del += 1.
    ELSEIF lv_act = 'UPDATE' OR lv_act = 'U' OR lv_act = 'MODIFY' OR lv_act = 'CHANGE'.
      n_upd += 1.
    ELSEIF lv_act = 'INSERT' OR lv_act = 'I' OR lv_act = 'CREATE' OR lv_act = 'C'.
      n_ins += 1.
    ELSE.
      n_oth += 1.
    ENDIF.
  ENDLOOP.

  " Ghép phần chi tiết kiểu: "1 Delete, 2 Update, 1 Create"
  DATA: lt_parts  TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
        lv_part   TYPE string,
        lv_detail TYPE string.

  IF n_del > 0. lv_part = |{ n_del } Delete|.  APPEND lv_part TO lt_parts. ENDIF.
  IF n_upd > 0. lv_part = |{ n_upd } Update|.  APPEND lv_part TO lt_parts. ENDIF.
  IF n_ins > 0. lv_part = |{ n_ins } Create|.  APPEND lv_part TO lt_parts. ENDIF.
  IF n_oth > 0. lv_part = |{ n_oth } Khác|.    APPEND lv_part TO lt_parts. ENDIF.

  LOOP AT lt_parts INTO lv_part.
    IF lv_detail IS INITIAL.
      lv_detail = lv_part.
    ELSE.
      CONCATENATE lv_detail lv_part INTO lv_detail SEPARATED BY ', '.
    ENDIF.
  ENDLOOP.

  IF lv_detail IS INITIAL.
    lv_detail = |{ ev_total } mục|.
  ENDIF.

  ev_text = |Khôi phục { lv_detail } cho bảng { iv_tabname }?|.

ENDFORM.


*---------------------------------------------------------------------*
* Popup confirm dùng text tuỳ biến
*---------------------------------------------------------------------*
FORM popup_confirm_rollback_text
  USING    iv_text TYPE string
  CHANGING ev_ok   TYPE abap_bool.

  DATA lv_ans TYPE c LENGTH 1.

  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
      titlebar      = |Xác nhận khôi phục dữ liệu|
      text_question = iv_text
      text_button_1 = |Khôi phục|
      text_button_2 = |Hủy|
    IMPORTING
      answer        = lv_ans.

  ev_ok = xsdbool( lv_ans = '1' ).

ENDFORM.



*---------------------------------------------------------------------*
* Reload dữ liệu và refresh ALV sau khi có thay đổi DB
*---------------------------------------------------------------------*
FORM reload_after_change USING iv_tab TYPE tabname.

  DATA: lv_rows TYPE i,
        lv_err  TYPE string.

  " 1) Reload DB
  PERFORM load_data USING iv_tab 0
                    CHANGING gr_data lv_rows lv_err.
  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Merge lại audit để các cột Created*/Changed* đúng ngay sau rollback
  FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <lt_data>.
  PERFORM ensure_keys USING iv_tab.
  IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
    PERFORM merge_audit_log USING iv_tab CHANGING <lt_data>.
  ENDIF.

  " 3) Build lại fieldcatalog và sync với itab động, rồi sắp xếp nhóm audit
  PERFORM build_fieldcat_all.
  PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.
  PERFORM reorder_audit_cols   CHANGING gt_fieldcat.

  " 4) Reset mode + rebind ALV (không chỉ refresh)
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.
  PERFORM apply_editability_and_push.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_ready_for_input( 0 ).
      CATCH cx_root.
    ENDTRY.

    TRY.
        g_alv_grid->set_table_for_first_display(
          EXPORTING is_layout       = gs_layout
          CHANGING  it_outtab       = <lt_data>
                    it_fieldcatalog = gt_fieldcat ).
      CATCH cx_root.
        " Fallback: tối thiểu vẫn refresh nếu rebind lỗi
        DATA(ls_stbl) = VALUE lvc_s_stbl( row = 'X' col = 'X' ).
        g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    ENDTRY.

    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

ENDFORM.



*&---------------------------------------------------------------------*
*& sap xep ERDAT
*&---------------------------------------------------------------------*

FORM reorder_audit_cols CHANGING ct_fcat TYPE lvc_t_fcat.
  DATA lt_keep  TYPE lvc_t_fcat.
  DATA lt_audit TYPE lvc_t_fcat.
  DATA ls       TYPE lvc_s_fcat.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  " 1) Tách nhóm audit ra khỏi danh sách
  LOOP AT ct_fcat ASSIGNING <fc>.
    DATA(lvfn) = to_upper( <fc>-fieldname ).
    IF lvfn = 'ERDAT' OR lvfn = 'ERTIM' OR lvfn = 'ERNAM'
     OR lvfn = 'AEDAT' OR lvfn = 'AETIM' OR lvfn = 'AENAM'.
      APPEND <fc> TO lt_audit.
    ELSE.
      APPEND <fc> TO lt_keep.
    ENDIF.
  ENDLOOP.

  " 2) Ghép lại: business trước, rồi audit theo thứ tự mong muốn
  REFRESH ct_fcat.
  APPEND LINES OF lt_keep TO ct_fcat.

  DEFINE _append_audit.
    READ TABLE lt_audit INTO ls WITH KEY fieldname = &1.
    IF sy-subrc = 0.
      APPEND ls TO ct_fcat.
    ENDIF.
  END-OF-DEFINITION.

  _append_audit 'ERDAT'.   " Ngày tạo  -> muốn đứng ngay trước Created Time/By
  _append_audit 'ERTIM'.   " Created Time
  _append_audit 'ERNAM'.   " Created By
  _append_audit 'AEDAT'.   " Changed On
  _append_audit 'AETIM'.   " Changed Time
  _append_audit 'AENAM'.   " Changed By

  " 3) Refresh lại COL_POS để cố định vị trí
  DATA lv_pos TYPE i VALUE 1.
  LOOP AT ct_fcat ASSIGNING <fc>.
    <fc>-col_pos = lv_pos.
    lv_pos += 1.
  ENDLOOP.
ENDFORM.





"=== ZFA25SAP23_F01 ================================================
FORM sort_current_view_by_ddic_key.

  FIELD-SYMBOLS: <lt_all>    TYPE STANDARD TABLE,
                 <lt_saved>  TYPE STANDARD TABLE,
                 <lt_newrec> TYPE STANDARD TABLE,
                 <ls_any>    TYPE any,
                 <flag_new>  TYPE any.

  IF gr_data IS INITIAL.
    RETURN.
  ENDIF.

  ASSIGN gr_data->* TO <lt_all>.
  IF <lt_all> IS NOT ASSIGNED OR <lt_all> IS INITIAL.
    RETURN.
  ENDIF.

  "--- Chia saved vs newrec để tránh xáo vị trí dòng đang nhập
  DATA lo_tab TYPE REF TO cl_abap_tabledescr.
  lo_tab ?= cl_abap_tabledescr=>describe_by_data_ref( REF #( <lt_all> ) ).

  DATA lr_saved TYPE REF TO data.
  DATA lr_new   TYPE REF TO data.
  CREATE DATA lr_saved TYPE HANDLE lo_tab.
  CREATE DATA lr_new   TYPE HANDLE lo_tab.
  ASSIGN lr_saved->* TO <lt_saved>.
  ASSIGN lr_new->*   TO <lt_newrec>.

  LOOP AT <lt_all> ASSIGNING <ls_any>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_any> TO <flag_new>.
    IF sy-subrc = 0 AND <flag_new> = 'X'.
      APPEND <ls_any> TO <lt_newrec>.
    ELSE.
      APPEND <ls_any> TO <lt_saved>.
    ENDIF.
  ENDLOOP.

  "--- Sort theo KHÓA DDIC (dùng logic hiện có của bạn)
  PERFORM ensure_keys USING p_tab.                       "đã có sẵn :contentReference[oaicite:0]{index=0}
  IF gt_key_fields IS NOT INITIAL AND <lt_saved> IS ASSIGNED.

    DATA(lv_key) = gt_key_fields[ 1 ].
    IF lv_key IS NOT INITIAL.

      FIELD-SYMBOLS: <ls_row> TYPE any, <val> TYPE any.
      DATA(lv_all_numeric) = abap_true.

      LOOP AT <lt_saved> ASSIGNING <ls_row>.
        ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
        IF sy-subrc <> 0 OR <val> IS INITIAL. CONTINUE. ENDIF.
        DATA(lv_raw) = CONV string( <val> ).
        CONDENSE lv_raw NO-GAPS.
        IF NOT lv_raw CO '0123456789'.
          lv_all_numeric = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF lv_all_numeric = abap_true.
        "Sort số theo key
        TYPES: BEGIN OF ty_idx, idx TYPE i, num TYPE p LENGTH 16 DECIMALS 0, END OF ty_idx.
        DATA: lt_idx TYPE STANDARD TABLE OF ty_idx, ls_idx TYPE ty_idx, lv_idx TYPE i VALUE 0.

        LOOP AT <lt_saved> ASSIGNING <ls_row>.
          lv_idx += 1.
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
          CLEAR ls_idx.
          ls_idx-idx = lv_idx.
          IF sy-subrc = 0 AND <val> IS ASSIGNED.
            DATA(lv_raw2) = CONV string( <val> ).
            CONDENSE lv_raw2 NO-GAPS.
            IF lv_raw2 CO '0123456789'.
              ls_idx-num = lv_raw2.
            ENDIF.
          ENDIF.
          APPEND ls_idx TO lt_idx.
        ENDLOOP.

        SORT lt_idx BY num.

        DATA lr_sorted TYPE REF TO data.
        FIELD-SYMBOLS: <lt_sorted> TYPE STANDARD TABLE,
                       <ls_src>    TYPE any,
                       <ls_new2>   TYPE any.
        CREATE DATA lr_sorted LIKE <lt_saved>.
        ASSIGN lr_sorted->* TO <lt_sorted>.

        LOOP AT lt_idx INTO ls_idx.
          READ TABLE <lt_saved> INDEX ls_idx-idx ASSIGNING <ls_src>.
          IF sy-subrc = 0 AND <ls_src> IS ASSIGNED.
            APPEND INITIAL LINE TO <lt_sorted> ASSIGNING <ls_new2>.
            MOVE-CORRESPONDING <ls_src> TO <ls_new2>.
          ENDIF.
        ENDLOOP.

        "Ghép lại: saved đã sort + giữ nguyên các NEWREC ở cuối
        CLEAR <lt_all>.
        APPEND LINES OF <lt_sorted> TO <lt_all>.
        APPEND LINES OF <lt_newrec> TO <lt_all>.

      ELSE.
        "Sort chữ theo key (ổn định)
        SORT <lt_saved> STABLE BY (lv_key).
        CLEAR <lt_all>.
        APPEND LINES OF <lt_saved> TO <lt_all>.
        APPEND LINES OF <lt_newrec> TO <lt_all>.
      ENDIF.

    ENDIF.
  ENDIF.

ENDFORM.


FORM resort_and_refresh_alv.
  PERFORM sort_current_view_by_ddic_key.
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.
ENDFORM.