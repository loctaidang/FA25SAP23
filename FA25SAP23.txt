*&---------------------------------------------------------------------*
*& Report ZFA25SAP23
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zfa25sap23.

INCLUDE zfa25sap23_top.     "Khai báo biến toàn cục, TYPE, constant
INCLUDE zfa25sap23_sel.     "Selection screen
INCLUDE zfa25sap23_auth.    "Check whitelist + AUTHORITY-CHECK
INCLUDE zfa25sap23_ddic.    "Metadata + RTTC/RTTS + fieldcatalog
INCLUDE zfa25sap23_alv.     "ALV show + event
INCLUDE zfa25sap23_io.      "Upload/Download CSV, clipboard
INCLUDE zfa25sap23_audit.   "Audit log + rollback
INCLUDE zfa25sap23_db.      "Load/Save DB
INCLUDE zfa25sap23_main.    "START-OF-SELECTION + flow chính
INCLUDE zfa25sap23_f01.     "FORM rollBack"
*&---------------------------------------------------------------------*

"===== INCLUDE ZFA25SAP23_TOP =====
" Global declarations dùng chung cho DB/ALV/MAIN

CONSTANTS gc_hard_rcpt TYPE ad_smtpadr VALUE 'thanhchse171611@fpt.edu.vn'. " mail nhận cố định

TYPE-POOLS: abap.
CLASS lcl_alv_handler DEFINITION DEFERRED.

DATA: gv_toolbar_mode TYPE c LENGTH 1 VALUE 'D'. " 'D' = display, 'E' = edit

"––– Dữ liệu động (itab) cho mọi bảng
DATA: gr_data TYPE REF TO data.
FIELD-SYMBOLS: <gt_data> TYPE STANDARD TABLE,
               <gs_wa>   TYPE any.
"––– Ghi log lỗi chi tiết để hiển thị + debug + tô màu
TYPES: BEGIN OF ty_error_log,
         row   TYPE i,
         col   TYPE i,
         field TYPE fieldname,
         value TYPE string,
         msg   TYPE string,
       END OF ty_error_log,
       ty_t_error_log TYPE STANDARD TABLE OF ty_error_log WITH DEFAULT KEY.

DATA: gt_error_log TYPE ty_t_error_log.
DATA gv_keys_tabname TYPE tabname.

"––– Cấu trúc style để highlight lỗi trong ALV
TYPES: BEGIN OF ty_cell_style,
         fieldname TYPE fieldname,
         style     TYPE lvc_s_styl,
       END OF ty_cell_style,
       ty_t_celltab TYPE STANDARD TABLE OF ty_cell_style WITH DEFAULT KEY.


"––– ALV objects & cấu hình
DATA: g_container TYPE REF TO cl_gui_custom_container,
      g_alv_grid  TYPE REF TO cl_gui_alv_grid,
      g_okcode    TYPE sy-ucomm,
      g_handler   TYPE REF TO lcl_alv_handler,
      gv_edit_md  TYPE abap_bool VALUE abap_false. " =SPACE: VIEW, 'X': EDIT

DATA: gt_fieldcat TYPE lvc_t_fcat,
      gs_fieldcat TYPE lvc_s_fcat,
      gs_layout   TYPE lvc_s_layo.
TYPES: ty_fieldnames TYPE STANDARD TABLE OF fieldname WITH EMPTY KEY.
DATA: gt_fieldnames TYPE ty_fieldnames.
CONSTANTS: gc_cc_alv TYPE scrfname VALUE 'CC_ALV'.

DATA: gv_add_mode TYPE abap_bool VALUE abap_false.

"Cache danh sách trường khoá
DATA gt_key_fields TYPE STANDARD TABLE OF dd03l-fieldname WITH DEFAULT KEY.

"Buffer audit
TYPES: BEGIN OF ty_audit,
         logid       TYPE char32,
         uname       TYPE syuname,
         udate       TYPE sydatum,
         utime       TYPE syuzeit,
         tabname     TYPE tabname,
         action      TYPE char10,
         before_json TYPE zde_json_txt,
         after_json  TYPE zde_json_txt,
       END OF ty_audit.
DATA gt_audit TYPE STANDARD TABLE OF ty_audit WITH DEFAULT KEY.

DATA gv_dirty TYPE abap_bool VALUE abap_false.
DATA gv_del_newrec_only TYPE abap_bool VALUE abap_false.
DATA: gv_dirty_nonnewrec TYPE abap_bool VALUE abap_false.

TYPES: ty_fname TYPE lvc_fname.
DATA: gt_f4_whitelist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line,
      gt_f4_blacklist TYPE HASHED TABLE OF ty_fname WITH UNIQUE KEY table_line.
DATA gr_data_original TYPE REF TO data.

DATA: gv_can_create  TYPE abap_bool,
      gv_can_change  TYPE abap_bool,
      gv_can_delete  TYPE abap_bool,
      gv_can_display TYPE abap_bool.


"===== INCLUDE ZFA25SAP23_SEL =====

" Khối tham số
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-001.
  PARAMETERS:
    p_tab    TYPE tabname OBLIGATORY, "Bảng Z*
    p_maxrow TYPE i DEFAULT 200.
SELECTION-SCREEN END OF BLOCK b1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tab.
  PERFORM f4_tabname.

  " Validate cơ bản

AT SELECTION-SCREEN.
  " p_maxrow > 0
  IF p_maxrow IS INITIAL OR p_maxrow <= 0.
    MESSAGE e398(00) WITH 'p_maxrow phải > 0'.
  ENDIF.

  " p_tab là bảng Z* transparent và active trong DDIC
  SELECT SINGLE tabname
  FROM dd02l
  INTO @DATA(lv_tab)
  WHERE tabname = @p_tab
  AND tabclass = 'TRANSP'
  AND as4local = 'A'
  AND tabname LIKE 'Z%'.
  IF sy-subrc <> 0.
    MESSAGE e398(00) WITH |Bảng { p_tab } không hợp lệ (chỉ Z* active).|.
  ENDIF.

  "----------------- Subroutines -----------------

FORM f4_tabname.
  TYPES: BEGIN OF ty_tab, tabname TYPE dd02l-tabname, END OF ty_tab.
  DATA: lt_tabs TYPE STANDARD TABLE OF ty_tab,
        lt_ret  TYPE TABLE OF ddshretval.

  SELECT tabname
  FROM dd02l
  INTO TABLE lt_tabs
  WHERE tabname LIKE 'Z%'
  AND tabclass = 'TRANSP'
  AND as4local = 'A'
  ORDER BY tabname.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'TABNAME'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = 'P_TAB'
      value_org       = 'S'
    TABLES
      value_tab       = lt_tabs
      return_tab      = lt_ret
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
    READ TABLE lt_ret INDEX 1 INTO DATA(ls_ret).
    IF sy-subrc = 0.
      p_tab = ls_ret-fieldval.
    ENDIF.
  ENDIF.
ENDFORM.


*----------------------------------------------------------------------*
*  Include: ZFA25SAP23_AUTH
*----------------------------------------------------------------------*

FORM check_authorization .
  DATA: lv_can_create  TYPE abap_bool,
        lv_can_change  TYPE abap_bool,
        lv_can_delete  TYPE abap_bool,
        lv_can_display TYPE abap_bool.

  "--- Kiểm tra quyền
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '01'.
  IF sy-subrc = 0. lv_can_create = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '02'.
  IF sy-subrc = 0. lv_can_change = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '06'.
  IF sy-subrc = 0. lv_can_delete = abap_true. ENDIF.

  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD '03'.
  IF sy-subrc = 0. lv_can_display = abap_true. ENDIF.

  "--- LƯU Ý:
  " KHÔNG reset gv_edit_md / gv_toolbar_mode ở đây
  " Trạng thái Edit/View sẽ do người dùng bấm EVTG, hoặc do PAI quyết định.

  "--- Lưu lại quyền để toolbar biết ẩn/hiện nút
  gv_can_create  = lv_can_create.
  gv_can_change  = lv_can_change.
  gv_can_delete  = lv_can_delete.
  gv_can_display = lv_can_display.
ENDFORM.


FORM has_actvt USING iv_act TYPE activ_auth CHANGING ev_ok TYPE abap_bool.
  ev_ok = abap_false.
  AUTHORITY-CHECK OBJECT 'ZFA25SAP23' ID 'ACTVT' FIELD iv_act.
  IF sy-subrc = 0.
    ev_ok = abap_true.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_DDIC
*&---------------------------------------------------------------------*
*& Xử lý metadata, tạo itab động và fieldcatalog
*&---------------------------------------------------------------------*

"=== Build fieldcatalog cho ALV ===
FORM build_fieldcat USING p_field p_text.
  CLEAR gs_fieldcat.
  gs_fieldcat-fieldname = p_field.
  gs_fieldcat-seltext = p_text. " Tiêu đề cột
    gs_fieldcat-scrtext_m = p_text.   " Tên trung bình
  gs_fieldcat-reptext   = p_text.   " Tên report
   gs_fieldcat-coltext   = p_text.
  APPEND gs_fieldcat TO gt_fieldcat.
ENDFORM.

FORM build_fieldcat_all .
  REFRESH: gt_fieldcat, gt_fieldnames.

  "--- Lấy fieldcatalog từ DDIC
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name       = p_tab
    CHANGING
      ct_fieldcat            = gt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  IF gt_fieldcat IS INITIAL.
    MESSAGE |Không tạo được fieldcatalog cho bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Ẩn MANDT nếu có
  FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    IF <fs_fcat>-fieldname = 'MANDT'.
      <fs_fcat>-no_out = abap_true.
      <fs_fcat>-tech   = abap_true.
    ENDIF.
  ENDLOOP.

  "--- Thêm 6 cột audit CHỈ KHI chưa có
  DATA: lv_colpos TYPE i,
        ls_fc     TYPE lvc_s_fcat.

  DESCRIBE TABLE gt_fieldcat LINES lv_colpos.

  " ERDAT
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERDAT' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERDAT'.
    ls_fc-coltext   = 'Created On'.
    ls_fc-scrtext_m = 'Created On'.
    ls_fc-reptext   = 'Created On'.
    ls_fc-seltext   = 'Created On'.
    ls_fc-col_pos   = lv_colpos + 1.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " ERTIM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERTIM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERTIM'.
    ls_fc-coltext   = 'Created Time'.
    ls_fc-scrtext_m = 'Created Time'.
    ls_fc-reptext   = 'Created Time'.
    ls_fc-seltext   = 'Created Time'.
    ls_fc-col_pos   = lv_colpos + 2.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " ERNAM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ERNAM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ERNAM'.
    ls_fc-coltext   = 'Created By'.
    ls_fc-scrtext_m = 'Created By'.
    ls_fc-reptext   = 'Created By'.
    ls_fc-seltext   = 'Created By'.
    ls_fc-col_pos   = lv_colpos + 3.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AEDAT
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AEDAT' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AEDAT'.
    ls_fc-coltext   = 'Changed On'.
    ls_fc-scrtext_m = 'Changed On'.
    ls_fc-reptext   = 'Changed On'.
    ls_fc-seltext   = 'Changed On'.
    ls_fc-col_pos   = lv_colpos + 4.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AETIM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AETIM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AETIM'.
    ls_fc-coltext   = 'Changed Time'.
    ls_fc-scrtext_m = 'Changed Time'.
    ls_fc-reptext   = 'Changed Time'.
    ls_fc-seltext   = 'Changed Time'.
    ls_fc-col_pos   = lv_colpos + 5.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  " AENAM
  READ TABLE gt_fieldcat WITH KEY fieldname = 'AENAM' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'AENAM'.
    ls_fc-coltext   = 'Changed By'.
    ls_fc-scrtext_m = 'Changed By'.
    ls_fc-reptext   = 'Changed By'.
    ls_fc-seltext   = 'Changed By'.
    ls_fc-col_pos   = lv_colpos + 6.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Thêm field kỹ thuật CELLTAB (ẩn) nếu thiếu
  READ TABLE gt_fieldcat WITH KEY fieldname = 'CELLTAB' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'CELLTAB'.
    ls_fc-col_pos   = 999.
    ls_fc-no_out    = abap_true.
    ls_fc-tech      = abap_true.
    ls_fc-inttype   = 'L'.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Thêm field kỹ thuật ROW_COLOR (ẩn) nếu thiếu
  READ TABLE gt_fieldcat WITH KEY fieldname = 'ROW_COLOR' TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_fc.
    ls_fc-fieldname = 'ROW_COLOR'.
    ls_fc-col_pos   = 1000.
    ls_fc-no_out    = abap_true.
    ls_fc-tech      = abap_true.
    APPEND ls_fc TO gt_fieldcat.
  ENDIF.

  "--- Force read-only cho các cột audit trên FIELDCAT
  DATA: lt_audit_f TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit_f.
  APPEND 'ERTIM' TO lt_audit_f.
  APPEND 'ERNAM' TO lt_audit_f.
  APPEND 'AEDAT' TO lt_audit_f.
  APPEND 'AETIM' TO lt_audit_f.
  APPEND 'AENAM' TO lt_audit_f.

  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    READ TABLE lt_audit_f WITH KEY table_line = <fs_fcat>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CLEAR: <fs_fcat>-edit, <fs_fcat>-f4availabl.  " xám + không F4
    ENDIF.
  ENDLOOP.

  "--- (Tuỳ chọn) Khử trùng lặp lần cuối nếu có
  PERFORM dedup_fieldcat.

  "--- Build danh sách caption để dùng nơi khác
  CLEAR gt_fieldnames.
  LOOP AT gt_fieldcat ASSIGNING <fs_fcat>.
    IF <fs_fcat>-tech = abap_true OR <fs_fcat>-no_out = abap_true.
      CONTINUE.
    ENDIF.
    DATA(lv_name) = COND string(
                       WHEN <fs_fcat>-coltext IS NOT INITIAL
                       THEN <fs_fcat>-coltext
                       ELSE <fs_fcat>-fieldname ).
    lv_name = to_upper( condense( lv_name ) ).
    CONDENSE lv_name NO-GAPS.
    APPEND lv_name TO gt_fieldnames.
  ENDLOOP.

  "--- Bật F4 (chuẩn hoặc fallback)
  PERFORM enable_f4_in_fieldcat.
ENDFORM.




"=== Tạo itab động từ bảng p_tab ===
FORM create_dynamic_itab USING p_tabname TYPE tabname
CHANGING p_itab TYPE REF TO data.

  DATA: lo_descr TYPE REF TO cl_abap_structdescr,
        lo_table TYPE REF TO cl_abap_tabledescr.

  TRY.
      " Lấy mô tả cấu trúc của bảng p_tabname
      lo_descr ?= cl_abap_typedescr=>describe_by_name( p_tabname ).
      lo_table = cl_abap_tabledescr=>create( lo_descr ).
"=== Thêm 6 field audit tự động, tránh trùng tên ===
DATA: lt_components TYPE abap_component_tab,
      ls_component  TYPE abap_componentdescr,
      lt_names      TYPE STANDARD TABLE OF string.

DATA(lo_struct) = CAST cl_abap_structdescr( lo_table->get_table_line_type( ) ).
lt_components = lo_struct->get_components( ).

" Lấy danh sách field hiện có
LOOP AT lt_components INTO ls_component.
  APPEND ls_component-name TO lt_names.
ENDLOOP.

DEFINE add_field_if_missing.
  READ TABLE lt_names WITH KEY table_line = &1 TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR ls_component.
    ls_component-name = &1.
    ls_component-type ?= cl_abap_elemdescr=>describe_by_name( &2 ).
    APPEND ls_component TO lt_components.
  ENDIF.
END-OF-DEFINITION.

add_field_if_missing 'ERDAT' 'DATS'.  " Created On
add_field_if_missing 'ERTIM' 'TIMS'.  " Created Time
add_field_if_missing 'ERNAM' 'UNAME'. " Created By
add_field_if_missing 'AEDAT' 'DATS'.  " Changed On
add_field_if_missing 'AETIM' 'TIMS'.  " Changed Time
add_field_if_missing 'AENAM' 'UNAME'. " Changed By

" Tạo lại mô tả cấu trúc có 6 field mới
DATA(lo_new_struct) = cl_abap_structdescr=>create( lt_components ).
DATA(lo_new_table)  = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

CREATE DATA p_itab TYPE HANDLE lo_new_table.

*      CREATE DATA p_itab TYPE HANDLE lo_table.

        CATCH cx_sy_create_data_error INTO DATA(lx_create).
      MESSAGE |Không tạo được itab động cho { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

ENDFORM.



*---------------------------------------------------------------------*
* Đồng bộ fieldcatalog với line type của itab động (gr_data)
*---------------------------------------------------------------------*
FORM sync_fcat_with_itab CHANGING ct_fcat TYPE lvc_t_fcat.

  DATA: lo_tab  TYPE REF TO cl_abap_tabledescr,
        lo_line TYPE REF TO cl_abap_structdescr,
        lt_comp TYPE abap_component_tab.

  IF gr_data IS INITIAL.
    RETURN.
  ENDIF.

  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( gr_data ).
  lo_line ?= CAST cl_abap_structdescr( lo_tab->get_table_line_type( ) ).
  lt_comp = lo_line->get_components( ).

  LOOP AT ct_fcat ASSIGNING FIELD-SYMBOL(<fs_fc>).
    READ TABLE lt_comp WITH KEY name = <fs_fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE ct_fcat.
    ENDIF.
  ENDLOOP.

  " Sau khi sync có thể có cột bị xóa → bật lại F4 cho chắc
  PERFORM enable_f4_in_fieldcat.


ENDFORM.



FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
CHANGING er_data TYPE REF TO data.

  DATA: lt_dfies      TYPE TABLE OF dfies,
        lt_components TYPE cl_abap_structdescr=>component_table,
        ls_component  LIKE LINE OF lt_components.

  " Lấy metadata từ DDIC
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tabname
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " Lọc các trường không phải style (tên field thường là CELLTAB)
  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'. " Thay 'CELLTAB' nếu tên field style khác
    ls_component-name = ls_dfies-fieldname.
    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
    APPEND ls_component TO lt_components.
  ENDLOOP.

  " Tạo cấu trúc động
  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
  lr_struct_type = cl_abap_structdescr=>create( lt_components ).

  " Tạo internal table động
  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
  lr_table_type = cl_abap_tabledescr=>create(
  p_line_type = lr_struct_type
  p_table_kind = cl_abap_tabledescr=>tablekind_std ).
  CREATE DATA er_data TYPE HANDLE lr_table_type.

ENDFORM.
*FORM create_dynamic_itab_no_style USING iv_tabname TYPE tabname
*CHANGING er_data TYPE REF TO data.
*
*  DATA: lt_dfies      TYPE TABLE OF dfies,
*        lt_components TYPE cl_abap_structdescr=>component_table,
*        ls_component  LIKE LINE OF lt_components.
*
*  " Lấy metadata từ DDIC
*  CALL FUNCTION 'DDIF_FIELDINFO_GET'
*    EXPORTING
*      tabname   = iv_tabname
*    TABLES
*      dfies_tab = lt_dfies
*    EXCEPTIONS
*      not_found = 1
*      OTHERS    = 2.
*  IF sy-subrc <> 0.
*    MESSAGE 'Không lấy được metadata cho bảng' TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  " Bổ sung các field thực từ DDIC
*  LOOP AT lt_dfies INTO DATA(ls_dfies) WHERE fieldname <> 'CELLTAB'. " Bỏ qua CELLTAB nếu có
*    ls_component-name = ls_dfies-fieldname.
*    ls_component-type ?= cl_abap_datadescr=>describe_by_name( ls_dfies-rollname ).
*    APPEND ls_component TO lt_components.
*  ENDLOOP.
*PERFORM add_audit_fields CHANGING lt_components.
*  " Bổ sung các field kỹ thuật
*  CLEAR ls_component.
*  ls_component-name = 'ROW_COLOR'.
*  ls_component-type ?= cl_abap_tabledescr=>describe_by_name( 'LVC_T_SCOL' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'CELLTAB'.
*  ls_component-type ?= cl_abap_tabledescr=>describe_by_name( 'LVC_T_STYL' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'IS_ERROR'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'CHAR1' ).
*  APPEND ls_component TO lt_components.
*
*  CLEAR ls_component.
*  ls_component-name = 'IS_MESSAGE'.
*  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'STRING' ).
*  APPEND ls_component TO lt_components.
*
*  " Tạo cấu trúc động
*  DATA: lr_struct_type TYPE REF TO cl_abap_structdescr.
*  lr_struct_type = cl_abap_structdescr=>create( lt_components ).
*
*  " Tạo internal table động
*  DATA: lr_table_type TYPE REF TO cl_abap_tabledescr.
*  lr_table_type = cl_abap_tabledescr=>create(
*                    p_line_type  = lr_struct_type
*                    p_table_kind = cl_abap_tabledescr=>tablekind_std ).
*
*  CREATE DATA er_data TYPE HANDLE lr_table_type.
*
*ENDFORM.

*---------------------------------------------------------------------*
* Thêm 6 field audit (Created/Changed) vào cấu trúc động
*---------------------------------------------------------------------*
FORM add_audit_fields CHANGING ct_components TYPE cl_abap_structdescr=>component_table.
  DATA ls_component LIKE LINE OF ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERTIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'ERNAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AEDAT'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AETIM'.
  ls_component-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
  APPEND ls_component TO ct_components.

  CLEAR ls_component.
  ls_component-name = 'AENAM'.
  ls_component-type ?= cl_abap_elemdescr=>get_c( 12 ).
  APPEND ls_component TO ct_components.
ENDFORM.


*---------------------------------------------------------------------*
* Lấy metadata chi tiết từ DDIC (so với fieldcatalog ALV)
*---------------------------------------------------------------------*
FORM get_metadata USING p_tabname TYPE tabname
CHANGING ct_meta TYPE ddfields.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tabname
      langu          = sy-langu
      all_types      = 'X'
    TABLES
      dfies_tab      = ct_meta
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR ct_meta IS INITIAL.
    MESSAGE |Không lấy được metadata cho bảng { p_tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

ENDFORM.

FORM enable_f4_in_fieldcat .
  DATA: lt_meta TYPE TABLE OF dfies,
        ls_meta TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING tabname = p_tab
    TABLES   dfies_tab = lt_meta
    EXCEPTIONS OTHERS = 1.

  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Mặc định
    <fc>-f4availabl = abap_false.

    " Key?
    DATA(lv_is_key) = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    CLEAR ls_meta.
    READ TABLE lt_meta INTO ls_meta WITH KEY fieldname = <fc>-fieldname.

    " --- Ưu tiên SH/FK ---
    IF sy-subrc = 0 AND ( ls_meta-f4availabl = 'X' OR ls_meta-checktable IS NOT INITIAL ).
      <fc>-f4availabl = abap_true.
    ELSE.
      " --- Loại trừ các kiểu không nên bật F4 ---
      DATA(lv_is_disallowed) = abap_false.
      IF ls_meta-datatype = 'DATS' OR ls_meta-datatype = 'TIMS'.
        lv_is_disallowed = abap_true.
      ENDIF.
      " QUAN/CURR (số lượng/tiền tệ) hoặc có ref field
      IF ls_meta-datatype = 'QUAN' OR ls_meta-datatype = 'CURR'
         OR ls_meta-reffield  IS NOT INITIAL OR ls_meta-reftable IS NOT INITIAL.
        lv_is_disallowed = abap_true.
      ENDIF.

      " --- Cho phép "fallback-only" ---
      IF lv_is_key = abap_false AND lv_is_disallowed = abap_false.
        " Kiểu text hoặc số "tự do": CHAR/STRG/NUMC/DEC/INT/FLTP/packed…
        IF ls_meta-inttype = 'C'  OR ls_meta-inttype = 'N' OR   " CHAR/NUMC
           ls_meta-inttype = 'P'  OR                            " DEC/packed
           ls_meta-inttype = 'I'  OR                            " INT
           ls_meta-inttype = 'F'.                               " FLTP
          <fc>-f4availabl = abap_true.  " bật để kích hoạt onf4 → fallback từ ALV
        ENDIF.
      ENDIF.
    ENDIF.

    " --- Whitelist/Blacklist (tuỳ chọn) ---
    READ TABLE gt_f4_whitelist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_true. ENDIF.

    READ TABLE gt_f4_blacklist WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. <fc>-f4availabl = abap_false. ENDIF.

    " Giữ logic edit sẵn có
    IF <fc>-edit IS INITIAL.
      <fc>-edit = abap_true.
    ENDIF.
  ENDLOOP.
ENDFORM.


FORM register_f4_all .
  DATA: lt_f4   TYPE lvc_t_f4,
        ls_f4   TYPE lvc_s_f4,
        lt_seen TYPE HASHED TABLE OF lvc_fname WITH UNIQUE KEY table_line,
        lv_name TYPE lvc_fname.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  CLEAR: lt_f4, lt_seen.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    IF <fc>-f4availabl = abap_true.
      lv_name = <fc>-fieldname.
      IF lv_name IS INITIAL. CONTINUE. ENDIF.

      READ TABLE lt_seen WITH KEY table_line = lv_name TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. CONTINUE. ENDIF.
      INSERT lv_name INTO TABLE lt_seen.

      CLEAR ls_f4.
      ls_f4-fieldname = lv_name.
      ls_f4-register = abap_true.
      ls_f4-getbefore = abap_true.
      ls_f4-chngeafter = abap_false.

      INSERT ls_f4 INTO TABLE lt_f4.
    ENDIF.
  ENDLOOP.

  TRY.
      g_alv_grid->register_f4_for_fields( it_f4 = lt_f4 ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

"=== helper: chỉ thêm field vào fieldcatalog nếu chưa có
FORM add_fc_if_missing USING iv_field  TYPE lvc_fname
                              iv_text   TYPE string
                              iv_colpos TYPE i.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-coltext   = iv_text.
    gs_fieldcat-scrtext_m = iv_text.
    gs_fieldcat-reptext   = iv_text.
    gs_fieldcat-col_pos   = iv_colpos.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.

"=== helper: thêm cột kỹ thuật nếu chưa có (ẩn đi)
FORM add_fc_tech_if_missing USING iv_field  TYPE lvc_fname
                                   iv_colpos TYPE i
                                   iv_hidden TYPE abap_bool.
  READ TABLE gt_fieldcat WITH KEY fieldname = iv_field TRANSPORTING NO FIELDS.
  IF sy-subrc <> 0.
    CLEAR gs_fieldcat.
    gs_fieldcat-fieldname = iv_field.
    gs_fieldcat-col_pos   = iv_colpos.
    IF iv_hidden = abap_true.
      gs_fieldcat-no_out = abap_true.
      gs_fieldcat-tech   = abap_true.
    ENDIF.
    APPEND gs_fieldcat TO gt_fieldcat.
  ENDIF.
ENDFORM.


*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_ALV
*&---------------------------------------------------------------------*

CLASS lcl_alv_handler DEFINITION.
  PUBLIC SECTION.
    METHODS handle_toolbar
      FOR EVENT toolbar OF cl_gui_alv_grid
      IMPORTING e_object e_interactive.

    METHODS handle_user_command
      FOR EVENT user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm.

    METHODS handle_onf4
      FOR EVENT onf4 OF cl_gui_alv_grid
      IMPORTING e_fieldname es_row_no er_event_data e_display.

    METHODS handle_data_changed
      FOR EVENT data_changed OF cl_gui_alv_grid
      IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.
ENDCLASS.

CLASS lcl_alv_handler IMPLEMENTATION.

  METHOD handle_toolbar.
    DATA: lt_toolbar     TYPE STANDARD TABLE OF stb_button,
          lt_excl        TYPE TABLE OF syucomm,
          ls_btn         TYPE stb_button,
          lv_code        TYPE syucomm,
          lv_found       TYPE abap_bool,
          lv_can_create  TYPE abap_bool,
          lv_can_change  TYPE abap_bool,
          lv_can_delete  TYPE abap_bool,
          lv_can_display TYPE abap_bool.

    PERFORM has_actvt USING '01' CHANGING lv_can_create.
    PERFORM has_actvt USING '02' CHANGING lv_can_change.
    PERFORM has_actvt USING '06' CHANGING lv_can_delete.
    PERFORM has_actvt USING '03' CHANGING lv_can_display.

    e_interactive = space.

    " Loại bỏ nút chuẩn không dùng
    REFRESH lt_excl.
    APPEND 'INSR' TO lt_excl.
    APPEND 'DELE' TO lt_excl.
    APPEND 'COPY' TO lt_excl.
    APPEND 'PASTE' TO lt_excl.
    APPEND 'SCUT' TO lt_excl.
    APPEND 'SALL' TO lt_excl.
    APPEND 'PICK' TO lt_excl.

    lt_toolbar = e_object->mt_toolbar[].
    LOOP AT lt_toolbar ASSIGNING FIELD-SYMBOL(<fs_btn>).
      CLEAR lv_found.
      LOOP AT lt_excl INTO lv_code.
        IF lv_code = <fs_btn>-function.
          lv_found = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_found = abap_true.
        DELETE lt_toolbar INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

    "==== EVTG ====
    CLEAR ls_btn.
    ls_btn-function = 'EVTG'.
    IF gv_edit_md = abap_true.
      ls_btn-icon      = icon_display.
      ls_btn-text      = 'View'.
      ls_btn-quickinfo = 'Switch to view mode'.
      ls_btn-disabled  = space.
    ELSE.
      ls_btn-icon      = icon_change.
      ls_btn-text      = 'Edit'.
      ls_btn-quickinfo = 'Switch to edit mode'.
      IF lv_can_change = abap_true.
        ls_btn-disabled = space.
      ELSE.
        ls_btn-disabled = 'X'.
      ENDIF.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== SAVE ====
    CLEAR ls_btn.
    ls_btn-function = 'SAVE'.
    ls_btn-icon = icon_system_save.
    ls_btn-text = 'Save'.
    ls_btn-quickinfo = 'Save changes'.
    IF gv_edit_md = abap_true AND lv_can_change = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== ADD ====
    CLEAR ls_btn.
    ls_btn-function = 'ADD'.
    ls_btn-icon = icon_create.
    ls_btn-text = 'Add'.
    ls_btn-quickinfo = 'Add new entry'.
    IF gv_edit_md = abap_true AND lv_can_create = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== DELETE ====
    CLEAR ls_btn.
    ls_btn-function = 'DELE'.
    ls_btn-icon = icon_delete.
    ls_btn-text = 'Delete'.
    ls_btn-quickinfo = 'Delete selected entry'.
    IF gv_edit_md = abap_true AND lv_can_delete = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== UPLOAD ====
    CLEAR ls_btn.
    ls_btn-function = 'UPLD'.
    ls_btn-icon = icon_import.
    ls_btn-text = 'Upload Data'.
    ls_btn-quickinfo = 'Upload from file'.
    IF gv_edit_md = abap_true AND lv_can_change = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== EXPORT (XLSX) ====
    CLEAR ls_btn.
    ls_btn-function = 'XLSX'.
    ls_btn-icon = icon_export.
    ls_btn-text = 'Export Data'.
    ls_btn-quickinfo = 'Export to Excel'.
    IF lv_can_display = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== TEMPLATE ====
    CLEAR ls_btn.
    ls_btn-function = 'TMPL'.
    ls_btn-icon = icon_export.
    ls_btn-text = 'Export Template'.
    ls_btn-quickinfo = 'Download template'.
    IF lv_can_display = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    "==== HISTORY ====
    CLEAR ls_btn.
    ls_btn-function = 'HIST'.
    ls_btn-icon = icon_history.
    ls_btn-text = 'History'.
    ls_btn-quickinfo = 'View version history & rollback'.
    IF lv_can_display = abap_true.
      ls_btn-disabled = space.
    ELSE.
      ls_btn-disabled = 'X'.
    ENDIF.
    APPEND ls_btn TO lt_toolbar.

    e_object->mt_toolbar[] = lt_toolbar.
  ENDMETHOD.


  METHOD handle_user_command.
    DATA: ls_stbl               TYPE lvc_s_stbl,
          lv_has_change         TYPE abap_bool,
          lv_answer             TYPE c,
          lv_new_incomplete     TYPE abap_bool,
          lv_other_changes      TYPE abap_bool,
          lv_ans_conf           TYPE c,
          lv_question           TYPE c LENGTH 70,
          lv_msg                TYPE c LENGTH 200,
          lv_err                TYPE c LENGTH 200,
          lv_skip_unsaved_check TYPE abap_bool VALUE abap_false,
          lv_ok                 TYPE abap_bool.

    FIELD-SYMBOLS:
      <fs_tab>    TYPE STANDARD TABLE,
      <fs_row>    TYPE any,
      <fs_newrec> TYPE any,
      <fs_erdat>  TYPE any,  <fs_ertim> TYPE any,  <fs_ernam> TYPE any.

    CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

    " Gom dữ liệu đang edit về itab trước
    IF g_alv_grid IS BOUND.
      TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
    ENDIF.

    IF e_ucomm = 'DELE' OR e_ucomm = 'ADD'.
      lv_skip_unsaved_check = abap_true.
    ENDIF.

    "=== Kiểm tra thay đổi chưa lưu chi tiết (popup hướng dẫn) ===
    DATA: lv_new_incomplete_cnt TYPE i,
          lv_new_complete_cnt   TYPE i,
          lv_edit_existing_cnt  TYPE i,
          lv_ans                TYPE c,
          lv_text               TYPE c LENGTH 200.

    PERFORM analyze_change_state_detailed
      CHANGING lv_has_change lv_new_incomplete_cnt lv_new_complete_cnt lv_edit_existing_cnt.

    IF e_ucomm <> 'SAVE'
       AND lv_has_change = abap_true
       AND lv_skip_unsaved_check <> abap_true.

      IF     lv_new_incomplete_cnt > 0
         AND lv_new_complete_cnt   = 0
         AND lv_edit_existing_cnt  = 0.

        lv_text = |Có | && lv_new_incomplete_cnt &&
                  | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và tiếp tục?|.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Dòng mới thiếu khóa'
            text_question         = lv_text
            text_button_1         = 'Bỏ & tiếp tục'
            text_button_2         = 'Quay lại'
            default_button        = '2'
            display_cancel_button = space
          IMPORTING
            answer                = lv_ans.

        IF lv_ans = '1'.
          " Người dùng chọn Bỏ & Tiếp tục → xóa newrec, có thể về view
          PERFORM purge_incomplete_newrecs.
          gv_add_mode = abap_false.
          PERFORM apply_editability_and_push.
          " Không RETURN: cho phép tiếp tục xử lý ucomm (ví dụ EVTG…)
        ELSEIF lv_ans = '2'.
          " Người dùng chọn Quay lại → GIỮ nguyên edit mode, focus ô khóa
          PERFORM focus_key_on_newrec.
          RETURN. " THOÁT TOÀN METHOD, KHÔNG CHẠY TIẾP
        ENDIF.

      ELSEIF lv_new_complete_cnt > 0
         AND lv_edit_existing_cnt = 0
         AND lv_new_incomplete_cnt = 0.

        lv_text = |Có | && lv_new_complete_cnt &&
                  | dòng mới CHƯA LƯU. Lưu trước khi tiếp tục?|.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Dòng mới chưa lưu'
            text_question         = lv_text
            text_button_1         = 'Lưu'
            text_button_2         = 'Không lưu'
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
          WHEN 'A'. RETURN.
          WHEN '2'. " Không lưu, vẫn tiếp tục
        ENDCASE.

      ELSEIF lv_edit_existing_cnt > 0
         AND lv_new_incomplete_cnt = 0
         AND lv_new_complete_cnt   = 0.

        lv_text = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi tiếp tục?'.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Thay đổi chưa lưu'
            text_question         = lv_text
            text_button_1         = 'Lưu'
            text_button_2         = 'Không lưu'
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
          WHEN 'A'. RETURN.
          WHEN '2'. PERFORM discard_unsaved_changes.
        ENDCASE.

      ELSE.
        lv_text = |Có thay đổi chưa lưu: | &&
                  lv_new_incomplete_cnt && ' NEWREC thiếu khóa, ' &&
                  lv_new_complete_cnt   && ' NEWREC đủ khóa, ' &&
                  lv_edit_existing_cnt  && ' thay đổi dòng cũ. Lưu trước khi tiếp tục?'.
        CLEAR lv_ans.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Thay đổi chưa lưu'
            text_question         = lv_text
            text_button_1         = 'Lưu'
            text_button_2         = 'Không lưu'
            default_button        = '1'
            display_cancel_button = 'X'
          IMPORTING
            answer                = lv_ans.
        CASE lv_ans.
          WHEN '1'. PERFORM on_save. IF gv_dirty = abap_true. RETURN. ENDIF.
          WHEN 'A'. RETURN.
          WHEN '2'. PERFORM discard_unsaved_changes.
        ENDCASE.
      ENDIF.

    ENDIF.

    "=== Xử lý các nút ===
    CASE e_ucomm.

      WHEN 'EVTG'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
          gv_edit_md      = abap_false.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'D'.
          TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
        ELSE.
          gv_edit_md      = abap_true.
          gv_add_mode     = abap_false.
          gv_toolbar_mode = 'E'.
          TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
        ENDIF.
        PERFORM apply_editability_and_push.
        IF g_alv_grid IS BOUND.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'ADD'.
        PERFORM has_actvt USING '01' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Edit (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ASSIGN gr_data->* TO <fs_tab>.
        IF <fs_tab> IS ASSIGNED.
          APPEND INITIAL LINE TO <fs_tab> ASSIGNING <fs_row>.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <fs_row> TO <fs_newrec>.
          IF sy-subrc = 0. <fs_newrec> = 'X'. ENDIF.

          " Gán thông tin Created (chỉ cho dòng mới)
          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <fs_row> TO <fs_erdat>.
          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <fs_row> TO <fs_ertim>.
          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <fs_row> TO <fs_ernam>.
          DATA: lv_user_tzone TYPE tznzone,
                lv_local_date TYPE d,
                lv_local_time TYPE t,
                ts_utc        TYPE timestamp.

          " 1) Lấy timezone người dùng (ưu tiên SY-ZONLO vì luôn có, rồi mới thử class)
          lv_user_tzone = sy-zonlo.
          IF lv_user_tzone IS INITIAL.
            TRY.
                lv_user_tzone = cl_abap_context_info=>get_user_time_zone( ).
              CATCH cx_abap_context_info_error.
                lv_user_tzone = 'UTC'. " fallback an toàn
            ENDTRY.
          ENDIF.

          " 2) Lấy timestamp UTC hiện tại (không phụ thuộc giờ máy chủ)
          GET TIME STAMP FIELD ts_utc.

          " 3) Chuyển UTC -> giờ người dùng
          CONVERT TIME STAMP ts_utc TIME ZONE lv_user_tzone
                  INTO DATE lv_local_date TIME lv_local_time.

          " 4) Gán vào trường của bạn
          IF <fs_erdat> IS ASSIGNED. <fs_erdat> = lv_local_date. ENDIF.
          IF <fs_ertim> IS ASSIGNED. <fs_ertim> = lv_local_time. ENDIF.

          IF <fs_ernam> IS ASSIGNED. <fs_ernam> = sy-uname. ENDIF.

          " Không log audit ở đây – on_save sẽ xử lý

          gv_add_mode     = abap_true.
          gv_edit_md      = abap_true.
          gv_toolbar_mode = 'E'.

          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_ready_for_input( 1 ). CATCH cx_root. ENDTRY.
            g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Focus vào KEY đầu tiên
          PERFORM ensure_keys USING p_tab.
          READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
          IF sy-subrc = 0 AND g_alv_grid IS BOUND.
            DATA ls_row_id TYPE lvc_s_row.
            DATA ls_col_id TYPE lvc_s_col.
            ls_row_id-index     = lines( <fs_tab> ).
            ls_col_id-fieldname = lv_first_key.
            TRY.
                g_alv_grid->set_current_cell_via_id(
                  EXPORTING is_row_id    = ls_row_id
                            is_column_id = ls_col_id ).
                g_alv_grid->set_scroll_info_via_id(
                  EXPORTING is_row_info = ls_row_id
                            is_col_info = ls_col_id ).
              CATCH cx_root.
            ENDTRY.
          ENDIF.
        ENDIF.

      WHEN 'SAVE'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Change (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " Giao toàn bộ cho on_save (đã: check_key_on_add + audit + commit + view mode)
        PERFORM on_save.
        RETURN.

      WHEN 'DELE'.
        PERFORM has_actvt USING '06' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Delete (ACTVT=06).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        DATA: lt_sel_idx TYPE lvc_t_row,
              ls_cur_row TYPE lvc_s_row,
              ls_cur_col TYPE lvc_s_col,
              lv_cnt     TYPE i.
        CLEAR lt_sel_idx.

        IF g_alv_grid IS BOUND.
          TRY. g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ). CATCH cx_root. ENDTRY.
        ENDIF.
        IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
          TRY.
              g_alv_grid->get_current_cell(
                IMPORTING es_row_id = ls_cur_row
                          es_col_id = ls_cur_col ).
            CATCH cx_root.
          ENDTRY.
          IF ls_cur_row-index > 0.
            APPEND VALUE lvc_s_row( index = ls_cur_row-index ) TO lt_sel_idx.
          ENDIF.
        ENDIF.

        lv_cnt = lines( lt_sel_idx ).
        IF lv_cnt = 0.
          MESSAGE 'Vui lòng chọn dòng (hoặc đặt con trỏ) để xóa.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        CLEAR gv_del_newrec_only.
        CLEAR: lv_new_incomplete, lv_other_changes.
        PERFORM is_newrec_target_for_delete CHANGING gv_del_newrec_only.
        PERFORM analyze_change_state       CHANGING lv_new_incomplete lv_other_changes.

        DATA lv_need_confirm TYPE abap_bool VALUE abap_false.
        CLEAR lv_question.

        IF gv_del_newrec_only = abap_true.
          lv_need_confirm = abap_false.
        ELSE.
          lv_need_confirm = abap_true.
          lv_question     = |Bạn có chắc muốn xóa { lv_cnt } dòng đã chọn?|.
        ENDIF.

        IF lv_need_confirm = abap_true.
          CLEAR lv_ans_conf.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Xác nhận xóa'
              text_question         = lv_question(70)
              text_button_1         = 'Xóa'
              text_button_2         = 'Không'
              default_button        = '2'
              display_cancel_button = space
            IMPORTING
              answer                = lv_ans_conf.
          IF lv_ans_conf <> '1'.
            RETURN.
          ENDIF.
        ENDIF.

        CLEAR: lv_msg, lv_err.
        PERFORM delete_selected USING p_tab CHANGING lv_msg lv_err.
        IF lv_err IS INITIAL.
          MESSAGE |{ COND string( WHEN lv_msg IS INITIAL THEN 'Đã xóa và ghi audit.' ELSE lv_msg ) }| TYPE 'S'.
        ELSE.
          MESSAGE |{ lv_err }| TYPE 'S' DISPLAY LIKE 'E'.
        ENDIF.

        IF g_alv_grid IS BOUND.
          g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
          TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
        ENDIF.

      WHEN 'UPLD'.
        PERFORM has_actvt USING '02' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Upload (ACTVT=02).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        PERFORM upload_data_strict_match.

      WHEN 'XLSX' OR 'TMPL' OR 'HIST'.
        PERFORM has_actvt USING '03' CHANGING lv_ok.
        IF lv_ok IS INITIAL.
          MESSAGE 'Bạn không có quyền Display (ACTVT=03).' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.
        CASE e_ucomm.
          WHEN 'XLSX'. PERFORM download_excel_xlsx USING gr_data.
          WHEN 'TMPL'. PERFORM download_template_xlsx.
          WHEN 'HIST'. PERFORM show_audit_history.
        ENDCASE.

    ENDCASE.

    cl_gui_cfw=>flush( ).
  ENDMETHOD.



  METHOD handle_onf4.
    er_event_data->m_event_handled = abap_true.
    DATA: lt_ret   TYPE STANDARD TABLE OF ddshretval,
          ls_ret   TYPE ddshretval,
          lv_value TYPE string,
          lv_done  TYPE abap_bool.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.
    " 1) DDIC search help (nếu có)
    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname    = p_tab
        fieldname  = e_fieldname
        display    = 'F'
      TABLES
        return_tab = lt_ret
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc = 0.
      " ĐÃ gọi được SH chuẩn → không fallback nữa
      IF lt_ret IS NOT INITIAL.
        READ TABLE lt_ret INDEX 1 INTO ls_ret.
        IF sy-subrc = 0.
          lv_value = ls_ret-fieldval.
          lv_done  = abap_true.
        ENDIF.
      ELSE.
        " Người dùng Cancel/không chọn → kết thúc, KHÔNG mở popup fallback
        er_event_data->m_event_handled = 'X'.
        RETURN.
      ENDIF.
    ENDIF.

    " 2) Fallback dynamic từ dữ liệu hiện có
    IF lv_done IS INITIAL.
      DATA lv_current TYPE string.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, đổi internal -> external để dùng làm tiền tố filter
            DATA(lo_d1) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d1->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_current ).
                CATCH cx_abap_datfm.
                  lv_current = <cell>. " fallback
              ENDTRY.
            ELSE.
              lv_current = <cell>.
            ENDIF.
            CONDENSE lv_current.
          ENDIF.
        ENDIF.
      ENDIF.

      TYPES: BEGIN OF ty_val, fieldval TYPE char80, END OF ty_val.
      DATA: lt_vals TYPE STANDARD TABLE OF ty_val WITH DEFAULT KEY,
            ls_val  TYPE ty_val,
            lv_s    TYPE string.

      IF <outtab> IS ASSIGNED.
        LOOP AT <outtab> ASSIGNING <row>.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            " Nếu là DATS, hiển thị external trong popup
            DATA(lo_d2) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).
            IF lo_d2->type_kind = cl_abap_typedescr=>typekind_date.
              TRY.
                  cl_abap_datfm=>conv_date_int_to_ext(
                    EXPORTING im_datint = <cell>
                    IMPORTING ex_datext = lv_s ).
                CATCH cx_abap_datfm.
                  lv_s = <cell>.
              ENDTRY.
            ELSE.
              lv_s = <cell>.
            ENDIF.

            CONDENSE lv_s.
            IF lv_s IS NOT INITIAL AND ( lv_current IS INITIAL OR lv_s CP lv_current && '*' ).
              ls_val-fieldval = lv_s.
              COLLECT ls_val INTO lt_vals.  " distinct
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.


      IF lt_vals IS NOT INITIAL.
        DATA: lt_field_tab TYPE TABLE OF dfies,
              ls_field_tab TYPE dfies,
              lv_coltext   TYPE string.

        " Lấy caption từ fieldcatalog
        lv_coltext = e_fieldname.
        LOOP AT gt_fieldcat ASSIGNING FIELD-SYMBOL(<fc>) WHERE fieldname = e_fieldname.
          IF <fc>-coltext IS NOT INITIAL.
            lv_coltext = <fc>-coltext.
          ELSEIF <fc>-scrtext_m IS NOT INITIAL.
            lv_coltext = <fc>-scrtext_m.
          ENDIF.
          EXIT.
        ENDLOOP.

        CLEAR ls_field_tab.
        ls_field_tab-fieldname = 'FIELDVAL'.
        ls_field_tab-datatype  = 'CHAR'.
        ls_field_tab-inttype   = 'C'.
        ls_field_tab-intlen    = 80.
        ls_field_tab-leng      = 80.
        ls_field_tab-outputlen = 80.
        ls_field_tab-decimals  = 0.
        ls_field_tab-reffield  = ''.
        ls_field_tab-reftable  = ''.
        ls_field_tab-reptext   = lv_coltext.
        ls_field_tab-scrtext_l = lv_coltext.
        ls_field_tab-scrtext_m = lv_coltext.
        ls_field_tab-scrtext_s = lv_coltext.
        APPEND ls_field_tab TO lt_field_tab.

        CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
          EXPORTING
            retfield   = 'FIELDVAL'
            value_org  = 'S'
            display    = 'F'
          TABLES
            value_tab  = lt_vals
            field_tab  = lt_field_tab
            return_tab = lt_ret
          EXCEPTIONS
            OTHERS     = 1.

        IF sy-subrc = 0 AND lt_ret IS NOT INITIAL.
          READ TABLE lt_ret INDEX 1 INTO ls_ret.
          IF sy-subrc = 0.
            lv_value = ls_ret-fieldval.
            lv_done = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    " 3) Gán lại vào ô hiện tại và refresh
    IF lv_done = abap_true.
      ASSIGN gr_data->* TO <outtab>.
      IF <outtab> IS ASSIGNED AND es_row_no-row_id > 0.
        READ TABLE <outtab> INDEX es_row_no-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT e_fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS ASSIGNED.
            DATA(lo_desc) = cl_abap_typedescr=>describe_by_data_ref( REF #( <cell> ) ).

            IF lo_desc->type_kind = cl_abap_typedescr=>typekind_date.
              DATA lv_date_int TYPE d.
              TRY.
                  cl_abap_datfm=>conv_date_ext_to_int(
                    EXPORTING im_datext = lv_value
                    IMPORTING ex_datint = lv_date_int ).
                  <cell> = lv_date_int.
                CATCH cx_abap_datfm .
                  TRY. <cell> = lv_value. CATCH cx_root. ENDTRY.
              ENDTRY.
            ELSE.
              <cell> = lv_value.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      TRY.
          g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        CATCH cx_root.
      ENDTRY.
      cl_gui_cfw=>flush( ).
      er_event_data->m_event_handled = 'X'.
    ENDIF.
  ENDMETHOD.


  METHOD handle_data_changed.
    DATA: lt_mod TYPE lvc_t_modi,
          ls_mod TYPE lvc_s_modi.

    FIELD-SYMBOLS: <outtab> TYPE STANDARD TABLE,
                   <row>    TYPE any,
                   <cell>   TYPE any.

    ASSIGN gr_data->* TO <outtab>.
    IF <outtab> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    lt_mod = er_data_changed->mt_mod_cells.

    LOOP AT lt_mod INTO ls_mod.

      "--- 1) KEY: chỉ cho phép khi đang Add và dòng NEWREC = 'X'
      READ TABLE gt_key_fields WITH KEY table_line = ls_mod-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc = 0. " là KEY
        DATA(lv_block_key) = abap_true.
        IF gv_add_mode = abap_true AND ls_mod-row_id > 0.
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0 AND <cell> = 'X'.
              lv_block_key = abap_false.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_block_key = abap_true.
          " trả lại giá trị cũ
          READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
          IF sy-subrc = 0.
            ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
            IF sy-subrc = 0.
              er_data_changed->modify_cell(
                EXPORTING i_row_id    = ls_mod-row_id
                          i_fieldname = ls_mod-fieldname
                          i_value     = <cell> ).
              er_data_changed->add_protocol_entry(
                i_msgid = '00' i_msgno = '398' i_msgty = 'E'
                i_fieldname = ls_mod-fieldname
                i_row_id   = ls_mod-row_id
                i_msgv1    = |Field { ls_mod-fieldname } is not editable (key)| ).
            ENDIF.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      "--- 2) Non-key: chỉ cho phép khi đang Edit
      IF gv_edit_md <> abap_true.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT ls_mod-fieldname OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0.
            er_data_changed->modify_cell(
              EXPORTING i_row_id    = ls_mod-row_id
                        i_fieldname = ls_mod-fieldname
                        i_value     = <cell> ).
            er_data_changed->add_protocol_entry(
              i_msgid = '00' i_msgno = '398' i_msgty = 'E'
              i_fieldname = ls_mod-fieldname
              i_row_id   = ls_mod-row_id
              i_msgv1    = |Field { ls_mod-fieldname } is read-only in View mode| ).
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      "--- 3) Đánh dấu dirty CHỈ khi không phải dòng NEWREC
      DATA(lv_is_newrec) = abap_false.
      IF ls_mod-row_id > 0.
        READ TABLE <outtab> INDEX ls_mod-row_id ASSIGNING <row>.
        IF sy-subrc = 0.
          ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <row> TO <cell>.
          IF sy-subrc = 0 AND <cell> = 'X'.
            lv_is_newrec = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.

      IF lv_is_newrec = abap_false.
        " thay đổi trên dòng cũ -> coi là dirty để còn hỏi lưu
        gv_dirty = abap_true.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.


ENDCLASS.


*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
  SET PF-STATUS 'MAIN100'.
  SET TITLEBAR 'T100'.
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PBO_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE pbo_0100 OUTPUT.
  PERFORM check_authorization.
  PERFORM ensure_keys USING p_tab.
  FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.
  ASSIGN gr_data->* TO <fs_table>.

  IF <fs_table> IS ASSIGNED AND <fs_table> IS NOT INITIAL.
    PERFORM merge_audit_log USING p_tab CHANGING <fs_table>.
  ENDIF.

  IF <fs_table> IS NOT ASSIGNED OR <fs_table> IS INITIAL.
    MESSAGE 'Không có dữ liệu để hiển thị' TYPE 'I'.
    LEAVE TO SCREEN 0.
    RETURN.
  ENDIF.

  TRY.
      "=== Chuẩn bị Fieldcatalog ===
      IF gt_fieldcat IS INITIAL.
        PERFORM build_fieldcat_all.
      ENDIF.
      PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.
      PERFORM enable_f4_in_fieldcat. " Bật cờ F4 cho tất cả cột

      "=== Tạo container & grid nếu lần đầu ===
      IF g_container IS INITIAL OR g_alv_grid IS INITIAL.
        CREATE OBJECT g_container EXPORTING container_name = gc_cc_alv.
        CREATE OBJECT g_alv_grid EXPORTING i_parent = g_container.
        g_alv_grid->set_toolbar_interactive( ).

        " Gắn các handler
        IF g_handler IS INITIAL.
          CREATE OBJECT g_handler.
          SET HANDLER g_handler->handle_toolbar FOR g_alv_grid.
          SET HANDLER g_handler->handle_user_command FOR g_alv_grid.
          SET HANDLER g_handler->handle_onf4 FOR g_alv_grid.
          SET HANDLER g_handler->handle_data_changed FOR g_alv_grid.
        ENDIF.

        " Layout
        gs_layout = VALUE #( edit = abap_true zebra = abap_true
        cwidth_opt = abap_true stylefname = 'CELLTAB' ).

        PERFORM ensure_celltab_component CHANGING gr_data.
        ASSIGN gr_data->* TO <fs_table>.

        g_alv_grid->set_table_for_first_display(
        EXPORTING is_layout = gs_layout
        CHANGING it_outtab = <fs_table>
        it_fieldcatalog = gt_fieldcat ).
      ELSE.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
      ENDIF.
      PERFORM apply_editability_and_push.
      PERFORM register_f4_all.
      TRY.
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_enter ).
          g_alv_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_modified ).
        CATCH cx_root.
      ENDTRY.

      "=== Bật/tắt input cho grid ===
      g_alv_grid->set_ready_for_input(
      COND i( WHEN gv_edit_md = abap_true THEN 1 ELSE 0 ) ).

    CATCH cx_root.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE #( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.


*&---------------------------------------------------------------------*
*& Module PAI_0100 INPUT
*&---------------------------------------------------------------------*

MODULE pai_0100 INPUT.
  g_okcode = sy-ucomm.
  CLEAR sy-ucomm.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
  ENDIF.

  TRY.
      CASE g_okcode.

        WHEN 'BACK' OR 'CANC' OR 'EXIT'.

          " Đẩy giá trị đang nhập về itab trước khi so sánh
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->check_changed_data( ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Phân tích thay đổi chi tiết
          DATA: lv_has_change_exit         TYPE abap_bool,
                lv_new_incomplete_cnt_exit TYPE i,
                lv_new_complete_cnt_exit   TYPE i,
                lv_edit_existing_cnt_exit  TYPE i,
                lv_ans_exit                TYPE c,
                lv_text_exit               TYPE c LENGTH 200.

          CLEAR: lv_has_change_exit,
                 lv_new_incomplete_cnt_exit,
                 lv_new_complete_cnt_exit,
                 lv_edit_existing_cnt_exit.

          PERFORM analyze_change_state_detailed
            CHANGING lv_has_change_exit
                     lv_new_incomplete_cnt_exit
                     lv_new_complete_cnt_exit
                     lv_edit_existing_cnt_exit.

          " Không có thay đổi -> thoát luôn
          IF lv_has_change_exit = abap_false.
            LEAVE TO SCREEN 0.
            RETURN.
          ENDIF.

          " --- CASE 1: CHỈ NEWREC THIẾU KHÓA ---
          IF     lv_new_incomplete_cnt_exit > 0
             AND lv_new_complete_cnt_exit   = 0
             AND lv_edit_existing_cnt_exit  = 0.

            lv_text_exit = |Có | && lv_new_incomplete_cnt_exit &&
                           | dòng mới CHƯA NHẬP ĐỦ KHÓA. Bỏ dòng mới và thoát?|.
            CLEAR lv_ans_exit.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Dòng mới thiếu khóa'
                text_question         = lv_text_exit
                text_button_1         = 'Bỏ & Thoát'
                text_button_2         = 'Quay lại'
                default_button        = '2'
                display_cancel_button = space
              IMPORTING
                answer                = lv_ans_exit.

            IF lv_ans_exit = '1'.
              PERFORM purge_incomplete_newrecs.
              LEAVE TO SCREEN 0.
            ELSE.
              " Ở lại màn hình, GIỮ EDIT
              PERFORM stay_in_edit_and_focus.
              " --- Neo an toàn ---
              gv_edit_md      = abap_true.
              gv_toolbar_mode = 'E'.
              PERFORM apply_editability_and_push.
              IF g_alv_grid IS BOUND.
                TRY.
                    g_alv_grid->set_ready_for_input( 1 ).
                    g_alv_grid->refresh_table_display(
                      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                    g_alv_grid->set_toolbar_interactive( ).
                  CATCH cx_root.
                ENDTRY.
              ENDIF.
              CLEAR g_okcode.
              cl_gui_cfw=>flush( ).
              RETURN.
            ENDIF.

          " --- CASE 2: CHỈ NEWREC ĐỦ KHÓA (chưa lưu) ---
          ELSEIF lv_new_complete_cnt_exit   > 0
             AND lv_edit_existing_cnt_exit  = 0
             AND lv_new_incomplete_cnt_exit = 0.

            lv_text_exit = |Có | && lv_new_complete_cnt_exit &&
                           | dòng mới CHƯA LƯU. Lưu trước khi thoát?|.
            CLEAR lv_ans_exit.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Dòng mới chưa lưu'
                text_question         = lv_text_exit
                text_button_1         = 'Lưu'
                text_button_2         = 'Không lưu'
                default_button        = '1'
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_ans_exit.

            CASE lv_ans_exit.
              WHEN '1'. " Lưu rồi thoát nếu OK
                PERFORM on_save.
                IF gv_dirty = abap_true.
                  " Lưu lỗi -> ở lại màn hình (GIỮ EDIT)
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
                  RETURN.
                ENDIF.
                LEAVE TO SCREEN 0.

              WHEN '2'. " Không lưu -> bỏ thay đổi rồi thoát
                PERFORM discard_unsaved_changes.
                LEAVE TO SCREEN 0.

              WHEN 'A'. " Cancel -> ở lại và giữ Edit
                PERFORM stay_in_edit_and_focus.
                gv_edit_md      = abap_true.
                gv_toolbar_mode = 'E'.
                PERFORM apply_editability_and_push.
                IF g_alv_grid IS BOUND.
                  TRY.
                      g_alv_grid->set_ready_for_input( 1 ).
                      g_alv_grid->refresh_table_display(
                        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                      g_alv_grid->set_toolbar_interactive( ).
                    CATCH cx_root.
                  ENDTRY.
                ENDIF.
                CLEAR g_okcode.
                cl_gui_cfw=>flush( ).
                RETURN.
            ENDCASE.

          " --- CASE 3: CHỈ sửa dòng DB cũ ---
          ELSEIF lv_edit_existing_cnt_exit  > 0
             AND lv_new_incomplete_cnt_exit = 0
             AND lv_new_complete_cnt_exit   = 0.

            lv_text_exit = 'Bạn đã sửa dữ liệu trên dòng hiện có. Lưu trước khi thoát?'.
            CLEAR lv_ans_exit.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Thay đổi chưa lưu'
                text_question         = lv_text_exit
                text_button_1         = 'Lưu'
                text_button_2         = 'Không lưu'
                default_button        = '1'
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_ans_exit.

            CASE lv_ans_exit.
              WHEN '1'.
                PERFORM on_save.
                IF gv_dirty = abap_true.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
                  RETURN.
                ENDIF.
                LEAVE TO SCREEN 0.

              WHEN '2'.
                PERFORM discard_unsaved_changes.
                LEAVE TO SCREEN 0.

              WHEN 'A'.
                PERFORM stay_in_edit_and_focus.
                gv_edit_md      = abap_true.
                gv_toolbar_mode = 'E'.
                PERFORM apply_editability_and_push.
                IF g_alv_grid IS BOUND.
                  TRY.
                      g_alv_grid->set_ready_for_input( 1 ).
                      g_alv_grid->refresh_table_display(
                        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                      g_alv_grid->set_toolbar_interactive( ).
                    CATCH cx_root.
                  ENDTRY.
                ENDIF.
                CLEAR g_okcode.
                cl_gui_cfw=>flush( ).
                RETURN.
            ENDCASE.

          " --- CASE 4: HỖN HỢP ---
          ELSE.
            lv_text_exit = |Có thay đổi chưa lưu: | &&
                           lv_new_incomplete_cnt_exit && ' NEWREC thiếu khóa, ' &&
                           lv_new_complete_cnt_exit   && ' NEWREC đủ khóa, ' &&
                           lv_edit_existing_cnt_exit  && ' thay đổi dòng cũ. Lưu trước khi thoát?'.
            CLEAR lv_ans_exit.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Thay đổi chưa lưu'
                text_question         = lv_text_exit
                text_button_1         = 'Lưu'
                text_button_2         = 'Không lưu'
                default_button        = '1'
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_ans_exit.

            CASE lv_ans_exit.
              WHEN '1'.
                PERFORM on_save.
                IF gv_dirty = abap_true.
                  PERFORM stay_in_edit_and_focus.
                  gv_edit_md      = abap_true.
                  gv_toolbar_mode = 'E'.
                  PERFORM apply_editability_and_push.
                  IF g_alv_grid IS BOUND.
                    TRY.
                        g_alv_grid->set_ready_for_input( 1 ).
                        g_alv_grid->refresh_table_display(
                          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                        g_alv_grid->set_toolbar_interactive( ).
                      CATCH cx_root.
                    ENDTRY.
                  ENDIF.
                  CLEAR g_okcode.
                  cl_gui_cfw=>flush( ).
                  RETURN.
                ENDIF.
                LEAVE TO SCREEN 0.

              WHEN '2'.
                PERFORM discard_unsaved_changes.
                LEAVE TO SCREEN 0.

              WHEN 'A'.
                PERFORM stay_in_edit_and_focus.
                gv_edit_md      = abap_true.
                gv_toolbar_mode = 'E'.
                PERFORM apply_editability_and_push.
                IF g_alv_grid IS BOUND.
                  TRY.
                      g_alv_grid->set_ready_for_input( 1 ).
                      g_alv_grid->refresh_table_display(
                        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
                      g_alv_grid->set_toolbar_interactive( ).
                    CATCH cx_root.
                  ENDTRY.
                ENDIF.
                CLEAR g_okcode.
                cl_gui_cfw=>flush( ).
                RETURN.
            ENDCASE.
          ENDIF.

        WHEN 'SAVE'.
          PERFORM on_save.

          " Reset trạng thái sau khi lưu thành công
          gv_dirty        = abap_false.
          gv_add_mode     = abap_false.
          gv_edit_md      = abap_false.
          gv_toolbar_mode = 'D'.

          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
          ENDIF.

          " Xóa NEWREC ở tất cả dòng nếu có
          FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                         <ls>     TYPE any,
                         <newrec> TYPE any.
          ASSIGN gr_data->* TO <lt>.
          IF <lt> IS ASSIGNED.
            LOOP AT <lt> ASSIGNING <ls>.
              ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
              IF sy-subrc = 0.
                CLEAR <newrec>.
              ENDIF.
            ENDLOOP.
          ENDIF.

          PERFORM apply_editability_and_push.
          IF g_alv_grid IS BOUND.
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

        WHEN OTHERS.
          " Chỉ refresh cho chắc
          IF g_alv_grid IS BOUND.
            g_alv_grid->refresh_table_display(
              EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
            TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
          ENDIF.

      ENDCASE.

    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.
  ENDTRY.

  cl_gui_cfw=>flush( ).
ENDMODULE.

*&---------------------------------------------------------------------*
*& sap xep ERDAT
*&---------------------------------------------------------------------*

FORM reorder_audit_cols CHANGING ct_fcat TYPE lvc_t_fcat.
  DATA lt_keep  TYPE lvc_t_fcat.
  DATA lt_audit TYPE lvc_t_fcat.
  DATA ls       TYPE lvc_s_fcat.
  FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.

  " 1) Tách nhóm audit ra khỏi danh sách
  LOOP AT ct_fcat ASSIGNING <fc>.
    DATA(lvfn) = to_upper( <fc>-fieldname ).
    IF lvfn = 'ERDAT' OR lvfn = 'ERTIM' OR lvfn = 'ERNAM'
     OR lvfn = 'AEDAT' OR lvfn = 'AETIM' OR lvfn = 'AENAM'.
      APPEND <fc> TO lt_audit.
    ELSE.
      APPEND <fc> TO lt_keep.
    ENDIF.
  ENDLOOP.

  " 2) Ghép lại: business trước, rồi audit theo thứ tự mong muốn
  REFRESH ct_fcat.
  APPEND LINES OF lt_keep TO ct_fcat.

  DEFINE _append_audit.
    READ TABLE lt_audit INTO ls WITH KEY fieldname = &1.
    IF sy-subrc = 0.
      APPEND ls TO ct_fcat.
    ENDIF.
  END-OF-DEFINITION.

  _append_audit 'ERDAT'.   " Ngày tạo  -> muốn đứng ngay trước Created Time/By
  _append_audit 'ERTIM'.   " Created Time
  _append_audit 'ERNAM'.   " Created By
  _append_audit 'AEDAT'.   " Changed On
  _append_audit 'AETIM'.   " Changed Time
  _append_audit 'AENAM'.   " Changed By

  " 3) Refresh lại COL_POS để cố định vị trí
  DATA lv_pos TYPE i VALUE 1.
  LOOP AT ct_fcat ASSIGNING <fc>.
    <fc>-col_pos = lv_pos.
    lv_pos += 1.
  ENDLOOP.
ENDFORM.


FORM apply_editability_and_push.
  " 0) Đảm bảo danh sách KEY
  PERFORM ensure_keys USING p_tab.

  "=== Danh sách field audit cần khóa cứng
  DATA: lt_audit TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY.
  APPEND 'ERDAT' TO lt_audit.
  APPEND 'ERTIM' TO lt_audit.
  APPEND 'ERNAM' TO lt_audit.
  APPEND 'AEDAT' TO lt_audit.
  APPEND 'AETIM' TO lt_audit.
  APPEND 'AENAM' TO lt_audit.

  " 1) Fieldcatalog (cấp cột)
  "    - KEY: chỉ mở khi đang Add (dòng NEWREC)
  "    - Non-key: mở khi Edit
  "    - AUDIT: luôn đóng (edit = space, f4 = space)
  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.
  DATA: lv_is_key   TYPE abap_bool,
        lv_is_audit TYPE abap_bool.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      CONTINUE.
    ENDIF.

    " Audit? -> khóa cứng
    lv_is_audit = abap_false.
    READ TABLE lt_audit WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_is_audit = abap_true.
    ENDIF.

    IF lv_is_audit = abap_true.
      CLEAR: <fc>-edit, <fc>-f4availabl.
      CONTINUE. " bỏ qua các quyết định edit khác
    ENDIF.

    " Key / Non-key
    lv_is_key = abap_false.
    READ TABLE gt_key_fields WITH KEY table_line = <fc>-fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. lv_is_key = abap_true. ENDIF.

    IF lv_is_key = abap_true.
      IF gv_add_mode = abap_true.
        <fc>-edit       = 'X'.
        <fc>-f4availabl = 'X'.
      ELSE.
        CLEAR: <fc>-edit, <fc>-f4availabl.
      ENDIF.
    ELSE.
      IF gv_edit_md = abap_true.
        <fc>-edit = 'X'.
      ELSE.
        CLEAR <fc>-edit.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " 2) Style theo dòng (cấp ô)
  "    - KEY enabled chỉ khi Add + dòng NEWREC = 'X'
  "    - AUDIT luôn disabled
  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <celltab> TYPE lvc_t_styl,
                 <newrec>  TYPE any.
  DATA: ls_styl   TYPE lvc_s_styl,
        lv_key    TYPE dd03l-fieldname,
        lv_is_new TYPE abap_bool,
        lv_af     TYPE lvc_fname.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'CELLTAB' OF STRUCTURE <ls> TO <celltab>.
      IF sy-subrc <> 0. CONTINUE. ENDIF.
      CLEAR <celltab>.

      " Dòng mới?
      lv_is_new = abap_false.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'. lv_is_new = abap_true. ENDIF.

      " Khóa/mở cho KEY
      LOOP AT gt_key_fields INTO lv_key.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_key.
        IF gv_add_mode = abap_true AND lv_is_new = abap_true.
          ls_styl-style = cl_gui_alv_grid=>mc_style_enabled.     " cho nhập KEY ở dòng NEW
        ELSE.
          ls_styl-style = cl_gui_alv_grid=>mc_style_disabled.    " xám, không caret
        ENDIF.

        " Chỉ chèn nếu chưa có trong CELLTAB
        READ TABLE <celltab> WITH KEY fieldname = ls_styl-fieldname style = ls_styl-style TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          INSERT ls_styl INTO TABLE <celltab>.
        ENDIF.
      ENDLOOP.

      " Luôn khóa các cột audit
      LOOP AT lt_audit INTO lv_af.
        CLEAR ls_styl.
        ls_styl-fieldname = lv_af.
        ls_styl-style     = cl_gui_alv_grid=>mc_style_disabled.

        " Chỉ chèn nếu chưa có
        READ TABLE <celltab> WITH KEY fieldname = ls_styl-fieldname style = ls_styl-style TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          INSERT ls_styl INTO TABLE <celltab>.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

  "=== 2b) Tô màu dòng NEWREC/không hợp lệ bằng ROW_COLOR ===
  " Ưu tiên: INVALID (đỏ=6) > NEWREC (xanh=5)
  FIELD-SYMBOLS: <upload_flag> TYPE any,
                 <valid_flag>  TYPE any,
                 <row_color>   TYPE lvc_t_scol.
  DATA: lt_cols  TYPE STANDARD TABLE OF lvc_fname WITH DEFAULT KEY,
        lv_fname TYPE lvc_fname,
        lt_scol  TYPE lvc_t_scol,
        ls_scol  TYPE lvc_s_scol.

  CLEAR lt_cols.
  LOOP AT gt_fieldcat ASSIGNING <fc> WHERE tech <> abap_true AND no_out <> abap_true.
    APPEND <fc>-fieldname TO lt_cols.
  ENDLOOP.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls> TO <row_color>.
    IF sy-subrc <> 0. CONTINUE. ENDIF.

    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <upload_flag>.
    ASSIGN COMPONENT 'VALID'  OF STRUCTURE <ls> TO <valid_flag>.

    CLEAR lt_scol.

    IF <valid_flag> IS ASSIGNED AND <valid_flag> IS INITIAL.
      LOOP AT lt_cols INTO lv_fname.
        CLEAR ls_scol.
        ls_scol-fname     = lv_fname.
        ls_scol-color-col = 6.
        ls_scol-color-int = 0.
        ls_scol-color-inv = 0.
        APPEND ls_scol TO lt_scol.
      ENDLOOP.
    ELSEIF <upload_flag> IS ASSIGNED AND <upload_flag> = 'X'.
      LOOP AT lt_cols INTO lv_fname.
        CLEAR ls_scol.
        ls_scol-fname     = lv_fname.
        ls_scol-color-col = 5.
        ls_scol-color-int = 0.
        ls_scol-color-inv = 0.
        APPEND ls_scol TO lt_scol.
      ENDLOOP.
    ENDIF.

    <row_color> = lt_scol.
  ENDLOOP.

" 3) Đẩy xuống frontend & refresh
  PERFORM dedup_fieldcat.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_frontend_fieldcatalog( it_fieldcatalog = gt_fieldcat ).
      CATCH cx_root.
    ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
  ENDIF.
ENDFORM.

FORM stay_in_edit_and_focus.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.

  " 1) Giữ Edit; Add-mode nếu vẫn còn NEWREC
  gv_edit_md      = abap_true.
  gv_toolbar_mode = 'E'.

  gv_add_mode = abap_false.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        gv_add_mode = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " 2) Áp rule + bật input + rebuild toolbar
  PERFORM apply_editability_and_push.
  PERFORM register_f4_all.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->set_ready_for_input( 1 ).
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " 3) Focus về KEY của dòng NEWREC (nếu có)
  PERFORM focus_key_on_newrec.

  cl_gui_cfw=>flush( ).
ENDFORM.


*=====================================================================*
* INCLUDE ZFA25SAP23_IO - Đọc / Upload dữ liệu Excel (.XLSX, .XLS)
*=====================================================================*

TYPES: BEGIN OF alsmex_tabline,
         row   TYPE i,
         col   TYPE i,
         value TYPE string,
       END OF alsmex_tabline.
TYPES: ty_t_alsmex_tab TYPE STANDARD TABLE OF alsmex_tabline WITH DEFAULT KEY.

*---------------------------------------------------------------------*
* FORM read_xlsx_clfdt - Đọc file .XLSX bằng class CL_FDT_XL_SPREADSHEET
*---------------------------------------------------------------------*
FORM read_xlsx_clfdt USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.

  DATA: lt_bin   TYPE solix_tab,
        lv_xstr  TYPE xstring,
        lv_file  TYPE string,
        lo_excel TYPE REF TO cl_fdt_xl_spreadsheet,
        lt_names TYPE if_fdt_doc_spreadsheet=>t_worksheet_names,
        lv_sheet TYPE string,
        lr_src   TYPE REF TO data,
        lt_cells TYPE STANDARD TABLE OF alsmex_tabline,
        ls_cell  TYPE alsmex_tabline.

  FIELD-SYMBOLS: <lt_src> TYPE STANDARD TABLE,
                 <ls_src> TYPE any,
                 <lv_any> TYPE any,
                 <lt_ret> TYPE STANDARD TABLE.

  lv_file = iv_file.

  "--- Upload file Excel (.xlsx) dạng nhị phân ---
  cl_gui_frontend_services=>gui_upload(
  EXPORTING filename = lv_file filetype = 'BIN'
  CHANGING data_tab = lt_bin ).

  IF sy-subrc <> 0.
    MESSAGE 'Không đọc được file .xlsx từ frontend' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_xstr = cl_bcs_convert=>solix_to_xstring( lt_bin ).

  "--- Đọc nội dung file Excel ---
  CREATE OBJECT lo_excel
    EXPORTING
      xdocument     = lv_xstr
      document_name = 'UPLOAD_EXCEL'.

  lo_excel->if_fdt_doc_spreadsheet~get_worksheet_names(
  IMPORTING worksheet_names = lt_names ).
  READ TABLE lt_names INDEX 1 INTO lv_sheet.

  IF sy-subrc <> 0 OR lv_sheet IS INITIAL.
    MESSAGE 'Không xác định được worksheet đầu tiên' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_src = lo_excel->if_fdt_doc_spreadsheet~get_itab_from_worksheet( lv_sheet ).
  ASSIGN lr_src->* TO <lt_src>.
  IF <lt_src> IS NOT ASSIGNED.
    MESSAGE 'Không đọc được dữ liệu từ worksheet' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Lấy mô tả cấu trúc bảng ---
  DATA lo_tabdesc TYPE REF TO cl_abap_tabledescr.
  DATA lo_linedesc TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  lo_tabdesc ?= cl_abap_typedescr=>describe_by_data( <lt_src> ).
  lo_linedesc ?= CAST cl_abap_structdescr( lo_tabdesc->get_table_line_type( ) ).
  lt_comp = lo_linedesc->get_components( ).

  "--- Chuyển dữ liệu từ Excel → ALSMEX_TABLINE ---
  DATA lv_row TYPE i VALUE 0.
  LOOP AT <lt_src> ASSIGNING <ls_src>.
    lv_row = lv_row + 1.
    DATA(lv_col) = 0.
    LOOP AT lt_comp INTO DATA(ls_comp).
      ASSIGN COMPONENT ls_comp-name OF STRUCTURE <ls_src> TO <lv_any>.
      lv_col = lv_col + 1.

      CLEAR ls_cell.
      ls_cell-row = lv_row.
      ls_cell-col = lv_col.
      ls_cell-value = <lv_any>.
      APPEND ls_cell TO lt_cells.
    ENDLOOP.
  ENDLOOP.

  "--- Gán dữ liệu trả ra ---
  CREATE DATA cr_cells LIKE lt_cells.
  ASSIGN cr_cells->* TO <lt_ret>.
  IF <lt_ret> IS ASSIGNED.
    <lt_ret> = lt_cells.
  ENDIF.

  "--- Trích header (dòng 1) ---
  DATA lt_header TYPE STANDARD TABLE OF string.
  LOOP AT lt_cells INTO ls_cell WHERE row = 1.
    APPEND ls_cell-value TO lt_header.
  ENDLOOP.

  IF lt_header IS INITIAL.
    MESSAGE 'Không xác định được tiêu đề (header) trong Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  ct_header = lt_header.

  DESCRIBE TABLE lt_cells LINES DATA(lv_cnt).
  " Bỏ WRITE để không mở list
  " WRITE: / 'Số dòng đọc từ Excel:', lv_cnt.

  IF lv_cnt = 0.
    MESSAGE 'Không đọc được dữ liệu từ Excel (lt_cells = 0 dòng)' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
ENDFORM.


*---------------------------------------------------------------------*
* FORM read_xls_fm - Đọc file .XLS bằng FM cũ ALSM_EXCEL_TO_INTERNAL_TABLE
*---------------------------------------------------------------------*
FORM read_xls_fm USING iv_file TYPE rlgrap-filename
CHANGING cr_cells TYPE REF TO data
ct_header TYPE STANDARD TABLE.
  " SAP GUI đời mới không còn OLE, nên gọi lại form read_xlsx_clfdt
  PERFORM read_xlsx_clfdt USING iv_file CHANGING cr_cells ct_header.
ENDFORM.


*---------------------------------------------------------------------*
* FORM upload_data_strict_match - Upload Excel → ALV data
*---------------------------------------------------------------------*
FORM upload_data_strict_match.

  TYPES: BEGIN OF alsmex_tabline,
           row   TYPE i,
           col   TYPE i,
           value TYPE string,
         END OF alsmex_tabline.

  DATA: lv_filename TYPE rlgrap-filename,
        lt_file     TYPE filetable,
        ls_file     TYPE file_table,
        ls_fc       TYPE lvc_s_fcat,
        lv_rc       TYPE i,
        lr_cells    TYPE REF TO data,
        lt_str      TYPE STANDARD TABLE OF alsmex_tabline,
        lt_header   TYPE STANDARD TABLE OF string,
        lv_msg      TYPE string.

  "=== 1) Hộp thoại chọn file Excel ===
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title      = 'Chọn file Excel để upload'
      default_extension = 'XLSX'
      file_filter       = 'Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls|All files (*.*)|*.*'
      multiselection    = abap_false
    CHANGING
      file_table        = lt_file
      rc                = lv_rc
    EXCEPTIONS
      OTHERS            = 1.

  IF lv_rc < 1 OR sy-subrc <> 0.
    MESSAGE 'Upload bị hủy hoặc lỗi khi chọn file' TYPE 'I'.
    RETURN.
  ENDIF.

  READ TABLE lt_file INTO ls_file INDEX 1.
  IF sy-subrc <> 0 OR ls_file-filename IS INITIAL.
    MESSAGE 'Không đọc được đường dẫn file' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_filename = ls_file-filename.

  "=== 2) Đọc dữ liệu Excel ===
  IF lv_filename CP '*.xlsx' OR lv_filename CP '*.XLSX'.
    PERFORM read_xlsx_clfdt USING lv_filename CHANGING lr_cells lt_header.
  ELSEIF lv_filename CP '*.xls' OR lv_filename CP '*.XLS'.
    PERFORM read_xls_fm USING lv_filename CHANGING lr_cells lt_header.
  ELSE.
    MESSAGE 'Định dạng file không được hỗ trợ (chỉ .xls / .xlsx)' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lr_cells IS INITIAL.
    MESSAGE 'Không đọc được dữ liệu từ file Excel' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  FIELD-SYMBOLS: <lt_str>      TYPE ty_t_alsmex_tab,
                 <ls_line_hdr> TYPE alsmex_tabline.

  ASSIGN lr_cells->* TO <lt_str>.
  IF <lt_str> IS INITIAL.
    MESSAGE 'File Excel rỗng hoặc lỗi định dạng' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 3b) Kiểm tra header Excel khớp DDIC ===
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        ls_ddic_field  TYPE dfies,
        lt_missing     TYPE STANDARD TABLE OF string,
        lt_extra       TYPE STANDARD TABLE OF string.

  "--- Lấy metadata từ DDIC ---
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname        = p_tab
    TABLES
      dfies_tab      = lt_ddic_fields
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.

  IF sy-subrc <> 0 OR lt_ddic_fields IS INITIAL.
    MESSAGE |Không lấy được metadata của bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "--- Bỏ các field kỹ thuật không cần upload ---
  DELETE lt_ddic_fields WHERE fieldname = 'MANDT' OR keyflag = 'X'.

  "--- Chuẩn hóa tên header Excel ---
  LOOP AT lt_header INTO DATA(lv_header_norm).
    lv_header_norm = to_upper( condense( lv_header_norm ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_header_norm WITH ''.
    CONDENSE lv_header_norm NO-GAPS.
    MODIFY lt_header FROM lv_header_norm INDEX sy-tabix.
  ENDLOOP.

  "--- Chuẩn hóa tên field DDIC ---
  DATA lt_ddic_names TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
  LOOP AT lt_ddic_fields INTO ls_ddic_field.
    DATA(lv_ddic_norm) = to_upper( condense( ls_ddic_field-fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_ddic_norm WITH ''.
    CONDENSE lv_ddic_norm NO-GAPS.
    APPEND lv_ddic_norm TO lt_ddic_names.
  ENDLOOP.

  "--- So sánh 2 danh sách ---
  LOOP AT lt_ddic_names INTO DATA(lv_fieldname).
    READ TABLE lt_header WITH KEY table_line = lv_fieldname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Thiếu cột trong Excel: { lv_fieldname }| TO lt_missing.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_header INTO DATA(lv_hdrname).
    READ TABLE lt_ddic_names WITH KEY table_line = lv_hdrname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND |Cột thừa trong Excel: { lv_hdrname }| TO lt_extra.
    ENDIF.
  ENDLOOP.

  "--- Báo lỗi nếu có thiếu/thừa ---
  IF lt_missing IS NOT INITIAL.
    LOOP AT lt_missing INTO DATA(lv_miss).
      MESSAGE lv_miss TYPE 'S' DISPLAY LIKE 'E'.
    ENDLOOP.
    MESSAGE |Header Excel bị thiếu cột so với bảng { p_tab }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF lt_extra IS NOT INITIAL.
    LOOP AT lt_extra INTO DATA(lv_ext).
      MESSAGE lv_ext TYPE 'S' DISPLAY LIKE 'W'.
    ENDLOOP.
    MESSAGE |Excel có thêm cột không nằm trong bảng { p_tab }| TYPE 'S'.
  ENDIF.

  "--- Nếu mọi thứ ổn ---
  MESSAGE |Header Excel hợp lệ, khớp với bảng { p_tab }| TYPE 'S'.

  "=== 6) Gán dữ liệu vào GR_DATA ===
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any,
                 <val>     TYPE any.

  ASSIGN gr_data->* TO <lt_data>.
  IF sy-subrc <> 0 OR <lt_data> IS NOT ASSIGNED.
    MESSAGE 'Lỗi gán GR_DATA' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_data>.

  " Cache metadata của bảng để tránh gọi lại mỗi cell
  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = p_tab
    TABLES
      dfies_tab = lt_ddic_fields
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT <lt_str> INTO DATA(ls_cell) WHERE row > 1.
    READ TABLE lt_header INDEX ls_cell-col INTO DATA(lv_hdr_fieldname).
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    " Chuẩn hóa tên field
    lv_fieldname = to_upper( condense( lv_hdr_fieldname ) ).
    REPLACE ALL OCCURRENCES OF '_' IN lv_hdr_fieldname WITH ''.
    CONDENSE lv_hdr_fieldname NO-GAPS.

    READ TABLE gt_fieldnames INTO DATA(lv_real_field) WITH KEY table_line = lv_hdr_fieldname.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    READ TABLE <lt_data> INDEX ( ls_cell-row - 1 ) ASSIGNING <ls_data>.
    IF sy-subrc <> 0.
      APPEND INITIAL LINE TO <lt_data> ASSIGNING <ls_data>.
    ENDIF.



    ASSIGN COMPONENT lv_real_field OF STRUCTURE <ls_data> TO <val>.
    IF <val> IS ASSIGNED.

      "-----------------------------------------------------------
      " 🔹 [1] Lấy metadata field từ DDIC
      "-----------------------------------------------------------
      READ TABLE lt_ddic_fields INTO DATA(ls_ddic) WITH KEY fieldname = lv_real_field.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      DATA(lv_val_excel) = ls_cell-value.
      DATA(lv_type) = ls_ddic-inttype.
      DATA(lv_valid) = abap_true.

      "-----------------------------------------------------------
      " 🔹 [2] Kiểm tra kiểu dữ liệu cơ bản (DATE, TIME, NUMERIC…)
      "-----------------------------------------------------------
      lv_valid = abap_true.
      CASE lv_type.
        WHEN 'D'. " Date
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_date) = CONV d( lv_val_excel ).

                CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
                  EXPORTING
                    date                      = lv_date
                  EXCEPTIONS
                    plausibility_check_failed = 1
                    OTHERS                    = 2.

                IF sy-subrc <> 0.
                  lv_valid = abap_false. " Ngày không hợp lệ (ví dụ 30/02/2025)
                ENDIF.

              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.


        WHEN 'T'. " Time
          IF lv_val_excel IS NOT INITIAL.
            TRY.
                DATA(lv_time) = CONV t( lv_val_excel ).
                DATA(lv_dummy_date) = CONV d( '19700101' ).
                CONVERT DATE lv_dummy_date TIME lv_time INTO TIME STAMP DATA(lv_timestamp_t) TIME ZONE 'UTC'.
              CATCH cx_sy_conversion_error.
                lv_valid = abap_false.
            ENDTRY.
          ENDIF.

*        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
*          TRY.
*              DATA(lv_num) = lv_val_excel.
*            CATCH cx_sy_conversion_no_number.
*              lv_valid = abap_false.
*          ENDTRY.
        WHEN 'I' OR 'P' OR 'F' OR 'INT1' OR 'INT2' OR 'INT4' OR 'DEC' OR 'CURR' OR 'QUAN'.
          TRY.
              lv_val_excel = lv_val_excel + 0.
            CATCH cx_sy_conversion_no_number cx_sy_conversion_error.
              lv_valid = abap_false.
          ENDTRY.
*        WHEN 'N'. " NUMC
        WHEN 'N'. " NUMC
          lv_val_excel = condense( to_upper( lv_val_excel ) ).
          IF lv_val_excel IS NOT INITIAL AND NOT lv_val_excel CO '0123456789'.
            lv_valid = abap_false.
          ENDIF.

        WHEN OTHERS.
          lv_valid = abap_true.
      ENDCASE.

      " Nếu dữ liệu không hợp lệ theo kiểu DDIC → đánh dấu lỗi
      IF lv_valid = abap_false.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag>).
        IF <lv_err_flag> IS ASSIGNED.
          <lv_err_flag> = 'X'.
        ENDIF.
        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_msg>).
        IF <lv_err_msg> IS ASSIGNED.
          CONCATENATE 'Sai định dạng dữ liệu tại cột' lv_real_field 'giá trị:' lv_val_excel INTO <lv_err_msg> SEPARATED BY space.
        ENDIF.
        CONTINUE.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [3] Kiểm tra giá trị hợp lệ theo DOMAIN (nếu có)
      "-----------------------------------------------------------
      IF ls_ddic-domname IS NOT INITIAL.
        DATA(lt_dom_values) = VALUE dd07v_tab( ).
        CALL FUNCTION 'DD_DOMVALUES_GET'
          EXPORTING
            domname        = ls_ddic-domname
            text           = 'X'
          TABLES
            dd07v_tab      = lt_dom_values
          EXCEPTIONS
            wrong_textflag = 1
            OTHERS         = 2.

        IF sy-subrc = 0 AND lt_dom_values IS NOT INITIAL.
          DATA(lv_value_found) = abap_false.
          LOOP AT lt_dom_values INTO DATA(ls_dom).
            IF to_upper( ls_dom-domvalue_l ) = to_upper( lv_val_excel ).
              lv_value_found = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_value_found = abap_false.
            ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag2>).
            IF <lv_err_flag2> IS ASSIGNED.
              <lv_err_flag2> = 'X'.
            ENDIF.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      "-----------------------------------------------------------
      " 🔹 [4] Gán giá trị vào field nếu hợp lệ
      "-----------------------------------------------------------
      TRY.
          <val> = lv_val_excel.
        CATCH cx_sy_conversion_error.
          ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag3>).
          IF <lv_err_flag3> IS ASSIGNED.
            <lv_err_flag3> = 'X'.
          ENDIF.
          CONTINUE.
      ENDTRY.
    ENDIF.
  ENDLOOP.

  "-----------------------------------------------------------
  " 🔹 [5] Kiểm tra trùng khóa chính trong Excel
  "-----------------------------------------------------------
  DATA(lt_keys) = VALUE string_table( ).
  LOOP AT lt_ddic_fields INTO DATA(ls_keyfld) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_keyfld-fieldname TO lt_keys.
  ENDLOOP.

  IF lt_keys IS NOT INITIAL.
    DATA(lt_seen_keys) = VALUE string_table( ).
    DATA(lv_key_string) = VALUE string( ).

    LOOP AT <lt_data> ASSIGNING <ls_data>.
      CLEAR lv_key_string.
      LOOP AT lt_keys INTO DATA(lv_keyfld).
        ASSIGN COMPONENT lv_keyfld OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_keyval>).
        IF <lv_keyval> IS ASSIGNED.
          lv_key_string = lv_key_string && to_upper( condense( <lv_keyval> ) ) && '|'.
        ENDIF.
      ENDLOOP.

      IF lv_key_string IS INITIAL.
        CONTINUE.
      ENDIF.

      READ TABLE lt_seen_keys WITH KEY table_line = lv_key_string TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        ASSIGN COMPONENT 'IS_DUPLICATE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_dupflag>).
        IF <lv_dupflag> IS ASSIGNED.
          <lv_dupflag> = 'X'.
        ENDIF.
        CONTINUE.
      ELSE.
        APPEND lv_key_string TO lt_seen_keys.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "-----------------------------------------------------------
  " 🔹 [7] Kiểm tra các trường bắt buộc (Key fields)
  "-----------------------------------------------------------
  DATA: lt_errors   TYPE STANDARD TABLE OF char255,
        lv_err_text TYPE char255.
  DATA(lt_required_fields) = VALUE string_table( ).

  LOOP AT lt_ddic_fields INTO DATA(ls_req) WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_req-fieldname TO lt_required_fields.
  ENDLOOP.

  IF lt_required_fields IS NOT INITIAL.
    LOOP AT <lt_data> ASSIGNING <ls_data>.
      DATA(lv_missing_fields) = VALUE string( ).
      LOOP AT lt_required_fields INTO DATA(lv_req_field).
        ASSIGN COMPONENT lv_req_field OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_req_val>).
        IF <lv_req_val> IS ASSIGNED AND <lv_req_val> IS INITIAL.
          lv_missing_fields = lv_missing_fields && lv_req_field && ', '.
        ENDIF.
      ENDLOOP.

      IF lv_missing_fields IS NOT INITIAL.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_err_flag_req>).
        IF <lv_err_flag_req> IS ASSIGNED.
          <lv_err_flag_req> = 'X'.
        ENDIF.

        ASSIGN COMPONENT 'IS_MESSAGE' OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_msg_flag>).
        IF <lv_msg_flag> IS ASSIGNED.
          CONCATENATE 'Thiếu dữ liệu bắt buộc: ' lv_missing_fields INTO <lv_msg_flag>.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  "-----------------------------------------------------------
  " 🔹 [8] Hiển thị tất cả lỗi trong popup (nếu có)
  "-----------------------------------------------------------
  IF lt_errors IS NOT INITIAL.
    DATA(lv_err_count) = lines( lt_errors ).
    MESSAGE |Phát hiện { lv_err_count } lỗi trong dữ liệu upload.| TYPE 'I'.
    CALL FUNCTION 'POPUP_WITH_TABLE_DISPLAY_T'
      EXPORTING
        endpos_col   = 120
        endpos_row   = 25
        startpos_col = 5
        startpos_row = 2
        titletext    = |Danh sách lỗi dữ liệu (Tổng: { lv_err_count })|
      TABLES
        valuetab     = lt_errors
      EXCEPTIONS
        break_off    = 1
        OTHERS       = 2.
    IF sy-subrc = 1.
      MESSAGE 'Người dùng đã đóng popup lỗi' TYPE 'S'.
    ELSEIF sy-subrc = 2.
      MESSAGE 'Lỗi khi hiển thị popup lỗi' TYPE 'E'.
    ENDIF.
  ENDIF.

  "=== 7) Set flag NEWREC nếu có ===
  LOOP AT <lt_data> ASSIGNING <ls_data>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0.
      <newrec> = 'X'.
    ENDIF.
  ENDLOOP.

  DESCRIBE TABLE <lt_data> LINES DATA(lv_count).
  IF lv_count = 0.
    MESSAGE 'Không có dữ liệu hợp lệ sau upload!' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  DATA(lv_err) = VALUE string( ).
  PERFORM upload_save_data USING p_tab CHANGING <lt_data> lv_err lv_msg.

  IF lv_err IS NOT INITIAL.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
  ELSE.
    MESSAGE lv_msg TYPE 'S'.
  ENDIF.
  PERFORM set_color.

  "-----------------------------------------------------------
  " 🔹 [11] Refresh lại ALV sau upload
  "-----------------------------------------------------------
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        g_alv_grid->set_toolbar_interactive( ).
      CATCH cx_root INTO DATA(lx_err).
        MESSAGE lx_err->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDIF.

ENDFORM.


FORM download_template_xlsx.

  FIELD-SYMBOLS: <lt_template> TYPE STANDARD TABLE.

  "=== 1) Gọi hộp thoại để người dùng chọn đường dẫn ===
  DATA: lv_filename TYPE string,
        lv_path     TYPE string,
        lv_fullpath TYPE string,
        lv_action   TYPE i.

  cl_gui_frontend_services=>file_save_dialog(
  EXPORTING
  default_extension = 'xlsx'
  default_file_name = |TEMPLATE_{ p_tab }.xlsx|
  file_filter = 'Excel Files (*.xlsx) | *.xlsx'
  CHANGING
  filename = lv_filename
  path = lv_path
  fullpath = lv_fullpath
  user_action = lv_action
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Download template bị hủy' TYPE 'I'.
    RETURN.
  ENDIF.

  "=== 2) Tạo dòng mẫu dựa trên fieldcatalog (header thôi) ===
  DATA: lr_template TYPE REF TO data,
        lv_xstring  TYPE xstring,
        lt_cols     TYPE if_fdt_doc_spreadsheet=>t_column.

  PERFORM create_dynamic_itab USING p_tab
  CHANGING lr_template.

  ASSIGN lr_template->* TO <lt_template>.
  IF <lt_template> IS ASSIGNED.
    CLEAR <lt_template>.
    APPEND INITIAL LINE TO <lt_template>. "chỉ tạo 1 dòng trống
  ELSE.
    MESSAGE 'Không tạo được template từ bảng dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  "=== 3) Export nội dung ra file Excel ===
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols
      itab = lr_template
      iv_call_type = 2
      iv_sheet_name = 'TEMPLATE'
      RECEIVING
      xdocument = lv_xstring ).
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "=== 4) Ghi file ra frontend ===
  DATA lt_bin TYPE solix_tab.
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring ).

  cl_gui_frontend_services=>gui_download(
  EXPORTING
  filename = lv_fullpath
  filetype = 'BIN'
  bin_filesize = xstrlen( lv_xstring )
  CHANGING
  data_tab = lt_bin
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Tải template thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file template' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.

*FORM upload_save_data USING p_tab TYPE tabname
*CHANGING pt_data TYPE STANDARD TABLE
*                  pv_err TYPE string
*                  pv_msg TYPE string.
*
*  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
*                 <ls_row>  TYPE any,
*                 <ls_wa>   TYPE any.
*
*  DATA: lv_tabname TYPE tabname,
*        lv_count   TYPE i,
*        lr_wa      TYPE REF TO data.
*
*  lv_tabname = p_tab.
*
*  ASSIGN pt_data TO <lt_data>.
*  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
*    pv_err = 'Không có dữ liệu hợp lệ để ghi vào DB.'.
*    RETURN.
*  ENDIF.
*
*  "--- tạo work area có kiểu tĩnh tương ứng
*  DATA lo_descr TYPE REF TO cl_abap_typedescr.
*  DATA lo_struct TYPE REF TO cl_abap_structdescr.
*
*  lo_descr = cl_abap_typedescr=>describe_by_name( lv_tabname ).
*  lo_struct ?= lo_descr.
*
*  CREATE DATA lr_wa TYPE HANDLE lo_struct.
*  ASSIGN lr_wa->* TO <ls_wa>.
*
*  TRY.
*      LOOP AT <lt_data> ASSIGNING <ls_row>.
*        MOVE-CORRESPONDING <ls_row> TO <ls_wa>.
*        INSERT (lv_tabname) FROM <ls_wa>.
*        COMMIT WORK AND WAIT.
*      ENDLOOP.
*
*      IF sy-subrc = 0.
*        COMMIT WORK AND WAIT.
*        DESCRIBE TABLE <lt_data> LINES lv_count.
*        pv_msg = |Đã lưu thành công { lv_count } dòng dữ liệu vào { lv_tabname }.|.
*
*        "=== Reload lại dữ liệu từ DB ===
*        FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
*        ASSIGN gr_data->* TO <lt_alv>.
*
*        IF <lt_alv> IS ASSIGNED.
*          DATA lr_temp TYPE REF TO data.
*          FIELD-SYMBOLS: <lt_temp> TYPE STANDARD TABLE,
*                         <ls_temp> TYPE any,
*                         <ls_alv>  TYPE any.
*
*          "Tạo table tạm có cùng cấu trúc DB
*          CREATE DATA lr_temp TYPE TABLE OF (lv_tabname).
*          ASSIGN lr_temp->* TO <lt_temp>.
*
*          "Đọc lại toàn bộ dữ liệu từ DB
*          SELECT * FROM (lv_tabname) INTO TABLE <lt_temp>.
*
*          "Xóa dữ liệu ALV cũ
*          REFRESH <lt_alv>.
*
*          "Chép dữ liệu DB vào ALV (dùng MOVE-CORRESPONDING để tránh dump)
*          LOOP AT <lt_temp> ASSIGNING <ls_temp>.
*            APPEND INITIAL LINE TO <lt_alv> ASSIGNING <ls_alv>.
*            MOVE-CORRESPONDING <ls_temp> TO <ls_alv>.
*          ENDLOOP.
*        ENDIF.
*
*        "=== Refresh lại ALV grid để hiển thị ngay dữ liệu ===
*        IF g_alv_grid IS BOUND.
*          g_alv_grid->refresh_table_display(
*            EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' )
*          ).
*        ENDIF.
*
*      ELSE.
*        pv_err = |Không thể ghi dữ liệu vào bảng { lv_tabname }.|.
*      ENDIF.
*
*    CATCH cx_sy_dynamic_osql_error INTO DATA(lx_sql).
*      pv_err = lx_sql->get_text( ).
*  ENDTRY.
*
*ENDFORM.
*---------------------------------------------------------------------*
*  FORM upload_save_data - Save dữ liệu upload + ghi log audit
*---------------------------------------------------------------------*
*FORM upload_save_data USING p_tab TYPE tabname
*CHANGING pt_data TYPE STANDARD TABLE
*                  pv_err TYPE string
*                  pv_msg TYPE string.
*
*  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
*                 <ls_row>  TYPE any,
*                 <ls_db>   TYPE any,
*                 <ls_wa>   TYPE any,
*                 <val_new> TYPE any,
*                 <val_old> TYPE any.
*
*  DATA: lv_tabname TYPE tabname,
*        lv_count   TYPE i,
*        lr_wa      TYPE REF TO data,
*        lr_db      TYPE REF TO data,
*        lr_temp    TYPE REF TO data,
*        lv_where   TYPE string.
*  lv_tabname = p_tab.
*  ASSIGN pt_data TO <lt_data>.
*  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
*    pv_err = 'Không có dữ liệu hợp lệ để ghi vào DB.'.
*    RETURN.
*  ENDIF.
*
*  "--- Mô tả kiểu cấu trúc bảng đích
*  DATA(lo_struct) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_name( lv_tabname ) ).
*  CREATE DATA lr_wa TYPE HANDLE lo_struct.
*  ASSIGN lr_wa->* TO <ls_wa>.
*
*  "--- Lấy metadata để biết key fields
*  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
*        lt_key_fields  TYPE STANDARD TABLE OF string,
*        ls_ddic_field  TYPE dfies.
*
*  CALL FUNCTION 'DDIF_FIELDINFO_GET'
*    EXPORTING
*      tabname   = lv_tabname
*    TABLES
*      dfies_tab = lt_ddic_fields
*    EXCEPTIONS
*      OTHERS    = 1.
*
*  LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
*    APPEND ls_ddic_field-fieldname TO lt_key_fields.
*  ENDLOOP.
*
*  "--- Lấy timestamp hiện tại (UTC -> VN)
*  DATA: lv_user  TYPE sy-uname,
*        lv_tzone TYPE tznzone VALUE 'UTC+7',
*        lv_ts    TYPE timestamp,
*        lv_date  TYPE d,
*        lv_time  TYPE t.
*  lv_user = sy-uname.
*  GET TIME STAMP FIELD lv_ts.
*  CONVERT TIME STAMP lv_ts TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.
*
*  TRY.
*
*      LOOP AT <lt_data> ASSIGNING <ls_row>.
*        " Bỏ qua dòng lỗi
*        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_err_flag>).
*        IF <lv_err_flag> IS ASSIGNED AND <lv_err_flag> = 'X'.
*          CONTINUE.
*        ENDIF.
*
*        "--- Xây điều kiện WHERE từ key fields
*        CLEAR lv_where.
*        LOOP AT lt_key_fields INTO DATA(lv_key).
*          ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_kval>).
*          IF <lv_kval> IS ASSIGNED.
*            IF lv_where IS INITIAL.
*              lv_where = |{ lv_key } = '{ <lv_kval> }'|.
*            ELSE.
*              lv_where = |{ lv_where } AND { lv_key } = '{ <lv_kval> }'|.
*            ENDIF.
*          ENDIF.
*        ENDLOOP.
*
*        "--- Lấy bản ghi DB hiện có
*        CREATE DATA lr_db TYPE HANDLE lo_struct.
*        ASSIGN lr_db->* TO <ls_db>.
*        SELECT SINGLE * FROM (lv_tabname) INTO @<ls_db> WHERE (lv_where).
*
*        IF sy-subrc = 0.
*          "=== ĐÃ CÓ → UPDATE
*          LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE fieldname <> 'MANDT'.
*            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_row> TO <val_new>.
*            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_db>  TO <val_old>.
*            IF <val_new> IS ASSIGNED AND <val_new> IS NOT INITIAL.
*              <val_old> = <val_new>.
*            ENDIF.
*          ENDLOOP.
*
*        MOVE-CORRESPONDING <ls_db> TO <ls_wa>.
*        MODIFY (lv_tabname) FROM <ls_wa>.
*
*        "--- Ghi audit log (UPDATE)
*        PERFORM log_audit_action USING lv_tabname 'U' <ls_wa>.
*
*      ELSE.
*        "=== CHƯA CÓ → INSERT
*        MOVE-CORRESPONDING <ls_row> TO <ls_wa>.
*        INSERT (lv_tabname) FROM <ls_wa>.
*
*        "--- Ghi audit log (CREATE)
*        PERFORM log_audit_action USING lv_tabname 'C' <ls_wa>.
*      ENDIF.
*
*    ENDLOOP.
*
*    COMMIT WORK AND WAIT.
*
*    "--- Reload lại dữ liệu DB và merge audit
*    DESCRIBE TABLE <lt_data> LINES lv_count.
*    pv_msg = |Đã lưu thành công { lv_count } dòng dữ liệu vào { lv_tabname }.|.
*
*    FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
*    ASSIGN gr_data->* TO <lt_alv>.
*    IF <lt_alv> IS ASSIGNED.
*      CREATE DATA lr_temp TYPE TABLE OF (lv_tabname).
*      ASSIGN lr_temp->* TO FIELD-SYMBOL(<lt_temp>).
*
*      SELECT * FROM (lv_tabname) INTO TABLE @<lt_temp>.
*
*        REFRESH <lt_alv>.
*        LOOP AT <lt_temp> ASSIGNING FIELD-SYMBOL(<ls_temp>).
*          APPEND INITIAL LINE TO <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv>).
*          MOVE-CORRESPONDING <ls_temp> TO <ls_alv>.
*        ENDLOOP.
*
*        "=== Merge audit log vào ALV
*        PERFORM merge_audit_log USING lv_tabname CHANGING <lt_alv>.
*
*      ENDIF.
*
*      "--- Refresh ALV grid
*      IF g_alv_grid IS BOUND.
*        g_alv_grid->refresh_table_display(
*          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
*      ENDIF.
*
*    CATCH cx_sy_dynamic_osql_error INTO DATA(lx_sql).
*      pv_err = lx_sql->get_text( ).
*  ENDTRY.
*
*ENDFORM.

FORM upload_save_data USING p_tab TYPE tabname
CHANGING pt_data TYPE STANDARD TABLE
                  pv_err TYPE string
                  pv_msg TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any,
                 <ls_db>   TYPE any,
                 <ls_wa>   TYPE any,
                 <val_new> TYPE any,
                 <val_old> TYPE any.

  DATA: lv_tabname TYPE tabname,
        lv_count   TYPE i,
        lr_wa      TYPE REF TO data,
        lr_db      TYPE REF TO data,
        lr_temp    TYPE REF TO data,
        lv_where   TYPE string.
lv_tabname = p_tab.
  ASSIGN pt_data TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    pv_err = 'Không có dữ liệu hợp lệ để ghi vào DB.'.
    RETURN.
  ENDIF.

  "--- Lấy mô tả cấu trúc của bảng đích
  DATA(lo_struct) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_name( lv_tabname ) ).
  CREATE DATA lr_wa TYPE HANDLE lo_struct.
  ASSIGN lr_wa->* TO <ls_wa>.

  "--- Lấy key fields
  DATA: lt_ddic_fields TYPE STANDARD TABLE OF dfies,
        lt_key_fields  TYPE STANDARD TABLE OF string,
        ls_ddic_field  TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING tabname = lv_tabname
    TABLES dfies_tab = lt_ddic_fields
    EXCEPTIONS OTHERS = 1.

  LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE keyflag = 'X' AND fieldname <> 'MANDT'.
    APPEND ls_ddic_field-fieldname TO lt_key_fields.
  ENDLOOP.

  "--- Chuẩn bị thời gian & user (timezone VN)
  DATA: lv_user  TYPE sy-uname,
        lv_tzone TYPE tznzone VALUE 'UTC+7',
        lv_ts    TYPE timestamp,
        lv_date  TYPE d,
        lv_time  TYPE t.
lv_user = sy-uname.
  GET TIME STAMP FIELD lv_ts.
  CONVERT TIME STAMP lv_ts TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.

  TRY.
      LOOP AT <lt_data> ASSIGNING <ls_row>.
        ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_err_flag>).
        IF <lv_err_flag> IS ASSIGNED AND <lv_err_flag> = 'X'.
          CONTINUE.
        ENDIF.

        "--- Xây WHERE từ key
        CLEAR lv_where.
        LOOP AT lt_key_fields INTO DATA(lv_key).
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO FIELD-SYMBOL(<lv_kval>).
          IF <lv_kval> IS ASSIGNED.
            IF lv_where IS INITIAL.
              lv_where = |{ lv_key } = '{ <lv_kval> }'|.
            ELSE.
              lv_where = |{ lv_where } AND { lv_key } = '{ <lv_kval> }'|.
            ENDIF.
          ENDIF.
        ENDLOOP.

        "--- Lấy bản ghi DB (nếu có)
        CREATE DATA lr_db TYPE HANDLE lo_struct.
        ASSIGN lr_db->* TO <ls_db>.
        SELECT SINGLE * FROM (lv_tabname) INTO @<ls_db> WHERE (lv_where).

        IF sy-subrc = 0.
          "=== Record có sẵn → kiểm tra thay đổi
          DATA(lv_changed) = abap_false.

          LOOP AT lt_ddic_fields INTO ls_ddic_field WHERE fieldname <> 'MANDT'.
            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_row> TO <val_new>.
            ASSIGN COMPONENT ls_ddic_field-fieldname OF STRUCTURE <ls_db>  TO <val_old>.

            IF <val_new> IS ASSIGNED AND <val_old> IS ASSIGNED.
              IF <val_new> <> <val_old>.
                <val_old> = <val_new>.
                lv_changed = abap_true.
              ENDIF.
            ENDIF.
          ENDLOOP.

          IF lv_changed = abap_true.
            "--- Ghi 3 cột Changed*
            ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_db> TO FIELD-SYMBOL(<lv_aedat>).
            IF <lv_aedat> IS ASSIGNED. <lv_aedat> = lv_date. ENDIF.

            ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_db> TO FIELD-SYMBOL(<lv_aetim>).
            IF <lv_aetim> IS ASSIGNED. <lv_aetim> = lv_time. ENDIF.

            ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_db> TO FIELD-SYMBOL(<lv_aenam>).
            IF <lv_aenam> IS ASSIGNED. <lv_aenam> = lv_user. ENDIF.

            MOVE-CORRESPONDING <ls_db> TO <ls_wa>.
            MODIFY (lv_tabname) FROM <ls_wa>.

            "--- Audit log UPDATE
            PERFORM log_audit_action USING lv_tabname 'U' <ls_wa>.
          ENDIF.

        ELSE.
          "=== Record mới → INSERT
          MOVE-CORRESPONDING <ls_row> TO <ls_wa>.

          ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_wa> TO FIELD-SYMBOL(<lv_erdat>).
          IF <lv_erdat> IS ASSIGNED. <lv_erdat> = lv_date. ENDIF.

          ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_wa> TO FIELD-SYMBOL(<lv_ertim>).
          IF <lv_ertim> IS ASSIGNED. <lv_ertim> = lv_time. ENDIF.

          ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_wa> TO FIELD-SYMBOL(<lv_ernam>).
          IF <lv_ernam> IS ASSIGNED. <lv_ernam> = lv_user. ENDIF.

          INSERT (lv_tabname) FROM <ls_wa>.

          "--- Audit log CREATE
          PERFORM log_audit_action USING lv_tabname 'C' <ls_wa>.
        ENDIF.

      ENDLOOP.

      COMMIT WORK AND WAIT.

      "--- Reload dữ liệu và merge audit
      DESCRIBE TABLE <lt_data> LINES lv_count.
      pv_msg = |Đã lưu thành công { lv_count } dòng dữ liệu vào { lv_tabname }.|.

      FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
      ASSIGN gr_data->* TO <lt_alv>.

      IF <lt_alv> IS ASSIGNED.
        CREATE DATA lr_temp TYPE TABLE OF (lv_tabname).
        ASSIGN lr_temp->* TO FIELD-SYMBOL(<lt_temp>).

        SELECT * FROM (lv_tabname) INTO TABLE @<lt_temp>.

        REFRESH <lt_alv>.
        LOOP AT <lt_temp> ASSIGNING FIELD-SYMBOL(<ls_temp>).
          APPEND INITIAL LINE TO <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv>).
          MOVE-CORRESPONDING <ls_temp> TO <ls_alv>.
        ENDLOOP.

        "--- Gộp lại audit log vào ALV hiển thị
        PERFORM merge_audit_log USING lv_tabname CHANGING <lt_alv>.
      ENDIF.

      IF g_alv_grid IS BOUND.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      ENDIF.

    CATCH cx_sy_dynamic_osql_error INTO DATA(lx_sql).
      pv_err = lx_sql->get_text( ).
  ENDTRY.

ENDFORM.








*=====================================================================*
* FORM download_excel_xlsx – Export dữ liệu ra Excel gồm 2 sheet *
*=====================================================================*
FORM download_excel_xlsx USING ir_data TYPE REF TO data.

  TYPES: BEGIN OF ty_field_help,
           fieldname TYPE string,
           heading   TYPE string,
           tooltip   TYPE string,
         END OF ty_field_help.

  FIELD-SYMBOLS: <lt_original> TYPE STANDARD TABLE,
                 <ls_original> TYPE any,
                 <lt_no_style> TYPE STANDARD TABLE,
                 <ls_no_style> TYPE any,
                 <lt_help>     TYPE STANDARD TABLE,
                 <ls_help>     TYPE any.

  DATA: lr_data_no_style TYPE REF TO data,
        lv_filename      TYPE string,
        lv_path          TYPE string,
        lv_fullpath      TYPE string,
        lv_action        TYPE i,
        lv_xstring_data  TYPE xstring,
        lv_xstring_help  TYPE xstring,
        lt_bin           TYPE solix_tab,
        lt_cols_data     TYPE if_fdt_doc_spreadsheet=>t_column,
        lt_cols_help     TYPE if_fdt_doc_spreadsheet=>t_column,
        lt_help_raw      TYPE STANDARD TABLE OF ty_field_help,
        lr_help_raw      TYPE REF TO data,
        lt_meta          TYPE ddfields.

  "== 1) Gọi hộp thoại chọn nơi lưu file ==
  cl_gui_frontend_services=>file_save_dialog(
  EXPORTING
  default_extension = 'xlsx'
  default_file_name = |DATA_{ p_tab }_{ sy-datum }_{ sy-uzeit }.xlsx|
  file_filter = 'Excel Files (*.xlsx)|*.xlsx'
  CHANGING
  filename = lv_filename
  path = lv_path
  fullpath = lv_fullpath
  user_action = lv_action
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc <> 0 OR lv_action <> cl_gui_frontend_services=>action_ok.
    MESSAGE 'Export bị hủy' TYPE 'S'.
    RETURN.
  ENDIF.

  "== 2) Chuẩn bị dữ liệu gốc (DATA sheet) ==
  ASSIGN ir_data->* TO <lt_original>.
  IF <lt_original> IS NOT ASSIGNED.
    MESSAGE 'Dữ liệu không hợp lệ' TYPE 'S'.
    RETURN.
  ENDIF.

  PERFORM create_dynamic_itab_no_style USING p_tab CHANGING lr_data_no_style.
  ASSIGN lr_data_no_style->* TO <lt_no_style>.

  LOOP AT <lt_original> ASSIGNING <ls_original>.
    APPEND INITIAL LINE TO <lt_no_style> ASSIGNING <ls_no_style>.
    MOVE-CORRESPONDING <ls_original> TO <ls_no_style>.
  ENDLOOP.

  "== 3) Lấy metadata từ DDIC để tạo sheet mô tả ==
  PERFORM get_metadata USING p_tab CHANGING lt_meta.

  LOOP AT lt_meta INTO DATA(ls_ddic).
    APPEND VALUE ty_field_help(
    fieldname = ls_ddic-fieldname
    heading = ls_ddic-scrtext_l
    tooltip = ls_ddic-scrtext_m ) TO lt_help_raw.
  ENDLOOP.

  CREATE DATA lr_help_raw LIKE lt_help_raw.
  ASSIGN lr_help_raw->* TO <lt_help>.
  <lt_help> = lt_help_raw.

  "== 4) Tạo sheet DATA ==
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols_data
      itab = lr_data_no_style
      iv_call_type = 2
      iv_sheet_name = 'DATA'
      RECEIVING
      xdocument = lv_xstring_data ).
    CATCH cx_root INTO DATA(lx_data).
      MESSAGE lx_data->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "== 5) Tạo sheet Input help ==
  TRY.
      cl_fdt_xl_spreadsheet=>if_fdt_doc_spreadsheet~create_document(
      EXPORTING
      columns = lt_cols_help
      itab = lr_help_raw
      iv_call_type = 2
      iv_sheet_name = 'Input help'
      RECEIVING
      xdocument = lv_xstring_help ).
    CATCH cx_root INTO DATA(lx_help).
      MESSAGE lx_help->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
  ENDTRY.

  "== 6) Gộp tạm 2 xstring (không chuẩn multi-sheet nhưng chấp nhận được)==
  CONCATENATE lv_xstring_data lv_xstring_help INTO lv_xstring_data IN BYTE MODE.

  "== 7) Ghi file ra frontend ==
  lt_bin = cl_bcs_convert=>xstring_to_solix( iv_xstring = lv_xstring_data ).

  cl_gui_frontend_services=>gui_download(
  EXPORTING
  filename = lv_fullpath
  filetype = 'BIN'
  bin_filesize = xstrlen( lv_xstring_data )
  CHANGING
  data_tab = lt_bin
  EXCEPTIONS
  OTHERS = 1 ).

  IF sy-subrc = 0.
    MESSAGE |Xuất dữ liệu thành công: { lv_filename }| TYPE 'S'.
  ELSE.
    MESSAGE 'Lỗi khi ghi file dữ liệu' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM set_color – Tô màu dòng trong ALV sau khi upload
*---------------------------------------------------------------------*
FORM set_color.

  FIELD-SYMBOLS: <lt_data>   TYPE STANDARD TABLE,
                 <ls_data>   TYPE any,
                 <celltab>   TYPE lvc_t_styl,
                 <row_color> TYPE lvc_t_scol,
                 <color>     TYPE lvc_s_scol,
                 <is_error>  TYPE any.

  " Gán tới dữ liệu hiện tại của ALV
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    RETURN.
  ENDIF.

  " Lặp qua từng dòng dữ liệu
  LOOP AT <lt_data> ASSIGNING <ls_data>.

    " Nếu ALV có field màu (CELLTAB) hoặc COLOR, ta đảm bảo nó tồn tại
    ASSIGN COMPONENT 'ROW_COLOR' OF STRUCTURE <ls_data> TO <row_color>.
    IF sy-subrc <> 0.
      ASSIGN COMPONENT 'COLOR' OF STRUCTURE <ls_data> TO <row_color>.
    ENDIF.

    " Nếu không có, bỏ qua
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    CLEAR <row_color>.

    " Kiểm tra cờ lỗi IS_ERROR
    ASSIGN COMPONENT 'IS_ERROR' OF STRUCTURE <ls_data> TO <is_error>.
    IF sy-subrc = 0 AND <is_error> = 'X'.
      " 🔴 Dòng lỗi → tô đỏ (C600)
      CLEAR <color>.
      <color>-fname = ''.
      <color>-color-col = 6. " Red
      <color>-color-int = 0.
      <color>-color-inv = 0.
      APPEND <color> TO <row_color>.
    ELSE.
      " 🟢 Dòng hợp lệ → tô xanh lá (C500)
      CLEAR <color>.
      <color>-fname = ''.
      <color>-color-col = 5. " Green
      <color>-color-int = 0.
      <color>-color-inv = 0.
      APPEND <color> TO <row_color>.
    ENDIF.

  ENDLOOP.

  " Refresh ALV để hiển thị màu ngay
  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->refresh_table_display(
        EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

ENDFORM.


*&---------------------------------------------------------------------*
*& Include ZFA25SAP23_AUDIT (classic-syntax, no templates/inline)
*&---------------------------------------------------------------------*

* Cache key fields for current table
FORM ensure_keys USING iv_tab TYPE tabname.
  DATA lv_tab TYPE tabname.
  IF gv_keys_tabname <> iv_tab.
    CLEAR gt_key_fields.
    gv_keys_tabname = iv_tab.
  ENDIF.

  " Upper-case để khớp DDIC
  lv_tab = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  IF gt_key_fields IS INITIAL.
    SELECT fieldname
      FROM dd03l
      INTO TABLE @gt_key_fields
      WHERE tabname  = @lv_tab
        AND as4local = 'A'
        AND keyflag  = 'X'
        AND fieldname <> 'MANDT'.
  ENDIF.

  " Fallback từ fieldcatalog nếu DD03L không trả về
  IF gt_key_fields IS INITIAL AND gt_fieldcat IS NOT INITIAL.
    FIELD-SYMBOLS <fc> TYPE lvc_s_fcat.
    LOOP AT gt_fieldcat ASSIGNING <fc>.
      IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
        CONTINUE.
      ENDIF.
      IF <fc>-key = 'X' AND to_upper( <fc>-fieldname ) <> 'MANDT'.
        APPEND <fc>-fieldname TO gt_key_fields.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM ensure_celltab_component CHANGING cr_tab TYPE REF TO data.
  TYPE-POOLS abap.

  DATA: lo_tab      TYPE REF TO cl_abap_tabledescr,
        lo_line     TYPE REF TO cl_abap_structdescr,
        lt_comp     TYPE abap_component_tab,
        ls_comp     TYPE abap_componentdescr,
        lv_has_cell TYPE abap_bool,
        lv_has_new  TYPE abap_bool,
        lo_cell_any TYPE REF TO cl_abap_typedescr,
        lo_cell_dat TYPE REF TO cl_abap_datadescr,
        lo_bool_dat TYPE REF TO cl_abap_datadescr,
        lo_newline  TYPE REF TO cl_abap_structdescr,
        lo_newtab   TYPE REF TO cl_abap_tabledescr,
        lr_new      TYPE REF TO data,
        lr_row      TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).




  CLEAR: lv_has_cell, lv_has_new.
  LOOP AT lt_comp INTO ls_comp.
    IF ls_comp-name = 'CELLTAB'. lv_has_cell = abap_true. ENDIF.
    IF ls_comp-name = 'NEWREC'.  lv_has_new  = abap_true. ENDIF.
  ENDLOOP.

  IF lv_has_cell = abap_true AND lv_has_new = abap_true.
    RETURN. " đã có đủ hai cột kỹ thuật
  ENDIF.

  " Thêm CELLTAB: LVC_T_STYL
  IF lv_has_cell = abap_false.
    lo_cell_any = cl_abap_typedescr=>describe_by_name( 'LVC_T_STYL' ).
    lo_cell_dat ?= lo_cell_any.
    CLEAR ls_comp.
    ls_comp-name = 'CELLTAB'.
    ls_comp-type = lo_cell_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Thêm NEWREC: C(1)
  IF lv_has_new = abap_false.
    lo_bool_dat = cl_abap_elemdescr=>get_c( 1 ).
    CLEAR ls_comp.
    ls_comp-name = 'NEWREC'.
    ls_comp-type = lo_bool_dat.
    APPEND ls_comp TO lt_comp.
  ENDIF.

  " Tạo lại line type + table type mới
  lo_newline = cl_abap_structdescr=>create( lt_comp ).
  lo_newtab  = cl_abap_tabledescr=>create( lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  IF <lt_old> IS ASSIGNED AND <lt_new> IS ASSIGNED.
    LOOP AT <lt_old> ASSIGNING <ls_old>.
      CREATE DATA lr_row TYPE HANDLE lo_newline.
      ASSIGN lr_row->* TO <ls_new>.
      MOVE-CORRESPONDING <ls_old> TO <ls_new>.
      APPEND <ls_new> TO <lt_new>.
    ENDLOOP.
    cr_tab = lr_new. " ref mới có CELLTAB + NEWREC
  ENDIF.
ENDFORM.

*=== Helper: escape dấu nháy đơn cho literal SQL
FORM _escape_single_quote USING    iv_in  TYPE string
                          CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH ''''''.
ENDFORM.

* Build dynamic WHERE from key fields (type-aware, with escaping)
FORM make_where_from_key USING    is_str  TYPE any
                                  it_keys TYPE STANDARD TABLE
                         CHANGING ev_where TYPE string
                                  ev_err   TYPE string.

  CLEAR: ev_where, ev_err.
  DATA lv_cond TYPE string.
  FIELD-SYMBOLS: <val>   TYPE any, <fname> TYPE dd03l-fieldname.

  DATA all_empty TYPE abap_bool VALUE abap_true.

  LOOP AT it_keys ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE is_str TO <val>.
    IF sy-subrc = 0 AND <val> IS ASSIGNED AND <val> IS NOT INITIAL.
      all_empty = abap_false.

      "  Phải lấy mô tả kiểu *trong từng vòng lặp*
      DATA(lo_td) = cl_abap_typedescr=>describe_by_data_ref( REF #( <val> ) ).
      DATA(lv_tk) = lo_td->type_kind.

      DATA(lv_piece) = ``.
      IF lv_tk = 'I' OR lv_tk = 'P' OR lv_tk = 'F' OR lv_tk = 'N'.
        lv_piece = |{ <fname> } = { <val> }|.
      ELSE.
        DATA(lv_s) = |{ <val> }|.
        PERFORM _escape_single_quote USING lv_s CHANGING lv_s.
        lv_piece = |{ <fname> } = '{ lv_s }'|.
      ENDIF.

      IF lv_cond IS INITIAL.
        lv_cond = lv_piece.
      ELSE.
        lv_cond = |{ lv_cond } AND { lv_piece }|.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF all_empty = abap_true.
    ev_err = 'Tất cả trường khóa đều rỗng.'.
    RETURN.
  ENDIF.

  IF lv_cond IS INITIAL.
    ev_err = 'Không tạo được điều kiện khóa.'.
  ELSE.
    ev_where = lv_cond.
  ENDIF.

ENDFORM.


* Serialize any structure to JSON (fallback XML) into ZDE_JSON_TXT
FORM to_json USING is_any TYPE any
             CHANGING cv_json TYPE zde_json_txt.
  DATA lv_str TYPE string.
  CLEAR lv_str.
  " Đồng bộ pretty_mode-none để khớp json_to_itab
  TRY.
      lv_str = /ui2/cl_json=>serialize(
                 data        = is_any
                 pretty_name = /ui2/cl_json=>pretty_mode-none ).
    CATCH cx_root.
      TRY.
          CALL TRANSFORMATION id
            SOURCE data = is_any
            RESULT XML lv_str.
        CATCH cx_root.
          lv_str = '<<serialize failed>>'.
      ENDTRY.
  ENDTRY.
  cv_json = lv_str.
ENDFORM.

* Check key when adding: key must be filled & not exist in DB
FORM check_key_on_add USING    iv_tab  TYPE tabname
                      CHANGING ev_err  TYPE string.

  DATA: lv_first_key TYPE dd03l-fieldname,
        lv_where     TYPE string,
        lv_msg       TYPE string,
        lv_label     TYPE string,
        lv_count     TYPE i.

  FIELD-SYMBOLS: <lt>    TYPE STANDARD TABLE,
                 <ls>    TYPE any,
                 <comp>  TYPE any,
                 <fname> TYPE dd03l-fieldname.

  CLEAR ev_err.

  " Chỉ kiểm tra khi đang ở chế độ Add
  IF gv_add_mode IS INITIAL.
    RETURN.
  ENDIF.

  " Lấy dòng NEW (giả định dòng cuối)
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS INITIAL.
    ev_err = 'Không có dữ liệu để kiểm tra.'.
    RETURN.
  ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX lines( <lt> ).
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED.
    ev_err = 'Không xác định được dòng mới.'.
    RETURN.
  ENDIF.

  " Lấy key fields
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC.'.
    RETURN.
  ENDIF.

  " ============ 1) Nếu tất cả khóa rỗng ============
  DATA(lv_all_empty) = abap_true.
  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc = 0 AND <comp> IS NOT INITIAL.
      lv_all_empty = abap_false.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_all_empty = abap_true.
    READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
    IF lv_first_key IS INITIAL.
      ev_err = 'Dòng mới đang trống. Vui lòng nhập khóa.'.
    ELSE.
      ev_err = |Dòng mới đang trống. Vui lòng nhập trường khóa đầu tiên: { lv_first_key }|.
    ENDIF.

    " Focus caret vào ô KEY đầu tiên
    TRY.
        DATA: ls_row TYPE lvc_s_row,
              ls_col TYPE lvc_s_col.
        ls_row-index     = lines( <lt> ).
        ls_col-fieldname = COND #( WHEN lv_first_key IS INITIAL
                                   THEN gt_key_fields[ 1 ]
                                   ELSE lv_first_key ).
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = ls_row
                      is_column_id = ls_col ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = ls_row
                      is_col_info = ls_col ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.

    RETURN. " Dừng save
  ENDIF.

  " ============ 2) Kiểm tra từng field khóa ============
  DATA: lt_dfies TYPE STANDARD TABLE OF dfies,
        ls_dfies TYPE dfies.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = iv_tab
      all_types = 'X'
    TABLES
      dfies_tab = lt_dfies
    EXCEPTIONS
      OTHERS    = 1.

  LOOP AT gt_key_fields ASSIGNING <fname>.
    ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
    IF sy-subrc <> 0 OR <comp> IS INITIAL.

      CLEAR lv_label.
      READ TABLE lt_dfies INTO ls_dfies WITH KEY fieldname = <fname>.
      IF sy-subrc = 0.
        lv_label = COND #( WHEN ls_dfies-scrtext_m IS NOT INITIAL THEN ls_dfies-scrtext_m
                           WHEN ls_dfies-scrtext_l IS NOT INITIAL THEN ls_dfies-scrtext_l
                           ELSE ls_dfies-scrtext_s ).
      ENDIF.

      ev_err = COND #( WHEN lv_label IS INITIAL
                       THEN |Trường khóa { <fname> } đang rỗng|
                       ELSE |Trường khóa { <fname> } ({ lv_label }) đang rỗng| ).

      " Focus vào field khóa đang rỗng
      TRY.
          DATA: l_row TYPE lvc_s_row,
                l_col TYPE lvc_s_col.
          l_row-index     = lines( <lt> ).
          l_col-fieldname = <fname>.
          IF g_alv_grid IS BOUND.
            g_alv_grid->set_current_cell_via_id(
              EXPORTING is_row_id    = l_row
                        is_column_id = l_col ).
            g_alv_grid->set_scroll_info_via_id(
              EXPORTING is_row_info = l_row
                        is_col_info = l_col ).
          ENDIF.
        CATCH cx_root.
      ENDTRY.

      RETURN.
    ENDIF.
  ENDLOOP.

  " ============ 3) Kiểm tra trùng khóa trong DB (theo TOÀN BỘ key) ============
  PERFORM make_where_from_key USING <ls> gt_key_fields
                       CHANGING lv_where lv_msg.
  IF lv_where IS INITIAL.
    ev_err = COND #( WHEN lv_msg IS INITIAL THEN 'Không tạo được điều kiện khóa.' ELSE lv_msg ).
    RETURN.
  ENDIF.

  " Đếm số bản ghi khớp toàn bộ composite key
  TRY.
      SELECT COUNT( * ) INTO lv_count
        FROM (iv_tab)
        WHERE (lv_where).
    CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_syn).
      ev_err = |Lỗi cú pháp WHERE "{ lv_where }": { lx_syn->get_text( ) }|.
      RETURN.
  ENDTRY.

  IF lv_count > 0.
    ev_err = |Khóa đã tồn tại trong { iv_tab }. Vui lòng nhập khóa khác.|.

    " Focus vào trường khóa đầu tiên
    TRY.
        DATA: l_row2 TYPE lvc_s_row,
              l_col2 TYPE lvc_s_col.
        l_row2-index = lines( <lt> ).
        READ TABLE gt_key_fields INDEX 1 INTO lv_first_key.
        IF lv_first_key IS INITIAL.
          lv_first_key = gt_key_fields[ 1 ].
        ENDIF.
        l_col2-fieldname = lv_first_key.
        IF g_alv_grid IS BOUND.
          g_alv_grid->set_current_cell_via_id(
            EXPORTING is_row_id    = l_row2
                      is_column_id = l_col2 ).
          g_alv_grid->set_scroll_info_via_id(
            EXPORTING is_row_info = l_row2
                      is_col_info = l_col2 ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.

    RETURN.
  ENDIF.

ENDFORM.


FORM on_save.
  DATA: lv_mod     TYPE i,
        lv_err     TYPE string,
        lv_ck      TYPE string,
        lv_msg     TYPE c LENGTH 200.

  DATA: lr_to_save   TYPE REF TO data,
        lo_line      TYPE REF TO cl_abap_structdescr,
        lo_tab       TYPE REF TO cl_abap_tabledescr.

  FIELD-SYMBOLS: <lt_to_save> TYPE STANDARD TABLE,
                 <ls_to_save> TYPE any.

  FIELD-SYMBOLS: <lt_data>    TYPE STANDARD TABLE,
                 <ls_data>    TYPE any,
                 <newrec>     TYPE any.

  DATA: lv_where        TYPE string,
        lv_we           TYPE string,
        lv_is_new       TYPE abap_bool.

  DATA: lr_db_struct TYPE REF TO cl_abap_structdescr,
        lr_now_db    TYPE REF TO data,
        lr_old_db    TYPE REF TO data.

  FIELD-SYMBOLS: <ls_db_now> TYPE any,
                 <ls_db_old> TYPE any,
                 <fs_mandt>  TYPE any.

  DATA: lr_old TYPE REF TO data.
  FIELD-SYMBOLS: <ls_old> TYPE any.

  DATA: lxsql TYPE REF TO cx_sy_dynamic_osql_syntax.

  DATA: ls_stbl TYPE lvc_s_stbl.
  CLEAR ls_stbl. ls_stbl-row = 'X'. ls_stbl-col = 'X'.

  " 1) Kiểm tra khóa khi thêm dòng (hiển thị rõ field lỗi)
  CLEAR lv_ck.
  PERFORM check_key_on_add USING p_tab CHANGING lv_ck.
  IF lv_ck IS NOT INITIAL.
    MESSAGE lv_ck TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 2) Build audit và chuẩn bị danh sách lưu
  REFRESH gt_audit.
  ASSIGN gr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    MESSAGE 'Không có dữ liệu để lưu.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING p_tab.
  IF gt_key_fields IS INITIAL.
    MESSAGE 'Bảng không có khóa trong DDIC.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( p_tab ).
  CREATE DATA lr_now_db TYPE HANDLE lr_db_struct.
  CREATE DATA lr_old_db TYPE HANDLE lr_db_struct.
  ASSIGN lr_now_db->* TO <ls_db_now>.
  ASSIGN lr_old_db->* TO <ls_db_old>.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    " NEWREC?
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_is_new = abap_true.
    ELSE.
      lv_is_new = abap_false.
    ENDIF.

    " WHERE theo khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields CHANGING lv_where lv_we.
    IF lv_where IS INITIAL.
      MESSAGE |Không tạo được WHERE từ key fields: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    " Lazy init danh sách cần lưu
    IF lo_line IS INITIAL.
      lo_line ?= cl_abap_typedescr=>describe_by_data( <ls_data> ).
      lo_tab  = cl_abap_tabledescr=>create( p_line_type = lo_line ).
      CREATE DATA lr_to_save TYPE HANDLE lo_tab.
      ASSIGN lr_to_save->* TO <lt_to_save>.
    ENDIF.

    " Đọc bản ghi cũ từ DB
    CREATE DATA lr_old LIKE <ls_data>.
    ASSIGN lr_old->* TO <ls_old>.
    CLEAR <ls_old>.

    TRY.
        SELECT SINGLE * FROM (p_tab)
          WHERE (lv_where)
          INTO CORRESPONDING FIELDS OF @<ls_old>.
      CATCH cx_sy_dynamic_osql_syntax INTO lxsql.
        MESSAGE lxsql->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
        CLEAR <ls_old>.
        sy-subrc = 4.
    ENDTRY.

    " INSERT mới
    IF lv_is_new = abap_true AND sy-subrc <> 0.
      " --- CHỈ set Created*, KHÔNG set Changed* ---
      FIELD-SYMBOLS: <erdat> TYPE any, <ertim> TYPE any, <ernam> TYPE any.
      ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <ls_data> TO <erdat>.
      ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <ls_data> TO <ertim>.
      ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <ls_data> TO <ernam>.
      IF <erdat> IS ASSIGNED. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED. <ernam> = sy-uname. ENDIF.

      DATA(ls_a_i) = VALUE ty_audit(
        tabname = p_tab
        action  = 'INSERT'
        uname   = sy-uname
        udate   = sy-datum
        utime   = sy-uzeit ).
      PERFORM to_json USING <ls_data> CHANGING ls_a_i-after_json.
      CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_i-logid.
      APPEND ls_a_i TO gt_audit.

      APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
      MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
      PERFORM log_audit_action USING p_tab 'C' <ls_data>.

    ELSE.
      " --- UPDATE (chỉ set Changed* nếu khác DB và không phải dòng mới) ---
      CLEAR: <ls_db_now>, <ls_db_old>.
      MOVE-CORRESPONDING <ls_data> TO <ls_db_now>.
      MOVE-CORRESPONDING <ls_old>  TO <ls_db_old>.
      ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_db_now> TO <fs_mandt>.
      IF sy-subrc = 0 AND <fs_mandt> IS ASSIGNED.
        <fs_mandt> = sy-mandt.
      ENDIF.

      IF <ls_db_old> <> <ls_db_now>.
        FIELD-SYMBOLS: <aedat> TYPE any, <aetim> TYPE any, <aenam> TYPE any.
        ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <ls_data> TO <aedat>.
        ASSIGN COMPONENT 'AETIM' OF STRUCTURE <ls_data> TO <aetim>.
        ASSIGN COMPONENT 'AENAM' OF STRUCTURE <ls_data> TO <aenam>.
        IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
        IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
        IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.

        DATA(ls_a_u) = VALUE ty_audit(
          tabname = p_tab
          action  = 'UPDATE'
          uname   = sy-uname
          udate   = sy-datum
          utime   = sy-uzeit ).
        PERFORM to_json USING <ls_old>  CHANGING ls_a_u-before_json.
        PERFORM to_json USING <ls_data> CHANGING ls_a_u-after_json.
        CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a_u-logid.
        APPEND ls_a_u TO gt_audit.

        APPEND INITIAL LINE TO <lt_to_save> ASSIGNING <ls_to_save>.
        MOVE-CORRESPONDING <ls_data> TO <ls_to_save>.
        PERFORM log_audit_action USING p_tab 'U' <ls_data>.
      ENDIF.
    ENDIF.

    " Xóa cờ NEWREC sau khi xử lý
    IF lv_is_new = abap_true.
      CLEAR <newrec>.
    ENDIF.
  ENDLOOP.

  " 3) Lưu DB
  IF <lt_to_save> IS NOT ASSIGNED OR <lt_to_save> IS INITIAL.
    MESSAGE 'Không có dữ liệu hợp lệ để lưu.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM save_data USING p_tab
                    CHANGING lr_to_save
                             lv_mod
                             lv_err.
  IF lv_err IS NOT INITIAL.
    ROLLBACK WORK.
    MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 4) Ghi audit log
  TYPES: BEGIN OF ty_audit_db,
           mandt       TYPE mandt,
           logid       TYPE char32,
           uname       TYPE syuname,
           udate       TYPE sydatum,
           utime       TYPE syuzeit,
           tabname     TYPE tabname,
           action      TYPE char10,
           before_json TYPE zde_json_txt,
           after_json  TYPE zde_json_txt,
         END OF ty_audit_db.

  DATA wa_log TYPE ty_audit_db.
  LOOP AT gt_audit ASSIGNING FIELD-SYMBOL(<a>).
    CLEAR wa_log.
    MOVE-CORRESPONDING <a> TO wa_log.
    wa_log-mandt = sy-mandt.
    INSERT zaudit_log FROM wa_log.
  ENDLOOP.

  " 5) Commit + Refresh ALV + Quay về View Mode
  COMMIT WORK AND WAIT.

  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display( EXPORTING is_stable = ls_stbl ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.

  " Thông báo kết quả
  DATA(lv_ins) = REDUCE i( INIT x = 0 FOR a IN gt_audit WHERE ( action = 'INSERT' ) NEXT x = x + 1 ).
  DATA(lv_upd) = REDUCE i( INIT y = 0 FOR a IN gt_audit WHERE ( action = 'UPDATE' ) NEXT y = y + 1 ).
  DATA(lv_cnt) = lines( <lt_to_save> ).
  MESSAGE |Đã lưu { lv_cnt } dòng (INSERT={ lv_ins }, UPDATE={ lv_upd }) và quay về chế độ xem.| TYPE 'S'.

ENDFORM.




FORM delete_selected USING iv_tab TYPE tabname
                     CHANGING ev_msg TYPE c
                              ev_err TYPE c.

  CLEAR: ev_msg, ev_err.

  " Giữ lại trạng thái Edit/Add trước khi xóa để khôi phục cuối form (cú pháp cổ điển)
  DATA lv_keep_edit TYPE abap_bool.
  IF gv_edit_md = abap_true OR gv_add_mode = abap_true.
    lv_keep_edit = abap_true.
  ELSE.
    lv_keep_edit = abap_false.
  ENDIF.

  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any.
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS INITIAL.
    ev_err = 'Không có dữ liệu để xóa.'.
    RETURN.
  ENDIF.

  " Lấy danh sách chọn
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_sel_idx TYPE lvc_s_row.
  REFRESH lt_sel_idx.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  " Nếu chưa chọn thì lấy dòng hiện tại
  IF lt_sel_idx IS INITIAL.
    DATA ls_rowid TYPE lvc_s_row.
    DATA ls_colid TYPE lvc_s_col.
    IF g_alv_grid IS BOUND.
      TRY.
          g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
        CATCH cx_root.
      ENDTRY.
    ENDIF.
    IF ls_rowid-index IS INITIAL.
      ev_err = 'Vui lòng chọn hoặc đặt con trỏ vào dòng cần xóa.'.
      RETURN.
    ENDIF.
    CLEAR ls_sel_idx.
    ls_sel_idx-index = ls_rowid-index.
    APPEND ls_sel_idx TO lt_sel_idx.
  ENDIF.

  " Đảo ngược index để delete không lệch
  DATA: lt_idx TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_i   TYPE i.
  REFRESH lt_idx.
  LOOP AT lt_sel_idx INTO ls_sel_idx.
    lv_i = ls_sel_idx-index.
    APPEND lv_i TO lt_idx.
  ENDLOOP.
  SORT lt_idx DESCENDING.

  " Đảm bảo danh sách khóa
  PERFORM ensure_keys USING iv_tab.
  IF gt_key_fields IS INITIAL.
    ev_err = 'Bảng không có khóa trong DDIC — không thể xóa.'.
    RETURN.
  ENDIF.

  " Chuẩn bị audit buffer
  REFRESH gt_audit.

  " Biến làm việc
  DATA: lv_where          TYPE string,
        lv_we             TYPE string,
        lv_exists         TYPE abap_bool,
        lv_deleted        TYPE i,
        lv_newrec_deleted TYPE i.
  CLEAR: lv_deleted, lv_newrec_deleted.

  LOOP AT lt_idx INTO lv_i.
    READ TABLE <lt> ASSIGNING <ls> INDEX lv_i.
    IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    " 1) Dòng NEWREC -> chỉ xóa khỏi ALV
    FIELD-SYMBOLS <newrec> TYPE any.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> IS ASSIGNED AND <newrec> = 'X'.
      DELETE <lt> INDEX lv_i.
      lv_newrec_deleted = lv_newrec_deleted + 1.
      CONTINUE.
    ENDIF.

    " 2) Dòng DB cũ -> kiểm tra đủ khóa
    DATA any_empty TYPE abap_bool.
    any_empty = abap_false.

    FIELD-SYMBOLS: <comp>  TYPE any,
                   <fname> TYPE dd03l-fieldname.
    LOOP AT gt_key_fields ASSIGNING <fname>.
      ASSIGN COMPONENT <fname> OF STRUCTURE <ls> TO <comp>.
      IF sy-subrc = 0 AND <comp> IS INITIAL.
        any_empty = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF any_empty = abap_true.
      " Khóa không đủ → chỉ xóa khỏi lưới cho sạch
      DELETE <lt> INDEX lv_i.
      ev_msg = 'Dòng có khóa không đầy đủ đã được xóa khỏi lưới.'.
      CONTINUE.
    ENDIF.

    " Build điều kiện WHERE từ khóa
    CLEAR: lv_where, lv_we.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      ev_err = 'Không xây được điều kiện khóa để xóa.'.
      EXIT.
    ENDIF.

    " Có còn tồn tại trong DB không?
    CLEAR lv_exists.
    TRY.
        SELECT SINGLE @abap_true FROM (iv_tab) WHERE (lv_where) INTO @lv_exists.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del1).
          ev_err = lx_del1->get_text( ).
          EXIT.
      ENDTRY.

      IF sy-subrc <> 0.
        " Không còn trong DB -> xóa khỏi ALV cho sạch
        DELETE <lt> INDEX lv_i.
        CONTINUE.
      ENDIF.

      " Lưu bản cũ để audit
      DATA lr_old TYPE REF TO data.
      CREATE DATA lr_old LIKE <ls>.
      FIELD-SYMBOLS <ls_old> TYPE any.
      ASSIGN lr_old->* TO <ls_old>.
      CLEAR <ls_old>.

      TRY.
          SELECT SINGLE * FROM (iv_tab) WHERE (lv_where)
            INTO CORRESPONDING FIELDS OF @<ls_old>.
          CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del2).
            ev_err = lx_del2->get_text( ).
            EXIT.
        ENDTRY.
        IF ev_err IS NOT INITIAL.
          EXIT.
        ENDIF.
        IF sy-subrc <> 0.
          <ls_old> = <ls>.
        ENDIF.

        " Xóa DB
        TRY.
            DELETE FROM (iv_tab) WHERE (lv_where).
          CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_del3).
            ev_err = lx_del3->get_text( ).
            EXIT.
        ENDTRY.
        IF sy-subrc <> 0.
          ev_err = 'Xóa DB thất bại cho 1 dòng; dừng lại.'.
          EXIT.
        ENDIF.

        " Xóa khỏi ALV & ghi audit
        DELETE <lt> INDEX lv_i.

        DATA ls_a TYPE ty_audit.
        CLEAR ls_a.
        ls_a-tabname = iv_tab.
        ls_a-action  = 'DELETE'.
        ls_a-uname   = sy-uname.
        ls_a-udate   = sy-datum.
        ls_a-utime   = sy-uzeit.
        PERFORM to_json USING <ls_old> CHANGING ls_a-before_json.
        CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = ls_a-logid.
        APPEND ls_a TO gt_audit.

        lv_deleted = lv_deleted + 1.
      ENDLOOP.

      " === Sau xóa: quét lại xem còn dòng NEWREC='X' nào không ===
      DATA(lv_still_has_newrec) = abap_false.
      LOOP AT <lt> ASSIGNING <ls>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          lv_still_has_newrec = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF ev_err IS NOT INITIAL.
        ROLLBACK WORK.
        RETURN.
      ENDIF.

      " Ghi audit vào bảng log
      IF gt_audit IS NOT INITIAL.
        TYPES: BEGIN OF ty_audit_db,
                 mandt       TYPE mandt,
                 logid       TYPE char32,
                 uname       TYPE syuname,
                 udate       TYPE sydatum,
                 utime       TYPE syuzeit,
                 tabname     TYPE tabname,
                 action      TYPE char10,
                 before_json TYPE zde_json_txt,
                 after_json  TYPE zde_json_txt,
               END OF ty_audit_db.
        DATA wa_log      TYPE ty_audit_db.
        DATA lv_audit_tab TYPE tabname.
        lv_audit_tab = 'ZAUDIT_LOG'.

        FIELD-SYMBOLS <a> TYPE ty_audit.
        LOOP AT gt_audit ASSIGNING <a>.
          CLEAR wa_log.
          wa_log-mandt       = sy-mandt.
          wa_log-logid       = <a>-logid.
          wa_log-uname       = <a>-uname.
          wa_log-udate       = <a>-udate.
          wa_log-utime       = <a>-utime.
          wa_log-tabname     = <a>-tabname.
          wa_log-action      = <a>-action.
          wa_log-before_json = <a>-before_json.
          INSERT (lv_audit_tab) FROM wa_log.
        ENDLOOP.
      ENDIF.

      " Chỉ COMMIT khi có xóa DB hoặc có ghi audit
      IF lv_deleted > 0 OR gt_audit IS NOT INITIAL.
        COMMIT WORK AND WAIT.
      ENDIF.

      " Nếu chỉ xóa NEWREC nhưng trước đó có sửa dòng cũ → reload để về trạng thái sạch
      DATA lv_had_dirty TYPE abap_bool.
      lv_had_dirty = gv_dirty.
      IF lv_deleted = 0 AND lv_newrec_deleted > 0 AND lv_had_dirty = abap_true.
        DATA lv_rows2 TYPE i.
        DATA lv_err2  TYPE string.
        PERFORM load_data USING iv_tab 0 CHANGING gr_data lv_rows2 lv_err2.
        IF lv_err2 IS INITIAL.
          gv_dirty = abap_false.
        ELSE.
          ev_err = |Reload dữ liệu sau khi xóa NEWREC thất bại: | && lv_err2.
        ENDIF.
      ENDIF.

      " Message tổng kết
      ev_msg = |Đã xóa | && lv_deleted && | dòng DB và | &&
               lv_newrec_deleted && | dòng NEWREC.|.

      " Khôi phục mode
      gv_dirty    = abap_false.
      gv_add_mode = COND #( WHEN lv_still_has_newrec = abap_true THEN abap_true ELSE abap_false ).
      IF lv_keep_edit = abap_true.
        gv_edit_md      = abap_true.
        gv_toolbar_mode = 'E'.
      ELSE.
        gv_edit_md      = abap_false.
        gv_toolbar_mode = 'D'.
      ENDIF.

      PERFORM apply_editability_and_push.

      " Nếu còn NEWREC thì focus vào key của dòng NEWREC cuối cùng
      IF lv_still_has_newrec = abap_true.
        PERFORM focus_key_on_newrec.
      ENDIF.

      IF g_alv_grid IS BOUND.
        IF gv_edit_md = abap_true.
          g_alv_grid->set_ready_for_input( 1 ).
        ELSE.
          g_alv_grid->set_ready_for_input( 0 ).
        ENDIF.
        g_alv_grid->refresh_table_display(
          EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
        TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
      ENDIF.

ENDFORM.


*-------------------------------------------------------------*
* Popup hiển thị log rollback
*-------------------------------------------------------------*
FORM show_audit_log_popup USING iv_tab TYPE tabname.
  DATA: lt_log      TYPE STANDARD TABLE OF zaudit_log,
        ls_log      TYPE zaudit_log,
        ls_selfield TYPE slis_selfield.

  SELECT *
  FROM zaudit_log
  INTO TABLE @lt_log
  WHERE tabname = @iv_tab
  ORDER BY udate DESCENDING, utime DESCENDING.

    IF lt_log IS INITIAL.
      MESSAGE 'Không có log nào để rollback' TYPE 'I'.
      RETURN.
    ENDIF.

    CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
      EXPORTING
        i_title               = |Chọn log rollback cho bảng { iv_tab }|
        i_zebra               = 'X'
        i_screen_start_column = 10
        i_screen_start_line   = 5
        i_screen_end_column   = 100
        i_screen_end_line     = 20
      IMPORTING
        es_selfield           = ls_selfield
      TABLES
        t_outtab              = lt_log
      EXCEPTIONS
        OTHERS                = 1.

    IF sy-subrc = 0 AND ls_selfield-tabindex > 0.
      READ TABLE lt_log INDEX ls_selfield-tabindex INTO ls_log.
      IF sy-subrc = 0.
        PERFORM rollback_from_log USING ls_log.
      ENDIF.
    ENDIF.
ENDFORM.

*-------------------------------------------------------------*
* Rollback từ 1 log
*-------------------------------------------------------------*
FORM rollback_from_log USING is_log TYPE zaudit_log.
  DATA: lr_before    TYPE REF TO data,
        lr_curr_data TYPE REF TO data,
        lv_err       TYPE string,
        lv_mod       TYPE i,
        lv_json      TYPE zde_json_txt,
        lv_curr_json TYPE zde_json_txt.

  FIELD-SYMBOLS: <lt>      TYPE STANDARD TABLE,
                 <lt_curr> TYPE STANDARD TABLE,
                 <ls>      TYPE any,
                 <ls_curr> TYPE any.

  IF is_log-tabname IS INITIAL.
    MESSAGE 'Tên bảng không được để trống' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  lv_json = is_log-before_json.
  IF lv_json IS INITIAL AND is_log-action <> 'INSERT'.
    MESSAGE 'JSON trước đó rỗng, không thể rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM json_to_itab USING is_log-tabname lv_json CHANGING lr_before.
  ASSIGN lr_before->* TO <lt>.
  IF <lt> IS NOT ASSIGNED.
    MESSAGE 'Không parse được JSON để rollback' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_dyn_itab USING is_log-tabname CHANGING lr_curr_data.
  IF lr_curr_data IS NOT BOUND.
    MESSAGE 'Không tạo được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.
  ASSIGN lr_curr_data->* TO <lt_curr>.
  IF <lt_curr> IS NOT ASSIGNED.
    MESSAGE 'Không assign được itab động cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING is_log-tabname.
  IF gt_key_fields IS INITIAL.
    MESSAGE |Không tìm thấy key fields cho bảng { is_log-tabname }| TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  CLEAR <lt_curr>.
  DATA: lo_tabledesc TYPE REF TO cl_abap_tabledescr,
        lo_linedesc  TYPE REF TO cl_abap_structdescr.
  lo_tabledesc ?= cl_abap_typedescr=>describe_by_data_ref( lr_before ).
  lo_linedesc  ?= lo_tabledesc->get_table_line_type( ).

  LOOP AT <lt> ASSIGNING <ls>.
    DATA: lv_where TYPE string,
          lv_we    TYPE string.
    PERFORM make_where_from_key USING <ls> gt_key_fields CHANGING lv_where lv_we.
    IF lv_we IS NOT INITIAL OR lv_where IS INITIAL.
      MESSAGE |Không xây được điều kiện khóa: { lv_we }| TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    DATA lr_line TYPE REF TO data.
    CREATE DATA lr_line TYPE HANDLE lo_linedesc.
    ASSIGN lr_line->* TO <ls_curr>.
    IF <ls_curr> IS NOT ASSIGNED.
      MESSAGE 'Không tạo được cấu trúc dòng cho trạng thái hiện tại' TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    TRY.
        SELECT SINGLE * FROM (is_log-tabname) WHERE (lv_where) INTO @<ls_curr>.
        CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_rb1).
          MESSAGE lx_rb1->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.
      IF sy-subrc = 0.
        APPEND <ls_curr> TO <lt_curr>.
      ENDIF.
    ENDLOOP.

    IF <lt_curr> IS NOT INITIAL.
      /ui2/cl_json=>serialize(
        EXPORTING data        = <lt_curr>
                  pretty_name = /ui2/cl_json=>pretty_mode-none
        RECEIVING r_json      = lv_curr_json ).
    ELSE.
      lv_curr_json = '[]'.
    ENDIF.

    PERFORM save_data USING is_log-tabname
                      CHANGING lr_before lv_mod lv_err.

    IF lv_err IS INITIAL.
      DATA: lv_newlogid TYPE char32,
            ls_new      TYPE zaudit_log.
      CALL FUNCTION 'GUID_CREATE' IMPORTING ev_guid_32 = lv_newlogid.

      CLEAR ls_new.
      ls_new-mandt       = sy-mandt.
      ls_new-logid       = lv_newlogid.
      ls_new-uname       = sy-uname.
      ls_new-udate       = sy-datum.
      ls_new-utime       = sy-uzeit.
      ls_new-tabname     = is_log-tabname.
      ls_new-action      = 'ROLLBACK'.
      ls_new-before_json = lv_curr_json.
      ls_new-after_json  = lv_json.

      INSERT zaudit_log FROM ls_new.
      COMMIT WORK AND WAIT.
      gv_dirty = abap_false.
      DATA lv_subj TYPE so_obj_des.
      DATA lv_mail_rc TYPE i.
      lv_subj = |[RB OK] { is_log-tabname } LOG { lv_newlogid(8) }|.
      PERFORM send_mail_min USING lv_subj 'thanhchse171611@fpt.edu.vn'.
      lv_mail_rc = sy-subrc.
    ELSE.
      ROLLBACK WORK.
      MESSAGE lv_err TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail tối giản (raw)
*---------------------------------------------------------------------*
FORM send_mail_min USING iv_subject TYPE so_obj_des
iv_to TYPE ad_smtpadr.
  DATA: lo_req      TYPE REF TO cl_bcs,
        lo_doc      TYPE REF TO cl_document_bcs,
        lo_rcpt     TYPE REF TO if_recipient_bcs,
        lt_text     TYPE bcsy_text,
        ls_line     LIKE LINE OF lt_text,
        lv_to_local TYPE ad_smtpadr.

  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

  CLEAR lt_text.
  ls_line-line = |Rollback thành công từ { sy-repid } (user { sy-uname }).|.
  APPEND ls_line TO lt_text.

  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'RAW'
                 i_text    = lt_text
                 i_subject = iv_subject ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " (A) TẮT thông báo trạng thái gửi (không nhận status mail/express)
      lo_req->set_status_attributes(
        i_requested_status = 'N'  " no MDN/status request
        i_status_mail      = 'N'    " no status mail back to sender
      ).

      " (B) GỬI CHO BẠN VÀO SBWP NHƯNG KHÔNG EXPRESS (=> KHÔNG POPUP)
      lo_req->add_recipient(
        i_recipient = cl_sapuser_bcs=>create( sy-uname )
        i_express   = abap_false ).

      " (C) GỬI RA EMAIL INTERNET – cũng KHÔNG express
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient = lo_rcpt
        i_express   = abap_false
        i_copy      = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Restore data từ JSON (dùng cho rollback)
*---------------------------------------------------------------------*
FORM restore_data USING iv_tabname TYPE tabname
                        iv_json    TYPE zde_json_txt
                  CHANGING ev_err  TYPE string
                           ev_mod  TYPE i.

  DATA: lr_data  TYPE REF TO data,
        lv_where TYPE string,
        lv_msg   TYPE string.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any.

  CLEAR: ev_err, ev_mod.

  PERFORM json_to_itab USING iv_tabname iv_json CHANGING lr_data.
  ASSIGN lr_data->* TO <lt_data>.
  IF <lt_data> IS NOT ASSIGNED OR <lt_data> IS INITIAL.
    ev_err = |Không parse được JSON để restore cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  PERFORM ensure_keys USING iv_tabname.
  IF gt_key_fields IS INITIAL.
    ev_err = |Không tìm thấy key fields cho bảng { iv_tabname }|.
    RETURN.
  ENDIF.

  LOOP AT <lt_data> ASSIGNING <ls_data>.
    PERFORM make_where_from_key USING <ls_data> gt_key_fields
      CHANGING lv_where lv_msg.
    IF lv_where IS INITIAL.
      ev_err = |Không tạo được WHERE: { lv_msg }|.
      RETURN.
    ENDIF.

    TRY.
        DELETE FROM (iv_tabname) WHERE (lv_where).
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(lx_r1).
        ev_err = lx_r1->get_text( ).
        RETURN.
    ENDTRY.

    INSERT (iv_tabname) FROM <ls_data>.
    IF sy-subrc = 0.
      ev_mod = ev_mod + 1.
    ELSE.
      ev_err = |Không insert được dòng trong { iv_tabname } với WHERE { lv_where }|.
      RETURN.
    ENDIF.
  ENDLOOP.
ENDFORM.

*-------------------------------------------------------------*
* JSON -> itab động (rollback) – đồng bộ pretty_mode = none
*-------------------------------------------------------------*
FORM json_to_itab USING iv_tab  TYPE tabname
                        iv_json TYPE zde_json_txt
                  CHANGING cr_data TYPE REF TO data.
  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_table  TYPE REF TO cl_abap_tabledescr,
        lr_any    TYPE REF TO data,
        lr_row    TYPE REF TO data.

  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_row>  TYPE any.

  TRY.
      lo_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
      lo_table  = cl_abap_tabledescr=>create( lo_struct ).
      CREATE DATA lr_any TYPE HANDLE lo_table.
      ASSIGN lr_any->* TO <lt_data>.

      /ui2/cl_json=>deserialize(
  EXPORTING json        = iv_json
            pretty_name = /ui2/cl_json=>pretty_mode-none
  CHANGING  data        = <lt_data> ).

      IF <lt_data> IS INITIAL.
        CREATE DATA lr_row TYPE HANDLE lo_struct.
        ASSIGN lr_row->* TO <ls_row>.
        /ui2/cl_json=>deserialize(
          EXPORTING json        = iv_json
                    pretty_name = /ui2/cl_json=>pretty_mode-none
          CHANGING  data        = <ls_row> ).
        APPEND <ls_row> TO <lt_data>.
      ENDIF.

      cr_data = lr_any.
    CATCH cx_root INTO DATA(lx).
      MESSAGE lx->get_text( ) TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

*---------------------------------------------------------------------*
* Gửi mail sau khi rollback – (wrapper, có fallback) — FINAL (SO_OBJ_DES)
*---------------------------------------------------------------------*
FORM notify_rollback_smtp
  USING is_log       TYPE zaudit_log
        iv_mod       TYPE i
        iv_curr_json TYPE zde_json_txt
        iv_prev_json TYPE zde_json_txt
        iv_note      TYPE string.

  DATA: lv_to TYPE ad_smtpadr VALUE 'thanhchse171611@fpt.edu.vn'.

  " Gửi mail chi tiết + note batch trong 1 email
  PERFORM send_mail_rb_detail USING is_log-tabname
                                    is_log-logid
                                    iv_mod
                                    lv_to
                                    iv_curr_json
                                    iv_prev_json
                                    iv_note.

  IF sy-subrc <> 0.
    " Fallback: SUBJECT phải là SO_OBJ_DES (không phải string)
    DATA lv_subj_fallback TYPE so_obj_des.
    lv_subj_fallback = CONV so_obj_des(
                          |[ROLLBACK OK] { is_log-tabname } - LOG { is_log-logid(8) } - { iv_mod } row(s)| ).

    " SEND_MAIL_MIN đang khai báo IV_SUBJECT TYPE SO_OBJ_DES, IV_TO TYPE AD_SMTPADR
    PERFORM send_mail_min USING lv_subj_fallback lv_to.
  ENDIF.
ENDFORM.



*---------------------------------------------------------------------*
* Gửi mail rollback chi tiết (html) – giữ nguyên luồng chính + note batch
*---------------------------------------------------------------------*
FORM send_mail_rb_detail
  USING iv_tab        TYPE tabname
        iv_logid      TYPE zaudit_log-logid
        iv_rows       TYPE i
        iv_to         TYPE ad_smtpadr
        iv_json_curr  TYPE zde_json_txt
        iv_json_after TYPE zde_json_txt
        iv_note       TYPE string.

  DATA: lo_req        TYPE REF TO cl_bcs,
        lo_doc        TYPE REF TO cl_document_bcs,
        lo_rcpt       TYPE REF TO if_recipient_bcs,
        lo_rcptso     TYPE REF TO if_recipient_bcs,
        lt_body       TYPE bcsy_text,
        lv_subj       TYPE so_obj_des,
        lv_html       TYPE string,
        lv_curr_html  TYPE string,
        lv_after_html TYPE string,
        lv_to_local   TYPE ad_smtpadr.

  lv_to_local = iv_to.
  IF lv_to_local IS INITIAL.
    lv_to_local = 'thanhchse171611@fpt.edu.vn'.
  ENDIF.

  " Escape + cắt JSON (tránh vỡ HTML)
  PERFORM _html_escape     USING iv_json_curr  CHANGING lv_curr_html.
  PERFORM _html_escape     USING iv_json_after CHANGING lv_after_html.
  PERFORM _ellipsize_html  USING lv_curr_html  8000 CHANGING lv_curr_html.
  PERFORM _ellipsize_html  USING lv_after_html 8000 CHANGING lv_after_html.

  lv_subj = |[ROLLBACK OK] { iv_tab } - LOG { iv_logid(8) } - { iv_rows } row(s)|.

  " Header + meta
  lv_html =
    |<html><head><meta charset="utf-8"></head>| &&
    |<body style="font-family:Arial,sans-serif;font-size:13px;color:#111;margin:0;padding:16px;background:#fafafa">| &&
    |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin-bottom:12px">| &&
    |<h3 style="font-size:16px;margin:0 0 8px 0">Rollback thành công | &&
    |<span style="display:inline-block;padding:2px 8px;border-radius:999px;background:#e2f3e8;color:#065f46;font-size:12px">{ iv_rows } row(s)</span>| &&
    |</h3>| &&
    |<table style="border-collapse:collapse">| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Bảng</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_tab }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Log ID</b></td><td style="padding:4px 8px;vertical-align:top">{ iv_logid }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Người thực hiện</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-uname }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Chương trình</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-repid }</td></tr>| &&
    |<tr><td style="padding:4px 8px;vertical-align:top"><b>Thời gian</b></td><td style="padding:4px 8px;vertical-align:top">{ sy-datum } { sy-uzeit }</td></tr>| &&
    |</table></div>|.

  " ====== CHÈN NOTE (danh sách batch) nếu có ======
  IF iv_note IS NOT INITIAL.
    DATA(lv_note_html) = iv_note.
    PERFORM _html_escape     USING lv_note_html CHANGING lv_note_html.
    PERFORM _ellipsize_html  USING lv_note_html 4000 CHANGING lv_note_html.

    lv_html = lv_html &&
      |<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">| &&
      |<h4 style="margin:0 0 8px 0;font-size:14px">Batch details</h4>| &&
      |<pre style="white-space:pre-wrap;font-family:Consolas,Menlo,monospace;font-size:12px;margin:0">| &&
      lv_note_html &&
      |</pre></div>|.
  ENDIF.

  " ====== PHẦN DIFF (nếu bạn muốn hiển thị biến động JSON) ======
  DATA lv_diff_html TYPE string.
  PERFORM build_html_diff USING    iv_tab
                                   iv_json_curr
                                   iv_json_after
                          CHANGING lv_diff_html.
  lv_html = lv_html && lv_diff_html && |</body></html>|.

  " Convert HTML string -> bcsy_text
  PERFORM _string_to_bcs_text USING lv_html CHANGING lt_body.

  " Gửi qua BCS
  TRY.
      lo_req = cl_bcs=>create_persistent( ).
      lo_doc = cl_document_bcs=>create_document(
                 i_type    = 'HTM'
                 i_text    = lt_body
                 i_subject = lv_subj ).
      lo_req->set_document( lo_doc ).
      lo_req->set_sender( cl_sapuser_bcs=>create( sy-uname ) ).

      " (A) TẮT status notification
      lo_req->set_status_attributes(
        i_requested_status = 'N'
        i_status_mail      = 'N' ).

      " (B) SBWP của bạn – KHÔNG express
      lo_rcptso = cl_sapuser_bcs=>create( sy-uname ).
      lo_req->add_recipient(
        i_recipient = lo_rcptso
        i_express   = abap_false ).

      " (C) Email internet – KHÔNG express
      lo_rcpt = cl_cam_address_bcs=>create_internet_address( lv_to_local ).
      lo_req->add_recipient(
        i_recipient = lo_rcpt
        i_express   = abap_false
        i_copy      = abap_false
        i_blind_copy = abap_false ).

      lo_req->set_send_immediately( abap_true ).
      lo_req->send( i_with_error_screen = abap_false ).
      COMMIT WORK AND WAIT.
      sy-subrc = 0.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.


*---------------------------------------------------------------------*
* Helper: string -> bcsy_text (manual SPLIT 255 ký tự/line)
*---------------------------------------------------------------------*
FORM _string_to_bcs_text USING iv_str TYPE string
CHANGING ct_text TYPE bcsy_text.
  DATA: lv_off  TYPE i VALUE 0,
        lv_len  TYPE i,
        lv_take TYPE i,
        ls      TYPE soli.
  CLEAR ct_text.
  lv_len = strlen( iv_str ).
  WHILE lv_off < lv_len.
    lv_take = lv_len - lv_off.
    IF lv_take > 255.
      lv_take = 255.
    ENDIF.
    CLEAR ls.
    ls-line = iv_str+lv_off(lv_take).
    APPEND ls TO ct_text.
    lv_off = lv_off + lv_take.
  ENDWHILE.
  IF ct_text IS INITIAL.
    CLEAR ls.
    APPEND ls TO ct_text.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: escape tối thiểu để nhúng json vào html safely
*---------------------------------------------------------------------*
FORM _html_escape USING iv_in TYPE string
CHANGING cv_out TYPE string.
  cv_out = iv_in.
  REPLACE ALL OCCURRENCES OF '&' IN cv_out WITH '&amp;'.
  REPLACE ALL OCCURRENCES OF '<' IN cv_out WITH '&lt;'.
  REPLACE ALL OCCURRENCES OF '>' IN cv_out WITH '&gt;'.
  REPLACE ALL OCCURRENCES OF '"' IN cv_out WITH '&quot;'.
  REPLACE ALL OCCURRENCES OF '''' IN cv_out WITH '&#39;'.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: rút gọn string nếu vượt max_len (thêm "... (truncated)")
*---------------------------------------------------------------------*
FORM _ellipsize_html USING iv_in TYPE string
iv_max_len TYPE i
CHANGING cv_out TYPE string.
  DATA: lv_len  TYPE i, lv_max TYPE i, lv_take TYPE i.
  lv_max = iv_max_len.
  IF lv_max IS INITIAL OR lv_max < 1000.
    lv_max = 1000.
  ENDIF.
  lv_len = strlen( iv_in ).
  IF lv_len > lv_max.
    lv_take = lv_max - 15.
    IF lv_take < 0.
      lv_take = 0.
    ENDIF.
    cv_out = iv_in+0(lv_take).
    cv_out = cv_out && |... (truncated)|.
  ELSE.
    cv_out = iv_in.
  ENDIF.
ENDFORM.

*---------------------------------------------------------------------*
*  Build HTML diff (COMPACT TABLE): 1 record -> 1 bảng ngang
*   Header:  Mô tả | <Field 1> | <Field 2> | ...
*   Body:    Before | ...values...   (ô khác biệt tô đỏ nhạt)
*            After  | ...values...   (ô khác biệt tô xanh nhạt)
*---------------------------------------------------------------------*
FORM build_html_diff USING    iv_tab        TYPE tabname
                              iv_json_curr  TYPE zde_json_txt
                              iv_json_after TYPE zde_json_txt
                     CHANGING cv_html       TYPE string.

  DATA: lr_data_curr  TYPE REF TO data,
        lr_data_after TYPE REF TO data,
        lt_fieldinfo  TYPE TABLE OF dfies,
        ls_field      TYPE dfies,
        lv_tab_up     TYPE tabname.

  FIELD-SYMBOLS: <lt_curr>  TYPE STANDARD TABLE,
                 <lt_after> TYPE STANDARD TABLE,
                 <ls_curr>  TYPE any,
                 <ls_after> TYPE any,
                 <old>      TYPE any,
                 <new>      TYPE any.

  DATA: lo_struct TYPE REF TO cl_abap_structdescr,
        lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Biến key (PHẢI là string để dùng CHANGING)
  DATA: lv_kc  TYPE string,
        lv_ka  TYPE string,
        lv_key TYPE string.

  " Tổng số field changed (cho legend cuối mail)
  DATA lv_changed_total TYPE i VALUE 0.

  " -- upper-case bảng
  lv_tab_up = iv_tab.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " 0) DDIC describe & field info
  lo_struct ?= cl_abap_typedescr=>describe_by_name( lv_tab_up ).
  IF lo_struct IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>Cannot describe DDIC structure.</i></div>'.
    RETURN.
  ENDIF.
  lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = lv_tab_up
      all_types = 'X'
    TABLES
      dfies_tab = lt_fieldinfo
    EXCEPTIONS
      OTHERS    = 1.
  IF lt_fieldinfo IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No DDIC field info for table.</i></div>'.
    RETURN.
  ENDIF.

  " 1) JSON -> itab động (có thể rỗng)
  PERFORM json_to_itab USING lv_tab_up iv_json_curr  CHANGING lr_data_curr.
  PERFORM json_to_itab USING lv_tab_up iv_json_after CHANGING lr_data_after.
  IF lr_data_curr IS BOUND.  ASSIGN lr_data_curr->*  TO <lt_curr>.  ENDIF.
  IF lr_data_after IS BOUND. ASSIGN lr_data_after->* TO <lt_after>. ENDIF.

  IF ( <lt_curr>  IS NOT ASSIGNED OR <lt_curr>  IS INITIAL )
 AND ( <lt_after> IS NOT ASSIGNED OR <lt_after> IS INITIAL ).
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No parsable data for diff (both before/after empty).</i></div>'.
    RETURN.
  ENDIF.

  " 2) Lấy key fields
  PERFORM ensure_keys IN PROGRAM (sy-repid) USING lv_tab_up IF FOUND.
  IF gt_key_fields IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key fields in DDIC.</i></div>'.
    RETURN.
  ENDIF.

  " 3) Hợp nhất các KEY từ cả Before/After
  DATA: lt_all_keys TYPE SORTED TABLE OF string WITH UNIQUE KEY table_line.
  IF <lt_curr> IS ASSIGNED.
    LOOP AT <lt_curr> ASSIGNING <ls_curr>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF <lt_after> IS ASSIGNED.
    LOOP AT <lt_after> ASSIGNING <ls_after>.
      CLEAR lv_key.
      PERFORM _make_key_str_any USING <ls_after> CHANGING lv_key.
      IF lv_key IS NOT INITIAL. INSERT lv_key INTO TABLE lt_all_keys. ENDIF.
    ENDLOOP.
  ENDIF.
  IF lt_all_keys IS INITIAL.
    cv_html = '<div style="padding:12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff"><i>No key found to pair rows.</i></div>'.
    RETURN.
  ENDIF.

  " 4) Render: mỗi KEY = 1 bảng ngang (1 header + 2 dòng Before/After)
  CLEAR cv_html.
  DATA: lv_block  TYPE string,
        lv_tbl    TYPE string,
        lv_head   TYPE string,
        lv_row_b  TYPE string,
        lv_row_a  TYPE string,
        lv_title  TYPE string,
        lv_desc   TYPE string,
        lv_desc_h TYPE string,
        lv_old    TYPE string,
        lv_new    TYPE string,
        lv_old_h  TYPE string,
        lv_new_h  TYPE string,
        lv_cnt    TYPE i VALUE 0.

  LOOP AT lt_all_keys INTO lv_key.
    ADD 1 TO lv_cnt.

    " — Tìm bản ghi theo KEY ở Before / After
    UNASSIGN: <ls_curr>, <ls_after>.
    IF <lt_curr> IS ASSIGNED.
      LOOP AT <lt_curr> ASSIGNING <ls_curr>.
        CLEAR lv_kc.
        PERFORM _make_key_str_any USING <ls_curr> CHANGING lv_kc.
        IF lv_kc = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.
    IF <lt_after> IS ASSIGNED.
      LOOP AT <lt_after> ASSIGNING <ls_after>.
        CLEAR lv_ka.
        PERFORM _make_key_str_any USING <ls_after> CHANGING lv_ka.
        IF lv_ka = lv_key. EXIT. ENDIF.
      ENDLOOP.
    ENDIF.

    " Nếu thiếu 1 phía -> tạo struct rỗng để vẫn render
    IF <ls_curr>  IS NOT ASSIGNED.
      DATA lr_zero_c TYPE REF TO data.
      CREATE DATA lr_zero_c TYPE HANDLE lo_struct.
      ASSIGN lr_zero_c->* TO <ls_curr>.
      CLEAR <ls_curr>.
    ENDIF.
    IF <ls_after> IS NOT ASSIGNED.
      DATA lr_zero_a TYPE REF TO data.
      CREATE DATA lr_zero_a TYPE HANDLE lo_struct.
      ASSIGN lr_zero_a->* TO <ls_after>.
      CLEAR <ls_after>.
    ENDIF.

    " — Title record
    lv_title = |Record { lv_cnt } — KEY [{ lv_key }]|.
    lv_block =
      '<div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:16px;margin:12px 0">'
   && |<div style="font-weight:600;font-size:14px;margin-bottom:10px">{ lv_title }</div>|
   && '<div style="overflow-x:auto">'
   && '<table style="border-collapse:collapse;min-width:720px;font-family:Arial,sans-serif;font-size:12px">'.

    " — Header (nền tối, chữ trắng)
    lv_head =
  '<tr>'
&& '<th style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left">Mô tả</th>'.

    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      " chọn nhãn dễ đọc
      lv_desc = ls_field-scrtext_l.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_m. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-scrtext_s. ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldtext.  ENDIF.
      IF lv_desc IS INITIAL. lv_desc = ls_field-fieldname.  ENDIF.
      PERFORM _html_escape USING lv_desc CHANGING lv_desc_h.

      lv_head &&=
        |<th style="background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb;text-align:left;white-space:nowrap">{ lv_desc_h }</th>|.
    ENDLOOP.
    lv_head &&= '</tr>'.

    " — Row BEFORE
    lv_row_b =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">Before</td>'.

    " — Row AFTER
    lv_row_a =
      '<tr>'
   && '<td style="position:sticky;left:0;background:#fff;color:#111;padding:8px 10px;border:1px solid #e5e7eb">After</td>'.

    " — Fill cells & đánh dấu thay đổi theo ô
    LOOP AT lt_fieldinfo INTO ls_field WHERE fieldname IS NOT INITIAL.
      CLEAR: lv_old, lv_new, lv_old_h, lv_new_h.

      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_curr>  TO <old>.
      IF <old> IS ASSIGNED. lv_old = <old>. ENDIF.
      ASSIGN COMPONENT ls_field-fieldname OF STRUCTURE <ls_after> TO <new>.
      IF <new> IS ASSIGNED. lv_new = <new>. ENDIF.

      PERFORM _html_escape USING lv_old CHANGING lv_old_h.
      PERFORM _html_escape USING lv_new CHANGING lv_new_h.

      DATA(lv_changed) = xsdbool( lv_old_h <> lv_new_h ).
      IF lv_changed = abap_true.
        lv_changed_total = lv_changed_total + 1.
      ENDIF.

      " Before-cell (đỏ nhạt nếu đổi)
      lv_row_b &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#FEE2E2;color:#991B1B;' ELSE '' )
       && |">{ lv_old_h }</td>|.

      " After-cell (xanh nhạt nếu đổi)
      lv_row_a &&=
        |<td style="padding:8px 10px;border:1px solid #e5e7eb;|
       &&  COND string( WHEN lv_changed = abap_true THEN 'background:#D1FAE5;color:#065F46;' ELSE '' )
       && |">{ lv_new_h }</td>|.
    ENDLOOP.

    lv_row_b &&= '</tr>'.
    lv_row_a &&= '</tr>'.

    lv_tbl = lv_head && lv_row_b && lv_row_a && '</table></div>'. " đóng table + overflow

    " — Gộp block
    lv_block &&= lv_tbl && '</div>'.
    cv_html  &&= lv_block.
  ENDLOOP.

  " Legend
  cv_html &&=
    |<div style="margin-top:8px;font-size:12px;color:#374151">|
 && |<b>{ lv_changed_total }</b> field(s) changed across records. |
 && |<span style="display:inline-block;margin-left:8px;padding:2px 6px;background:#FEE2E2;color:#991B1B;border-radius:999px">Before changed</span>|
 && |<span style="display:inline-block;margin-left:6px;padding:2px 6px;background:#D1FAE5;color:#065F46;border-radius:999px">After changed</span>|
 && |</div>|.

ENDFORM.


*---------------------------------------------------------------------*
* Tạo KEY string ổn định từ 1 dòng dựa trên gt_key_fields
*---------------------------------------------------------------------*
FORM _make_key_str_any
  USING    is_row TYPE any
  CHANGING cv_key TYPE string.

  DATA: lv_name TYPE dd03l-fieldname,
        lv_tmp  TYPE string,
        lv_part TYPE string.
  FIELD-SYMBOLS: <v> TYPE any.

  CLEAR cv_key.
  LOOP AT gt_key_fields INTO lv_name.
    ASSIGN COMPONENT lv_name OF STRUCTURE is_row TO <v>.
    CLEAR lv_part.
    IF sy-subrc = 0 AND <v> IS ASSIGNED.
      lv_tmp = <v>.
      TRANSLATE lv_tmp TO UPPER CASE.
      CONDENSE  lv_tmp NO-GAPS.
      lv_part = lv_tmp.
    ENDIF.
    IF cv_key IS INITIAL.
      cv_key = lv_part.
    ELSE.
      CONCATENATE cv_key lv_part INTO cv_key SEPARATED BY '|'.
    ENDIF.
  ENDLOOP.

ENDFORM.


*---------------------------------------------------------------------*
*  Get Data Element short text (DD04T-DDTEXT)
*---------------------------------------------------------------------*
FORM get_dtel_text USING    iv_rollname TYPE rollname
                   CHANGING cv_text     TYPE string.

  DATA ls_dd04v TYPE dd04v.

  CALL FUNCTION 'DDIF_DTEL_GET'
    EXPORTING
      name     = iv_rollname
    IMPORTING
      dd04v_wa = ls_dd04v
    EXCEPTIONS
      OTHERS   = 1.

  IF sy-subrc = 0 AND cv_text IS INITIAL AND ls_dd04v-ddtext IS NOT INITIAL.
    cv_text = ls_dd04v-ddtext.
  ENDIF.

ENDFORM.





*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
FORM check_unsaved_changes CHANGING ev_has_change TYPE abap_bool.
  FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE,
                 <ls_data> TYPE any,
                 <newrec>  TYPE any.

  ev_has_change = abap_false.

  " Nếu đang ở Add/Edit thì mới cần cảnh báo
  IF gv_add_mode = abap_true OR gv_edit_md = abap_true.

    " 1) Nếu đã có cờ bẩn => coi như chưa lưu
    IF gv_dirty = abap_true.
      ev_has_change = abap_true.
      RETURN.
    ENDIF.

    " 2) Hoặc có dòng NEWREC chưa lưu
    ASSIGN gr_data->* TO <lt_data>.
    IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
      LOOP AT <lt_data> ASSIGNING <ls_data>.
        ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_data> TO <newrec>.
        IF sy-subrc = 0 AND <newrec> = 'X'.
          ev_has_change = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.

FORM analyze_change_state CHANGING cv_new_incomplete TYPE abap_bool
cv_other_changes  TYPE abap_bool.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_has_newrec      TYPE abap_bool VALUE abap_false,
        lv_all_keys_filled TYPE abap_bool,
        lv_key             TYPE dd03l-fieldname,
        lv_val_str         TYPE string.

  cv_new_incomplete = abap_false.
  cv_other_changes  = abap_false.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_has_newrec      = abap_true.
        lv_all_keys_filled = abap_true.

        LOOP AT gt_key_fields INTO lv_key.
          ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc <> 0 OR <cell> IS NOT ASSIGNED.
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.

          " Chuẩn hóa để check INITIAL cho cả char/num
          CLEAR lv_val_str.
          TRY.
              lv_val_str = <cell>.
            CATCH cx_root.
              " Nếu không gán được string (kiểu số), check INITIAL trực tiếp
          ENDTRY.

          IF lv_val_str IS NOT INITIAL.
            CONDENSE lv_val_str.
          ENDIF.

          IF ( lv_val_str IS INITIAL ) AND ( <cell> IS INITIAL ).
            lv_all_keys_filled = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_all_keys_filled = abap_false.
          cv_new_incomplete = abap_true.
          EXIT. " chỉ cần biết có 1 NEWREC thiếu khóa là đủ
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF ( gv_dirty = abap_true AND cv_new_incomplete = abap_false )
  OR ( gv_dirty_nonnewrec = abap_true ).
    cv_other_changes = abap_true.
  ENDIF.

ENDFORM.


FORM is_newrec_target_for_delete CHANGING ev_newrec_only TYPE abap_bool.
  FIELD-SYMBOLS: <lt> TYPE STANDARD TABLE, <ls> TYPE any, <v> TYPE any.
  DATA: lt_sel_idx TYPE lvc_t_row,
        ls_rowid   TYPE lvc_s_row,
        ls_colid   TYPE lvc_s_col,
        lv_idx     TYPE i.

  ev_newrec_only = abap_false.

  IF g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_selected_rows( IMPORTING et_index_rows = lt_sel_idx ).
      CATCH cx_root.
    ENDTRY.
  ENDIF.

  IF lt_sel_idx IS INITIAL AND g_alv_grid IS BOUND.
    TRY.
        g_alv_grid->get_current_cell( IMPORTING es_row_id = ls_rowid es_col_id = ls_colid ).
      CATCH cx_root.
    ENDTRY.
    IF ls_rowid-index > 0.
      APPEND VALUE lvc_s_row( index = ls_rowid-index ) TO lt_sel_idx.
    ENDIF.
  ENDIF.

  IF lines( lt_sel_idx ) <> 1.
    RETURN.
  ENDIF.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE lt_sel_idx INTO DATA(ls_sel) INDEX 1.
  IF sy-subrc <> 0. RETURN. ENDIF.

  READ TABLE <lt> ASSIGNING <ls> INDEX ls_sel-index.
  IF sy-subrc <> 0 OR <ls> IS NOT ASSIGNED. RETURN. ENDIF.

  ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <v>.
  IF sy-subrc = 0 AND <v> = 'X'.
    " Kiểm tra xem dòng có trống hết key không
    DATA(lv_all_empty) = abap_true.
    LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<k>).
      ASSIGN COMPONENT <k> OF STRUCTURE <ls> TO FIELD-SYMBOL(<val>).
      IF sy-subrc = 0 AND <val> IS NOT INITIAL.
        lv_all_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_all_empty = abap_true.
      ev_newrec_only = abap_true.
    ENDIF.
  ENDIF.
ENDFORM.

FORM discard_unsaved_changes.
  FIELD-SYMBOLS: <lt_cur>  TYPE STANDARD TABLE,
                 <ls_cur>  TYPE any,
                 <lt_orig> TYPE STANDARD TABLE,
                 <ls_orig> TYPE any,
                 <flag>    TYPE any,
                 <kname>   TYPE dd03l-fieldname,
                 <v1>      TYPE any,
                 <v2>      TYPE any.

  " 0) Lấy itab hiện tại và bản gốc
  ASSIGN gr_data->*          TO <lt_cur>.
  ASSIGN gr_data_original->* TO <lt_orig>.
  IF <lt_cur> IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  " 1) Xóa toàn bộ dòng NEWREC (chưa lưu)
  DATA lt_del_idx TYPE STANDARD TABLE OF i WITH EMPTY KEY.
  LOOP AT <lt_cur> ASSIGNING <ls_cur>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_cur> TO <flag>.
    IF sy-subrc = 0 AND <flag> = 'X'.
      APPEND sy-tabix TO lt_del_idx.
    ENDIF.
  ENDLOOP.
  IF lt_del_idx IS NOT INITIAL.
    SORT lt_del_idx DESCENDING.
    LOOP AT lt_del_idx ASSIGNING FIELD-SYMBOL(<idx>).
      DELETE <lt_cur> INDEX <idx>.
    ENDLOOP.
  ENDIF.

  " 2) Khôi phục các dòng cũ đã sửa từ bản gốc theo KEY (không reload DB)
  IF <lt_orig> IS ASSIGNED AND <lt_orig> IS NOT INITIAL AND gt_key_fields IS NOT INITIAL.
    LOOP AT <lt_cur> ASSIGNING <ls_cur>.
      " tìm dòng tương ứng trong bản gốc theo khóa
      DATA(lv_found) = abap_false.
      LOOP AT <lt_orig> ASSIGNING <ls_orig>.
        DATA(lv_match) = abap_true.
        LOOP AT gt_key_fields ASSIGNING <kname>.
          ASSIGN COMPONENT <kname> OF STRUCTURE <ls_cur>  TO <v1>.
          ASSIGN COMPONENT <kname> OF STRUCTURE <ls_orig> TO <v2>.
          IF <v1> <> <v2>.
            lv_match = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF lv_match = abap_true.
          " copy lại các cột trùng tên (an toàn với cấu trúc động)
          MOVE-CORRESPONDING <ls_orig> TO <ls_cur>.
          lv_found = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

  " 3) Reset trạng thái & refresh UI
  gv_dirty        = abap_false.
  gv_add_mode     = abap_false.
  gv_edit_md      = abap_false.
  gv_toolbar_mode = 'D'.

  PERFORM apply_editability_and_push.
  IF g_alv_grid IS BOUND.
    TRY. g_alv_grid->set_ready_for_input( 0 ). CATCH cx_root. ENDTRY.
    g_alv_grid->refresh_table_display(
      EXPORTING is_stable = VALUE lvc_s_stbl( row = 'X' col = 'X' ) ).
    TRY. g_alv_grid->set_toolbar_interactive( ). CATCH cx_root. ENDTRY.
  ENDIF.
ENDFORM.


FORM purge_incomplete_newrecs.
  FIELD-SYMBOLS: <lt>   TYPE STANDARD TABLE,
                 <ls>   TYPE any,
                 <new>  TYPE any,
                 <cell> TYPE any.

  " Dùng bảng chỉ số để xóa theo INDEX (key mặc định)
  DATA: lt_del     TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_missing TYPE abap_bool,
        lv_key     TYPE dd03l-fieldname.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR <lt> IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <new>.
    IF sy-subrc = 0 AND <new> = 'X'.
      lv_missing = abap_false.
      LOOP AT gt_key_fields INTO lv_key.
        ASSIGN COMPONENT lv_key OF STRUCTURE <ls> TO <cell>.
        IF sy-subrc <> 0 OR <cell> IS INITIAL.
          lv_missing = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_missing = abap_true.
        APPEND sy-tabix TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF lt_del IS NOT INITIAL.
    SORT lt_del DESCENDING.
    LOOP AT lt_del ASSIGNING FIELD-SYMBOL(<idx>).
      DELETE <lt> INDEX <idx>.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM focus_key_on_newrec.
  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any.
  DATA: lv_idx TYPE i.

  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS NOT ASSIGNED OR g_alv_grid IS INITIAL.
    RETURN.
  ENDIF.

  lv_idx = 0.
  LOOP AT <lt> ASSIGNING <ls>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
    IF sy-subrc = 0 AND <newrec> = 'X'.
      lv_idx = sy-tabix.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF lv_idx = 0. RETURN. ENDIF.

  PERFORM ensure_keys USING p_tab.
  READ TABLE gt_key_fields INDEX 1 INTO DATA(lv_first_key).
  IF sy-subrc <> 0. RETURN. ENDIF.

  DATA ls_row TYPE lvc_s_row.
  DATA ls_col TYPE lvc_s_col.
  ls_row-index     = lv_idx.
  ls_col-fieldname = lv_first_key.

  TRY.
      g_alv_grid->set_current_cell_via_id(
      EXPORTING is_row_id    = ls_row
      is_column_id = ls_col ).
      g_alv_grid->set_scroll_info_via_id(
      EXPORTING is_row_info = ls_row
      is_col_info = ls_col ).
    CATCH cx_root.
  ENDTRY.
ENDFORM.

FORM analyze_change_state_detailed
  CHANGING ev_has_change          TYPE abap_bool
           ev_cnt_new_incomplete  TYPE i
           ev_cnt_new_complete    TYPE i
           ev_cnt_edited_existing TYPE i.

  FIELD-SYMBOLS: <lt>     TYPE STANDARD TABLE,
                 <ls>     TYPE any,
                 <newrec> TYPE any,
                 <cell>   TYPE any.

  DATA: lv_is_key_missing TYPE abap_bool,
        lv_keyname        TYPE dd03l-fieldname.

  CLEAR: ev_has_change, ev_cnt_new_incomplete, ev_cnt_new_complete, ev_cnt_edited_existing.

  " Đếm NEWREC và tình trạng khóa
  ASSIGN gr_data->* TO <lt>.
  IF <lt> IS ASSIGNED.
    LOOP AT <lt> ASSIGNING <ls>.
      ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls> TO <newrec>.
      IF sy-subrc = 0 AND <newrec> = 'X'.
        lv_is_key_missing = abap_false.
        LOOP AT gt_key_fields INTO lv_keyname.
          ASSIGN COMPONENT lv_keyname OF STRUCTURE <ls> TO <cell>.
          IF sy-subrc = 0 AND <cell> IS INITIAL.
            lv_is_key_missing = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF lv_is_key_missing = abap_true.
          ev_cnt_new_incomplete = ev_cnt_new_incomplete + 1.
        ELSE.
          ev_cnt_new_complete = ev_cnt_new_complete + 1.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  " Đếm sửa dòng cũ: bạn đã set gv_dirty khi sửa non-NEWREC trong handle_data_changed
  IF gv_dirty = abap_true.
    ev_cnt_edited_existing = 1.
  ENDIF.

  IF ev_cnt_new_incomplete > 0 OR ev_cnt_new_complete > 0 OR ev_cnt_edited_existing > 0.
    ev_has_change = abap_true.
  ENDIF.

ENDFORM.
FORM ensure_rowcolor_component CHANGING cr_tab TYPE REF TO data.
  DATA: lo_tab     TYPE REF TO cl_abap_tabledescr,
        lo_line    TYPE REF TO cl_abap_structdescr,
        lt_comp    TYPE abap_component_tab,
        ls_comp    TYPE abap_componentdescr,
        lo_any     TYPE REF TO cl_abap_typedescr,
        lo_newline TYPE REF TO cl_abap_structdescr,
        lo_newtab  TYPE REF TO cl_abap_tabledescr,
        lr_new     TYPE REF TO data,
        lr_row     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL.
    RETURN.
  ENDIF.

  " Mô tả kiểu hiện tại
  lo_tab  ?= cl_abap_typedescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp  = lo_line->get_components( ).

  " Đã có ROW_COLOR chưa?
  LOOP AT lt_comp INTO ls_comp WHERE name = 'ROW_COLOR'.
    RETURN.
  ENDLOOP.

  " Thêm ROW_COLOR: LVC_T_SCOL
  lo_any ?= cl_abap_typedescr=>describe_by_name( 'LVC_T_SCOL' ).
  CLEAR ls_comp.
  ls_comp-name = 'ROW_COLOR'.
  ls_comp-type ?= lo_any.
  APPEND ls_comp TO lt_comp.

  " Dựng lại line type
  lo_newline = cl_abap_structdescr=>create( lt_comp ).

  " Dựng lại table type (giữ đơn giản để tương thích release cũ)
  lo_newtab  = cl_abap_tabledescr=>create( p_line_type = lo_newline ).

  " Cấp phát & move dữ liệu cũ
  ASSIGN cr_tab->* TO <lt_old>.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    CREATE DATA lr_row TYPE HANDLE lo_newline.
    ASSIGN lr_row->* TO <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
    APPEND <ls_new> TO <lt_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.


"===== ZFA25SAP23_DB =====

" Tạo itab động dựa trên tên bảng
FORM ensure_dyn_itab USING iv_tab TYPE tabname
                     CHANGING cr_tab TYPE REF TO data.

  " Nếu đã có thì thôi
  IF cr_tab IS NOT INITIAL.
    CLEAR sy-subrc.
    RETURN.
  ENDIF.

  DATA lo_any    TYPE REF TO cl_abap_typedescr.
  DATA lo_struct TYPE REF TO cl_abap_structdescr.
  DATA lo_tab    TYPE REF TO cl_abap_tabledescr.

  " Chuẩn hóa tên bảng (đề phòng nhập thường)
  DATA(lv_tab) = iv_tab.
  TRANSLATE lv_tab TO UPPER CASE.

  TRY.
      lo_any = cl_abap_typedescr=>describe_by_name( lv_tab ).
    CATCH cx_root.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_struct ?= lo_any.
    CATCH cx_sy_move_cast_error.
      " KHÔNG MESSAGE – trả về im lặng
      sy-subrc = 4.
      RETURN.
  ENDTRY.

  TRY.
      lo_tab = cl_abap_tabledescr=>create( p_line_type = lo_struct ).
      CREATE DATA cr_tab TYPE HANDLE lo_tab.
      CLEAR sy-subrc.
    CATCH cx_root.
      sy-subrc = 4.
  ENDTRY.

ENDFORM.

"===== Load dữ liệu từ DB vào itab =====
FORM load_data USING    iv_tab TYPE tabname
                        iv_max TYPE i
               CHANGING cr_tab TYPE REF TO data
                        ev_rows TYPE i
                        ev_err  TYPE string.

  CLEAR: ev_rows, ev_err.

  " Chuẩn hóa tên bảng
  DATA(lv_tabname) = iv_tab.
  TRANSLATE lv_tabname TO UPPER CASE.

  " Validate DDIC
  TRY.
      DATA(lo_descr) = cl_abap_typedescr=>describe_by_name( lv_tabname ).
      IF lo_descr IS INITIAL.
        ev_err = |Bảng "{ lv_tabname }" không tồn tại hoặc không hợp lệ trong DDIC. Kiểm tra SE11.|.
        RETURN.
      ENDIF.
    CATCH cx_sy_create_data_error.
      ev_err = |Lỗi tạo type cho bảng "{ lv_tabname }": Bảng không active hoặc không tồn tại. Kiểm tra SE11.|.
      RETURN.
  ENDTRY.

  " Tạo itab động theo DDIC nếu chưa có
  PERFORM ensure_dyn_itab USING lv_tabname CHANGING cr_tab.

  FIELD-SYMBOLS: <lt_load> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_load>.
  IF <lt_load> IS NOT ASSIGNED.
    ev_err = 'Không assign được itab động.'.
    RETURN.
  ENDIF.

  " Refresh dữ liệu
  REFRESH <lt_load>.

  TRY.

      "--- Kiểm tra quyền truy cập theo authorization group ---
      DATA lv_authgrp TYPE tddat-cclass.
      CLEAR lv_authgrp.

      SELECT SINGLE cclass
        FROM tddat
        INTO @lv_authgrp
       WHERE tabname = @lv_tabname.

      IF sy-subrc = 0 AND lv_authgrp IS NOT INITIAL.
        AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
             ID 'DICBERCLS' FIELD lv_authgrp
             ID 'ACTVT'     FIELD '03'.
        IF sy-subrc <> 0.
          ev_err = |Không có quyền truy cập bảng { lv_tabname } (nhóm { lv_authgrp }). Kiểm tra SU53.|.
          RETURN.
        ENDIF.
      ENDIF.

      "=== Load dữ liệu chính ===
      IF iv_max > 0.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          UP TO @iv_max ROWS
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM (lv_tabname)
          INTO CORRESPONDING FIELDS OF TABLE @<lt_load>
          BYPASSING BUFFER
          ORDER BY PRIMARY KEY.
      ENDIF.
      ev_rows = sy-dbcnt.

      "=== Bổ sung 6 field audit nếu bảng gốc không có (ERDAT...AENAM) ===
      DATA: lo_tab_audit  TYPE REF TO cl_abap_tabledescr,
            lo_line_audit TYPE REF TO cl_abap_structdescr,
            lt_comp       TYPE abap_component_tab.

      lo_tab_audit ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
      lo_line_audit ?= lo_tab_audit->get_table_line_type( ).
      lt_comp = lo_line_audit->get_components( ).

      " Lấy danh sách field hiện có trong DDIC
      DATA: lt_dd03l    TYPE TABLE OF dd03l,
            lt_existing TYPE TABLE OF fieldname,
            lv_field    TYPE fieldname.

      SELECT fieldname
        FROM dd03l
        INTO TABLE @lt_dd03l
        WHERE tabname = @lv_tabname
          AND as4local = 'A'.

      LOOP AT lt_dd03l ASSIGNING FIELD-SYMBOL(<fld>).
        APPEND <fld>-fieldname TO lt_existing.
      ENDLOOP.

      " Danh sách các field audit cần có
      DATA lt_audit_fields TYPE TABLE OF string WITH EMPTY KEY.
      APPEND 'ERDAT' TO lt_audit_fields.
      APPEND 'ERTIM' TO lt_audit_fields.
      APPEND 'ERNAM' TO lt_audit_fields.
      APPEND 'AEDAT' TO lt_audit_fields.
      APPEND 'AETIM' TO lt_audit_fields.
      APPEND 'AENAM' TO lt_audit_fields.

      LOOP AT lt_audit_fields INTO lv_field.
        READ TABLE lt_existing WITH KEY table_line = lv_field TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CASE lv_field.
            WHEN 'ERDAT'. PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
            WHEN 'ERTIM'. PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
            WHEN 'ERNAM'. PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
            WHEN 'AEDAT'. PERFORM add_field_if_missing USING lv_field 'DATS' 8 lt_comp.
            WHEN 'AETIM'. PERFORM add_field_if_missing USING lv_field 'TIMS' 6 lt_comp.
            WHEN 'AENAM'. PERFORM add_field_if_missing USING lv_field 'CHAR' 12 lt_comp.
          ENDCASE.
        ENDIF.
      ENDLOOP.

      "=== Rebuild lại itab theo cấu trúc mới (AN TOÀN KIỂU) ===
      DATA lo_new_struct TYPE REF TO cl_abap_structdescr.
      DATA lo_new_tab    TYPE REF TO cl_abap_tabledescr.

      lo_new_struct = cl_abap_structdescr=>create( lt_comp ).
      lo_new_tab    = cl_abap_tabledescr=>create( p_line_type = lo_new_struct ).

      DATA lr_new TYPE REF TO data.
      CREATE DATA lr_new TYPE HANDLE lo_new_tab.

      FIELD-SYMBOLS: <lt_new>  TYPE STANDARD TABLE,
                     <row_old> TYPE any,
                     <row_new> TYPE any.
      ASSIGN lr_new->* TO <lt_new>.

      LOOP AT <lt_load> ASSIGNING <row_old>.
        APPEND INITIAL LINE TO <lt_new> ASSIGNING <row_new>.
        MOVE-CORRESPONDING <row_old> TO <row_new>.
      ENDLOOP.

      " đổi tham chiếu sang bảng mới (tránh copy bảng ↔ bảng)
      cr_tab = lr_new.
      UNASSIGN <lt_load>.
      ASSIGN cr_tab->* TO <lt_load>.

      "=== Sort theo khóa DDIC ===
      PERFORM ensure_keys USING iv_tab.
      IF gt_key_fields IS NOT INITIAL.
        DATA(lv_key) = gt_key_fields[ 1 ].
        IF lv_key IS NOT INITIAL.
          FIELD-SYMBOLS: <ls_row> TYPE any, <val> TYPE any.
          DATA(lv_all_numeric) = abap_true.

          LOOP AT <lt_load> ASSIGNING <ls_row>.
            ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
            IF sy-subrc <> 0 OR <val> IS INITIAL.
              CONTINUE.
            ENDIF.
            DATA(lv_raw) = CONV string( <val> ).
            CONDENSE lv_raw NO-GAPS.
            IF NOT lv_raw CO '0123456789'.
              lv_all_numeric = abap_false.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF lv_all_numeric = abap_true.

            " Lập bảng chỉ mục số
            TYPES: BEGIN OF ty_idx,
                     idx TYPE i,
                     num TYPE p LENGTH 16 DECIMALS 0,
                   END OF ty_idx.
            DATA: lt_idx TYPE STANDARD TABLE OF ty_idx,
                  ls_idx TYPE ty_idx,
                  lv_idx TYPE i VALUE 0.

            LOOP AT <lt_load> ASSIGNING <ls_row>.
              lv_idx += 1.
              ASSIGN COMPONENT lv_key OF STRUCTURE <ls_row> TO <val>.
              CLEAR ls_idx.
              ls_idx-idx = lv_idx.
              IF sy-subrc = 0 AND <val> IS ASSIGNED.
                DATA(lv_raw2) = CONV string( <val> ).
                CONDENSE lv_raw2 NO-GAPS.
                IF lv_raw2 CO '0123456789'.
                  ls_idx-num = lv_raw2.
                ENDIF.
              ENDIF.
              APPEND ls_idx TO lt_idx.
            ENDLOOP.

            SORT lt_idx BY num.

            " Build bảng đã sort MỚI rồi đổi ref (an toàn kiểu)
            DATA lr_sorted TYPE REF TO data.
            FIELD-SYMBOLS: <lt_sorted> TYPE STANDARD TABLE,
                           <ls_src>    TYPE any,
                           <ls_new2>   TYPE any.
            CREATE DATA lr_sorted LIKE <lt_load>.
            ASSIGN lr_sorted->* TO <lt_sorted>.

            LOOP AT lt_idx INTO ls_idx.
              READ TABLE <lt_load> INDEX ls_idx-idx ASSIGNING <ls_src>.
              IF sy-subrc = 0 AND <ls_src> IS ASSIGNED.
                APPEND INITIAL LINE TO <lt_sorted> ASSIGNING <ls_new2>.
                MOVE-CORRESPONDING <ls_src> TO <ls_new2>.
              ENDIF.
            ENDLOOP.

            cr_tab = lr_sorted.
            UNASSIGN <lt_load>.
            ASSIGN cr_tab->* TO <lt_load>.

          ELSE.
            SORT <lt_load> STABLE BY (lv_key).
          ENDIF.
        ENDIF.
      ENDIF.

    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động ===
  IF <lt_load> IS ASSIGNED AND <lt_load> IS NOT INITIAL.
    PERFORM merge_audit_log USING lv_tabname CHANGING <lt_load>.
  ENDIF.

  "=== Snapshot gốc để so sánh khi SAVE (an toàn & đơn giản) ===
  FIELD-SYMBOLS: <lt_orig>  TYPE STANDARD TABLE,
                 <ls_src_o> TYPE any,
                 <ls_dst_o> TYPE any.

  " Luôn tạo mới snapshot theo kiểu hiện tại của <lt_load>
  IF gr_data_original IS NOT INITIAL.
    FREE gr_data_original.
  ENDIF.
  CREATE DATA gr_data_original LIKE <lt_load>.

  ASSIGN gr_data_original->* TO <lt_orig>.
  REFRESH <lt_orig>.

  LOOP AT <lt_load> ASSIGNING <ls_src_o>.
    APPEND INITIAL LINE TO <lt_orig> ASSIGNING <ls_dst_o>.
    MOVE-CORRESPONDING <ls_src_o> TO <ls_dst_o>.
  ENDLOOP.

ENDFORM.






FORM save_data USING iv_tab TYPE tabname
               CHANGING cr_tab TYPE REF TO data
                        ev_mod TYPE i
                        ev_err TYPE string.

  ev_mod = 0.
  CLEAR ev_err.

  FIELD-SYMBOLS: <lt_alv> TYPE STANDARD TABLE.
  ASSIGN cr_tab->* TO <lt_alv>.
  IF <lt_alv> IS NOT ASSIGNED OR <lt_alv> IS INITIAL.
    ev_err = 'Không có dữ liệu để lưu.'.
    RETURN.
  ENDIF.

  "=== Fill audit fields tự động (ERDAT/ERTIM/ERNAM/AEDAT/AETIM/AENAM)
  FIELD-SYMBOLS: <ls_row> TYPE any,
                 <newrec> TYPE any,
                 <erdat>  TYPE any, <ertim> TYPE any, <ernam> TYPE any,
                 <aedat>  TYPE any, <aetim> TYPE any, <aenam> TYPE any.

  LOOP AT <lt_alv> ASSIGNING <ls_row>.
    ASSIGN COMPONENT 'NEWREC' OF STRUCTURE <ls_row> TO <newrec>.
    ASSIGN COMPONENT 'ERDAT'  OF STRUCTURE <ls_row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM'  OF STRUCTURE <ls_row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM'  OF STRUCTURE <ls_row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT'  OF STRUCTURE <ls_row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM'  OF STRUCTURE <ls_row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM'  OF STRUCTURE <ls_row> TO <aenam>.

    " Dòng mới -> chỉ set Created* nếu có cột và còn trống
    IF <newrec> IS ASSIGNED AND <newrec> = 'X'.
      IF <erdat> IS ASSIGNED AND <erdat> IS INITIAL. <erdat> = sy-datum. ENDIF.
      IF <ertim> IS ASSIGNED AND <ertim> IS INITIAL. <ertim> = sy-uzeit. ENDIF.
      IF <ernam> IS ASSIGNED AND <ernam> IS INITIAL. <ernam> = sy-uname. ENDIF.
    ENDIF.

    " Mọi trường hợp lưu -> set Changed*
    IF <aedat> IS ASSIGNED. <aedat> = sy-datum. ENDIF.
    IF <aetim> IS ASSIGNED. <aetim> = sy-uzeit. ENDIF.
    IF <aenam> IS ASSIGNED. <aenam> = sy-uname. ENDIF.
  ENDLOOP.

  "=== Build itab phẳng theo DDIC rồi upsert
  DATA lr_db_struct TYPE REF TO cl_abap_structdescr.
  DATA lr_db_table  TYPE REF TO cl_abap_tabledescr.
  DATA lr_flat      TYPE REF TO data.
  FIELD-SYMBOLS: <lt_flat> TYPE STANDARD TABLE,
                 <ls_flat> TYPE any,
                 <ls_alv>  TYPE any.

  lr_db_struct ?= cl_abap_typedescr=>describe_by_name( iv_tab ).
  lr_db_table = cl_abap_tabledescr=>create( p_line_type = lr_db_struct ).
  CREATE DATA lr_flat TYPE HANDLE lr_db_table.
  ASSIGN lr_flat->* TO <lt_flat>.

  LOOP AT <lt_alv> ASSIGNING <ls_alv>.
    APPEND INITIAL LINE TO <lt_flat> ASSIGNING <ls_flat>.
    MOVE-CORRESPONDING <ls_alv> TO <ls_flat>.

    FIELD-SYMBOLS <mandt> TYPE any.
    ASSIGN COMPONENT 'MANDT' OF STRUCTURE <ls_flat> TO <mandt>.
    IF sy-subrc = 0 AND <mandt> IS ASSIGNED.
      <mandt> = sy-mandt.
    ENDIF.
  ENDLOOP.

  TRY.
      MODIFY (iv_tab) FROM TABLE <lt_flat>.
      ev_mod = sy-dbcnt.
    CATCH cx_sy_dynamic_osql_semantics INTO DATA(lx_sem).
      ev_err = lx_sem->get_text( ).
    CATCH cx_sy_open_sql_db INTO DATA(lx_db).
      ev_err = lx_db->get_text( ).
  ENDTRY.

  "=== (tuỳ chọn) Ghi log audit chi tiết theo dòng
* IF ev_mod > 0.
*   LOOP AT <lt_alv> ASSIGNING FIELD-SYMBOL(<ls_alv_row>).
*     PERFORM log_audit_action USING iv_tab 'U' <ls_alv_row>.
*   ENDLOOP.
* ENDIF.

ENDFORM.
*---------------------------------------------------------------------*
* FORM log_audit_action - Ghi log thêm/sửa vào ZEDIT_AUDIT_LOG
*---------------------------------------------------------------------*
FORM log_audit_action USING iv_tabname TYPE tabname
                            iv_action  TYPE c
                            is_row     TYPE any.

  DATA: ls_log    TYPE zedit_audit_log,
        ls_old    TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        lv_ts_utc TYPE timestampl,
        lv_date   TYPE sydatum,
        lv_time   TYPE syuzeit.

  " Khóa log (chuẩn hóa theo key DDIC)
  PERFORM build_key_audit USING is_row CHANGING lv_key.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Lấy timestamp UTC hiện tại + convert sang giờ hiển thị
  GET TIME STAMP FIELD lv_ts_utc.
  PERFORM get_view_tzone CHANGING lv_tzone.
  CONVERT TIME STAMP lv_ts_utc TIME ZONE lv_tzone INTO DATE lv_date TIME lv_time.

  CLEAR ls_log.
  ls_log-mandt     = sy-mandt.
  ls_log-tabname   = lv_tab_up.
  ls_log-keyval    = lv_key.
  ls_log-action    = iv_action.

  " Upsert
  SELECT SINGLE * INTO @ls_old
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
      AND keyval  = @lv_key.

  IF sy-subrc <> 0.
    " ---- CHƯA CÓ LOG: chèn mới ----
    " Luôn set Created* cho lần đầu tiên
    ls_log-erdat       = lv_date.
    ls_log-ertim       = lv_time.
    ls_log-ernam       = sy-uname.
    ls_log-crt_ts_utc  = lv_ts_utc.

    " Nếu action là 'U' (rollback/update) mà chưa hề có log trước đó,
    " ta cũng set luôn Changed* để ALV có thể hiển thị Changed On/By/Time ngay lập tức.
    IF iv_action = 'U'.
      ls_log-aedat      = lv_date.
      ls_log-aetim      = lv_time.
      ls_log-aenam      = sy-uname.
      ls_log-chg_ts_utc = lv_ts_utc.
    ENDIF.

    INSERT zedit_audit_log FROM ls_log.

  ELSE.
    " ---- ĐÃ CÓ LOG: cập nhật Changed* khi action = 'U' ----
    IF iv_action = 'U'.
      UPDATE zedit_audit_log
         SET aedat      = @lv_date,
             aetim      = @lv_time,
             aenam      = @sy-uname,
             chg_ts_utc = @lv_ts_utc
       WHERE tabname    = @lv_tab_up
         AND keyval     = @lv_key.
    ENDIF.
  ENDIF.

  COMMIT WORK AND WAIT. "persist ngay để lần load sau/merge đọc được

ENDFORM.


FORM add_field_if_missing USING iv_name TYPE fieldname
                                 iv_type TYPE c
                                 iv_len  TYPE i
                         CHANGING ct_comp TYPE abap_component_tab.

  DATA ls_comp TYPE abap_componentdescr.
  DATA lv_type4 TYPE c LENGTH 4.

  lv_type4 = iv_type.  " Gán 4 ký tự đầu vào biến cố định

  " Kiểm tra field đã tồn tại chưa
  READ TABLE ct_comp WITH KEY name = iv_name TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    RETURN.
  ENDIF.

  CLEAR ls_comp.
  ls_comp-name = iv_name.

  CASE lv_type4.
    WHEN 'DATS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'DATS' ).
    WHEN 'TIMS'.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( 'TIMS' ).
    WHEN 'CHAR'.
      ls_comp-type ?= cl_abap_elemdescr=>get_c( iv_len ).
    WHEN OTHERS.
      ls_comp-type ?= cl_abap_elemdescr=>describe_by_name( lv_type4 ).
  ENDCASE.

  APPEND ls_comp TO ct_comp.

ENDFORM.

*---------------------------------------------------------------------*
* FORM merge_audit_log - Gắn dữ liệu audit (ERDAT...AENAM) vào ALV động
*---------------------------------------------------------------------*
FORM merge_audit_log USING    iv_tabname TYPE tabname
                     CHANGING ct_data    TYPE STANDARD TABLE.

  DATA: lt_audit  TYPE STANDARD TABLE OF zedit_audit_log,
        ls_audit  TYPE zedit_audit_log,
        lv_key    TYPE string,
        lv_tab_up TYPE tabname,
        lv_tzone  TYPE ttzz-tzone,
        d1        TYPE sydatum,
        t1        TYPE syuzeit,
        d2        TYPE sydatum,
        t2        TYPE syuzeit.

  FIELD-SYMBOLS: <row>   TYPE any,
                 <erdat> TYPE any,
                 <ertim> TYPE any,
                 <ernam> TYPE any,
                 <aedat> TYPE any,
                 <aetim> TYPE any,
                 <aenam> TYPE any.

  lv_tab_up = iv_tabname.
  TRANSLATE lv_tab_up TO UPPER CASE.

  " Đọc trực tiếp DB để lấy dữ liệu mới nhất vừa ghi log (tránh buffer)
  SELECT *
    FROM zedit_audit_log
    WHERE tabname = @lv_tab_up
    INTO TABLE @lt_audit
    BYPASSING BUFFER.

  IF lt_audit IS INITIAL.
    RETURN.
  ENDIF.

  PERFORM get_view_tzone CHANGING lv_tzone.

  LOOP AT ct_data ASSIGNING <row>.

    CLEAR lv_key.
    PERFORM build_key_audit USING <row> CHANGING lv_key.
    IF lv_key IS INITIAL.
      CONTINUE.
    ENDIF.

    CLEAR ls_audit.
    READ TABLE lt_audit INTO ls_audit
         WITH KEY tabname = lv_tab_up keyval = lv_key.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    CLEAR: d1, t1, d2, t2.
    IF ls_audit-crt_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-crt_ts_utc TIME ZONE lv_tzone
             INTO DATE d1 TIME t1.
    ENDIF.
    IF ls_audit-chg_ts_utc IS NOT INITIAL.
      CONVERT TIME STAMP ls_audit-chg_ts_utc TIME ZONE lv_tzone
             INTO DATE d2 TIME t2.
    ENDIF.

    ASSIGN COMPONENT 'ERDAT' OF STRUCTURE <row> TO <erdat>.
    ASSIGN COMPONENT 'ERTIM' OF STRUCTURE <row> TO <ertim>.
    ASSIGN COMPONENT 'ERNAM' OF STRUCTURE <row> TO <ernam>.
    ASSIGN COMPONENT 'AEDAT' OF STRUCTURE <row> TO <aedat>.
    ASSIGN COMPONENT 'AETIM' OF STRUCTURE <row> TO <aetim>.
    ASSIGN COMPONENT 'AENAM' OF STRUCTURE <row> TO <aenam>.

    " Fill created*
    IF <erdat> IS ASSIGNED.
      <erdat> = COND #( WHEN d1 IS INITIAL THEN ls_audit-erdat ELSE d1 ).
    ENDIF.
    IF <ertim> IS ASSIGNED.
      <ertim> = COND #( WHEN t1 IS INITIAL THEN ls_audit-ertim ELSE t1 ).
    ENDIF.
    IF <ernam> IS ASSIGNED.
      <ernam> = ls_audit-ernam.
    ENDIF.

    " Fill changed*
    IF <aedat> IS ASSIGNED.
      <aedat> = COND #( WHEN d2 IS INITIAL THEN ls_audit-aedat ELSE d2 ).
    ENDIF.

    " LƯU Ý: nếu trong bảng log là AETIME thay vì AETIM,
    " bạn vẫn có thể giữ gán như dưới vì nguồn là ls_audit-aetim/aetime.
    " Nếu DDIC của zedit_audit_log dùng AETIME, đổi dòng sau thành ls_audit-aetime.
    IF <aetim> IS ASSIGNED.
      <aetim> = ls_audit-aetim.
      " nếu field trong log là AETIME thì dùng:
      " <aetim> = ls_audit-aetime.
    ENDIF.

    IF <aenam> IS ASSIGNED.
      <aenam> = ls_audit-aenam.
    ENDIF.

  ENDLOOP.

ENDFORM.


FORM build_key_audit USING    is_row TYPE any
                     CHANGING ev_key TYPE string.

  DATA lv_val TYPE string.
  CLEAR ev_key.

  LOOP AT gt_key_fields ASSIGNING FIELD-SYMBOL(<kname>).
    ASSIGN COMPONENT <kname> OF STRUCTURE is_row TO FIELD-SYMBOL(<f>).
    IF sy-subrc = 0 AND <f> IS ASSIGNED.
      lv_val = <f>.
      CONDENSE lv_val NO-GAPS.
      IF ev_key IS INITIAL.
        ev_key = lv_val.
      ELSE.
        CONCATENATE ev_key lv_val INTO ev_key SEPARATED BY '|'.
      ENDIF.
    ENDIF.
  ENDLOOP.

  TRANSLATE ev_key TO UPPER CASE.
ENDFORM.

FORM get_view_tzone CHANGING ev_tzone TYPE ttzz-tzone.
  CLEAR ev_tzone.
  IF sy-zonlo IS NOT INITIAL.
    ev_tzone = sy-zonlo.
    RETURN.
  ENDIF.

  " hệ thống (nếu có cài đặt)
  DATA(lv_sys_tz) = VALUE ttzz-tzone( ).
  CALL FUNCTION 'GET_SYSTEM_TIMEZONE'
    IMPORTING
      timezone = lv_sys_tz
    EXCEPTIONS
      OTHERS   = 1.
  IF sy-subrc = 0 AND lv_sys_tz IS NOT INITIAL.
    ev_tzone = lv_sys_tz.
  ELSE.
    ev_tzone = 'UTC'.
  ENDIF.
ENDFORM.

FORM ts_utc_to_local USING    iv_ts_utc TYPE timestampl
                              iv_tzone  TYPE ttzz-tzone
                     CHANGING ev_date   TYPE sydatum
                              ev_time   TYPE syuzeit.
  CLEAR: ev_date, ev_time.
  IF iv_ts_utc IS INITIAL.
    RETURN.
  ENDIF.
  CONVERT TIME STAMP iv_ts_utc TIME ZONE iv_tzone
         INTO DATE ev_date TIME ev_time.
ENDFORM.

FORM dedup_fieldcat .

  FIELD-SYMBOLS: <fc> TYPE lvc_s_fcat.

  "===== Khai báo cấu trúc tạm lưu field đã gặp =====
  TYPES: BEGIN OF ty_seen,
           fieldname TYPE lvc_fname,
           idx       TYPE i,    " vị trí trong gt_fieldcat (để xóa)
           score     TYPE i,    " điểm ưu tiên
         END OF ty_seen.

  DATA: lt_seen TYPE STANDARD TABLE OF ty_seen WITH DEFAULT KEY,
        ls_seen TYPE ty_seen.

  DATA: lt_del TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
        lv_idx TYPE i,
        lv_scr TYPE i.

  LOOP AT gt_fieldcat ASSIGNING <fc>.
    lv_idx = sy-tabix.

    IF <fc>-fieldname IS INITIAL.
      CONTINUE.
    ENDIF.

    "===== Tính điểm ưu tiên cho field hiện tại =====
    CLEAR lv_scr.
    IF <fc>-coltext   IS NOT INITIAL. lv_scr = lv_scr + 4. ENDIF.
    IF <fc>-scrtext_l IS NOT INITIAL. lv_scr = lv_scr + 2. ENDIF.
    IF <fc>-scrtext_m IS NOT INITIAL. lv_scr = lv_scr + 1. ENDIF.
    IF <fc>-tech = abap_true OR <fc>-no_out = abap_true.
      lv_scr = lv_scr - 1.
    ENDIF.

    "===== Kiểm tra xem field này đã có chưa =====
    READ TABLE lt_seen INTO ls_seen WITH KEY fieldname = <fc>-fieldname.
    IF sy-subrc <> 0.
      " Lần đầu gặp field này
      CLEAR ls_seen.
      ls_seen-fieldname = <fc>-fieldname.
      ls_seen-idx       = lv_idx.
      ls_seen-score     = lv_scr.
      APPEND ls_seen TO lt_seen.
    ELSE.
      " Đã gặp rồi → chọn giữ bản tốt hơn
      IF lv_scr > ls_seen-score.
        " Bản mới tốt hơn → xóa bản cũ
        APPEND ls_seen-idx TO lt_del.
        ls_seen-idx   = lv_idx.
        ls_seen-score = lv_scr.
        MODIFY lt_seen FROM ls_seen TRANSPORTING idx score WHERE fieldname = ls_seen-fieldname.
      ELSE.
        " Bản mới kém hơn → xóa bản hiện tại
        APPEND lv_idx TO lt_del.
      ENDIF.
    ENDIF.
  ENDLOOP.

  "===== Xóa an toàn theo thứ tự giảm dần =====
  SORT lt_del DESCENDING.
  LOOP AT lt_del INTO lv_idx.
    IF lv_idx GT 0 AND lv_idx LE lines( gt_fieldcat ).
      DELETE gt_fieldcat INDEX lv_idx.
    ENDIF.
  ENDLOOP.

ENDFORM.


FORM normalize_itab_type CHANGING cr_tab TYPE REF TO data.
  DATA lo_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_line TYPE REF TO cl_abap_structdescr.
  DATA lt_comp TYPE abap_component_tab.

  FIELD-SYMBOLS: <lt_old> TYPE STANDARD TABLE,
                 <lt_new> TYPE STANDARD TABLE,
                 <ls_old> TYPE any,
                 <ls_new> TYPE any.

  IF cr_tab IS INITIAL. RETURN. ENDIF.
  ASSIGN cr_tab->* TO <lt_old>.
  IF <lt_old> IS INITIAL. RETURN. ENDIF.

  lo_tab  ?= cl_abap_tabledescr=>describe_by_data_ref( cr_tab ).
  lo_line ?= lo_tab->get_table_line_type( ).
  lt_comp = lo_line->get_components( ).

  DATA(lo_newline) = cl_abap_structdescr=>create( lt_comp ).
  DATA(lo_newtab)  = cl_abap_tabledescr=>create( lo_newline ).

  DATA lr_new TYPE REF TO data.
  CREATE DATA lr_new TYPE HANDLE lo_newtab.
  ASSIGN lr_new->* TO <lt_new>.

  LOOP AT <lt_old> ASSIGNING <ls_old>.
    APPEND INITIAL LINE TO <lt_new> ASSIGNING <ls_new>.
    MOVE-CORRESPONDING <ls_old> TO <ls_new>.
  ENDLOOP.

  cr_tab = lr_new.
ENDFORM.


"===== ZFA25SAP23_MAIN =====
START-OF-SELECTION.

DATA: lv_rows_main TYPE i,
lv_err_main TYPE string,
lt_meta TYPE ddfields. " metadata chi tiết

" 1. Lấy metadata đầy đủ từ DDIC
PERFORM get_metadata USING p_tab CHANGING lt_meta.

" 2. Tạo itab động cho bảng p_tab
PERFORM create_dynamic_itab USING p_tab CHANGING gr_data.
" 5. Load dữ liệu từ DB
PERFORM load_data USING p_tab p_maxrow
CHANGING gr_data lv_rows_main lv_err_main.
IF lv_err_main IS NOT INITIAL.
MESSAGE e398(00) WITH lv_err_main.
RETURN.
ENDIF.
" 5.1 Merge audit log ngay sau khi load
FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.
ASSIGN gr_data->* TO <lt_data>.
PERFORM ensure_keys USING p_tab.
IF <lt_data> IS ASSIGNED AND <lt_data> IS NOT INITIAL.
  PERFORM merge_audit_log USING p_tab CHANGING <lt_data>.
ENDIF.
" 3. Tạo fieldcatalog cho ALV
PERFORM build_fieldcat_all.

" 4. Đồng bộ fieldcatalog với itab động
PERFORM sync_fcat_with_itab CHANGING gt_fieldcat.

" 4.1 Đưa ERDAT về ngay trước nhóm Created*/Changed*
PERFORM reorder_audit_cols CHANGING gt_fieldcat.


" 6. Gọi screen hiển thị ALV
CALL SCREEN 100.